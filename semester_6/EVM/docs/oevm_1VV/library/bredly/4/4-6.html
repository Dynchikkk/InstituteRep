<html><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">



<body background="../images/bgrwhite.gif"><head>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
 <TITLE>Дэвид Дж. Брэдли</TITLE>
</head>



<h2>4.6. Логические операции</h2>

<p>
Следующий класс команд - логические команды. Эти команды, точно так же, как и арифметические команды, преобразуют данные, но делают это не арифметически. В то время как команды сложения и вычитания связаны со школьной арифметикой, логические команды работают со значениями 0 и 1, которые использует ЭВМ. В общем случае, эти команды позволяют программе выполнять
битовые операции.
<p>
Четырьмя основными логическими командами являются AND (и), OR (или), XOR (исключающее или), NOT (не). Существуют и другие логические функции, состоящие из этих четырех функций, но в микропроцессоре 8088 для них нет соответствующих команд. Эти четыре команды работают непосредственно с нулями и единицами двоичного кода.
<p>
Простейшая функция выполняется командой NOT. Эта команда основывается на определении единицы и
нуля, как истины (TRUE) и лжи (FALSE) соответственно. Предложение NOT TRUE (не истина) - это FALSE (ложь), а предложение NOT FALSE (не ложь) - это TRUE (истина). Команда NOT инвертирует все биты числа данных. Иначе говоря, команда NOT эквивалентна вычитанию данных из величины, состоящей из всех единиц. Фиг. 4.17 показывает, как оператор NOT действует на единственный бит.
<p>
<table align="center">
  <tr>
    <th class="center">Значение</th>
    <th class="center">Результат</th>
  </tr>
  <tr>
    <td class="center">0</td>
    <td class="center">1</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td class="center">0</td>
  </tr>
</table>
<p class="center">     
Фиг. 4.17 Операция NOT
<p>
Остальные три логические функции имеют два операнда. На Фиг.4.18 показаны результаты действий,
произведенных каждой функцией над парой бит.
<p>
<table align="center">
  <tr>
    <th class="center">X</th>
    <th class="center">Y</th>
    <th class="center">AND</th>
    <th class="center">OR</th>
    <th class="center">XOR</th>
  </tr>
  <tr>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">0</td>
  </tr>
  <tr>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="center">1</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td class="center">0</td>
    <td class="center">0</td>
    <td class="center">1</td>
    <td class="center">1</td>
  </tr>
  <tr>
    <td class="center">1</td>
    <td class="center">1</td>
    <td class="center">1</td>
    <td class="center">1</td>
    <td class="center">0</td>
  </tr>
</table>
<p class="center">     
Фиг. 4.18 Логические операции
<p>
Поскольку микропроцессор 8088 работает с байтами или словами, он повторяет результаты таблицы с каждым битом операнда. Например, байтовая команда выполняет логическое И со значениями нулевого бита обеих операндов а помещает результат в бит 0 результата. Затем эта команда повторяет функцию И с битами от первого до седьмого. В результате получается побитовая функция И
над отдельными битами операндов.
<p>
Функция AND равна 1 только тогда, когда оба операнда равны 1. В терминах истинности, результат есть истина только тогда, когда и X, и Y истинны. 
<p>
Функция OR дает 1, если хотя бы один из операндов равен 1. Результат есть истина, если либо X, либо Y являются истинными.
<p>
Результат функции XOR равен 1, только если один из операндов равен 1, а другой равен 0. Если же оба операнда равны 0, или оба равны 1, то результат равен 0. Функция исключающее ИЛИ в точности соответствует сложению, у которого игнорируется перенос.
<p>
Фиг. 4.19 иллюстрирует логические команды микропроцессора 8088. Команде NOT требуется один операнд, а ее форма идентична команде NEG. Остальные логические команды копируют синтаксис команд сложения и вычитания.
<p>
Когда микропроцессор 8088 делает логическую операцию, он устанавливает флаги в соответствии с
результатом. Так как операция не арифметическая, флаги переноса и переполнения всегда устанавливаются равными 0. Флаг дополнительного переноса после логических операций остается
неопределенным, в то время как другие флаги (знак, нуль) правильно отражают результат операции. Исключение представляет команда NOT, которая не изменяет ни одного флага.
<pre>
<tt>
Microsoft (R) Macro Assembler Version 5.00                  1/1/80 04:01:10
Фиг. 4.16 Фиг. 4.19 Логические команды                            Page  1-1
                         PAGE     ,132
                         TITLE    Фиг. 4.19 Логические команды
0000                     CODE     SEGMENT
                         ASSUME   CS:CODE,DS:CODE
0000    ????             X        DW        ?           ; Память для переменных
0000                     EXBYTE   LABEL     BYTE
0000                     EXWORD   LABEL     WORD
0000    22 06 0000 R              AND       AL, EXBYTE  ; AL &lt;- AL and [EXBYTE]
0004    81 E3 9FEF                AND       BX, 1001111111101111B  ; BX &lt;- BX and 9FEFH
0008    80 26 0000 R 03           AND       EXBYTE, 00000011B  ; [EXBYTE] &lt;- [EXBYTE] and 3
000D    08 2E 0000 R              OR        EXBYTE, CH  ; [EXBYTE] &lt;- [EXBYTE] or CH
0011    0B 16 0000 R              OR        DX, EXWORD  ; DX &lt;- DX or [EXWORD]
0015    0D FFF9                   OR        AX, 0FFF9H  ; AX &lt;- AX or 0FFF9H
0018    33 1E 0000 R              XOR       BX, EXWORD  ; BX &lt;- BX xor [EXWORD]
001C    30 1E 0000 R              XOR       EXBYTE, BL  ; [EXBYTE] &lt;- [EXBYTE] xor BL
0020    34 EF                     XOR       AL, 0EFH    ; AL &lt;- AL xor 0EFH
0022    F7 D1                     NOT       CX          ; CX &lt;- not CX
0024    F6 16 0000 R              NOT       EXBYTE      ; [EXBYTE] &lt;- not [EXBYTE]
0028    F7 06 0000 R 0003         TEST      EXWORD, 0003H  ; Установка флагов по [EXWORD] and 3
002E    84 E0                     TEST      AH, AL         ; Установка флагов по (AH and AL)
0030    A9 0002                   TEST      AX, 02H        ; Установка флагов по (AX and 2)
0033    D1 C1                     ROL       CX, 1       ; Циклический сдвиг влево на 1
0035    D3 0E 0000 R              ROR       EXWORD, CL  ; Циклический сдвиг вправо на CL
0039    D0 16 0000 R              RCL       EXBYTE, 1   ; Циклический сдвиг с переносом
                                                        ; влево на 1
003D    D3 DB                     RCR       BX, CL      ; Циклический сдвиг с переносом
                                                        ; вправо на CL
003F    D1 E0                     SHL       AX, 1       ; Сдвиг логический влево на 1
0041    D1 E0                     SAL       AX, 1       ; Сдвиг арифметический влево на 1
0043    D3 EB                     SHR       BX, CL      ; Сдвиг логический вправо на CL
0045    D0 3E 0000 R              SAR       EXBYTE, 1   ; Сдвиг арифметический вправо на 1
0049                     CODE     ENDS
                         END

                                  Фиг. 4.19 Логические команды
</tt>
</pre>
<p>
Первоочередное назначение логических операций в микропроцессоре 8088 - работа с битами. Самой малой единицей данных, с которой может работать этот микропроцессор, является байт. Ни одна из арифметических команд не может непосредственно выделить или изменить единственный бит, а логические команды позволяют программе обрабатывать отдельные биты.
<p>
Почему интересны однобитовые операции? Во многих случаях программа должна хранить значение
индикатора - истина - ложь. Этот бит может означать, что печатающее устройство занято, что нажата регистровая клавиша, или что инициализация программы выполнена. В таких случаях расточительно отводить байт для хранения единственного бита информации. Программа может объединить несколько таких битов в одном байте, если у нее есть способ выделения отдельных битов для их проверки и установки. Такое объединение однобитовых флагов очень широко
используется в устройствах ввода-вывода, которые имеют различные адреса. Устройству ввода-вывода гораздо проще работать с разными битами по одному адресу, чем распознавать многие адреса.
<p>
Логические команды могут выделить отдельные биты в байте или слове так, что они могут быть установлены, сброшены, проверены. Для выделения битов эти команды используют маску. Значение маски используется командой побитно. Чтобы установить какой-либо один бит, нужно использовать команду OR. В этом случае все значения маски - нули, кроме единицы на месте устанавливаемого бита. Команда OR над маской и другим операндом устанавливает 1 в выбранном бите, а другие биты результата оставляют неизменными. Аналогично, оператор AND может сбросить единственный
бит. В маске все разряды единичные, кроме сбрасываемого бита. Этот бит сбросится в 0, а остальные останутся без изменений.
<p>
Программисты не используют функцию исключающее или столь же часто, как команды AND и OR, но она тоже бывает полезна. Команда может выполнить взаимное дополнение одного бита с данными. Запишите маску для команды XOR так, чтобы на месте инвертируемого бита была 1, а на всех других местах 0. Когда команда XOR выполнится, биты, соответствовавшие нулям, останутся без изменений, а биты, соответствовавшие единицам маски, инвертируются. Если начальное значение бита было 0, 1 XOR 0 дает 1, дополнение к 0, а еслиначальное значение было 1, 1 XOR 1 дает 0, дополнение к 1.
<p>
Последняя логическая команда - TEST (проверка). Эта команда идентична команде AND, за исключением того, что она не записывает результат, но устанавливает флаги в соответствии с ним, т.е. команда TEST соответствует команде AND, как команда CMP соответствует команде SUB. Эта команда проверяет заданный бит, или набор битов внутри байта или слова.
<p>
Как работает команда проверки? Предположим, программа хочет проверить младший значащий бит байта, бит 0. Программа порождает маску 01H либо в регистре, либо как непосредственное значение. Команда TEST (или AND) дает результат с гарантированными нулями по всем позициям, за исключением бита 0; значение бита 0 отражает значение оригинала. Если нулевой бит оригинала содержит 0, то бит остается нулевым. Если он сначала единичен, результат ненулевой, и флаг нуля сбрасывается; если же бит 0, результат нулевой, и флаг нуля устанавливается. Таким образом,
программа может проверить единственный бит, выполняя команды TEST и AND с маской, которая имеет единственную единицу на месте проверяемого бита; регистр флагов отразит состояние этого
единственного бита. Команда TEST проверяет заданный бит без разрушения других битов, поскольку эта команда не изменяет поле результата.

<p><div align="center"><a href="../index.html"><img src="../images/index.gif" border=0 alt=""></a></div><p></p>

</body>
</html>
