<html><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">



<body background="../images/bgrwhite.gif">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
 <TITLE>Дэвид Дж. Брэдли</TITLE>
<h2>8.9. Адаптер управления играми</h2>

<p>
Адаптер управления играми подключает к системе джойстики и другие органы управления игрой. Это все аналоговые устройства - т.е., они не могут работать с нулями и единицами. Их входные значения - это сопротивление, которое ЭВМ не может прочитать непосредственно. р управления играми преобразует значение сопротивления в нечто такое, с чем ЭВМ может иметь дело.
<p>
Адаптер управления играми не преобразует значение сопротивления непосредственно в двоичное число. Вместо этого адаптер преобразует значение сопротивления во временную задержку. Чем больше сопротивление, тем больше временная задержка. Эту задержку компьютер может измерить. Преобразовать задержку в число, соответствующее положению джойстика, можно программным способом. Нашей задачей является написание программы, которая преобразует временную задержку в число.
<p>
Адаптер управления играми обслуживает до четырех входов сопротивления. Механизм временной задержки по каждому из этих входов подключен к отдельному биту порта ввода-вывода 201H. Когда вы выводите любое число в порт 201H, четыре его младших бита сбрасываются в 0. Биты озвращаются в состояние 1 после некоторого интервала времени. Этот интервал времени определяется значением сопротивления, подключенного к адаптеру. Программа на Фиг. 8.18 - это пример определения значения сопротивления двух из четырех входных портов. Эта программа использует простой метод. Вместо определения временной задержки всех четырех портов одновременно, она обслуживает их последовательно. Количество времени, нужного для определения одной задержки, невелико. В результате, поочередная обработка этих задержек вместо одновременной выполняется без проблем.
<pre>
<tt>
Microsoft (R) Macro Assembler Version 5.00                  1/1/80 04:03:56
Фиг. 8.18 Адаптер управления играми                               Page  1-1
PAGE  ,132
                         TITLE    Фиг. 8.18 Адаптер управления играми

      = 0201             GAME_PORT     EQU    201H

0000                     STACK    SEGMENT STACK
0000    0040[                     DW        64 DUP (?)
             ????
            ]
0080                     STACK    ENDS

0000                     CODE     SEGMENT
0000                     GAME_CONTROL       PROC    FAR
0000    1E                        PUSH      DS            ; Адрес возврата
0001    2B C0                     SUB       AX, AX
0003    50                        PUSH      AX
0004    BA 0201                   MOV       DX, GAME_PORT
0007    B8 B000                   MOV       AX, 0B000H    ; Сегмент дисплейной памяти
000A    8E D8                     MOV       DS, AX
000C    B5 21                     MOV       CH, 21H ; Символ, который будет записываться в буфер
000E    B1 00                     MOV       CL, 0
0010                     WRITE_LOOP:
0010    B4 01                     MOV       AH, 1         ; Выбор координаты X
0012    E8 0042 R                 CALL      POSITION
0015    8B D8                     MOV       BX, AX        ; Сохранение координаты X в буфере
0017    D1 EB                     SHR       BX, 1
0019    D1 EB                     SHR       BX, 1         ; Деление на 4
001B    B4 02                     MOV       AH, 2         ; Выбор координаты Y
001D    E8 0042 R                 CALL      POSITION
0020    D0 E8                     SHR       AL, 1
0022    D0 E8                     SHR       AL, 1
0024    D0 E8                     SHR       AL, 1
0026    D0 E8                     SHR       AL, 1         ; Деление на 16
0028    B4 A0                     MOV       AH, 160
002A    F6 E4                     MUL       AH            ; Преобразование в смещение в буфере
002C    03 D8                     ADD       BX, AX
002E    88 2F                     MOV       [BX], CH      ; Сохранение символа
0030    EC                        IN        AL, DX
0031    24 10                     AND       AL, 10H
0033    3A C1                     CMP       AL, CL
0035    74 D9                     JE        WRITE_LOOP
0037    8A C8                     MOV       CL, AL
0039    80 F9 10                  CMP       CL, 10H
003C    75 D2                     JNE       WRITE_LOOP
003E    FE C5                     INC       CH            ; Следующий символ
0040    EB CE                     JMP       WRITE_LOOP
0042                     GAME_CONTROL       ENDP
                         ;-----   В AH бит маски
0042                     POSITION PROC      NEAR
0042    51                        PUSH      CX
0043    2B C9                     SUB       CX, CX        ; Начальное значение для цикла ввода
0045    EE                        OUT       DX, AL        ; Запуск таймера
0046                     POS_LOOP:
0046    EC                        IN        AL, DX
0047    84 C4                     TEST      AL, AH
0049    E0 FB                     LOOPNE    POS_LOOP  ; Цикл пока 1 - таймер не закончил отсчет
004B    B8 0000                   MOV       AX, 0
004E    2B C1                     SUB       AX, CX        ; Определение значения счетчика
0050    59                        POP       CX            ; в диапазоне 0-255
0051    C3                        RET
0052                     POSITION ENDP
0052                     CODE     ENDS
                         END

                                  Фиг. 8.18 Адаптер управления играми (продолжение)
</tt>
</pre>
<p>
Последняя часть программы на Фиг. 8.18 берет позицию X-Y, определенную по входу от джойстика, и записывает символ в соответствующую позицию дисплея. Адаптер управления играми также допускает четыре переключающих ввода, значения которых можно прочитать в старших четырех битах порта 201H. Программа в примере опрашивает один из этих битов переключения, чтобы перейти от одного символа к другому и вывести его на экран.

<p><div align="center"><a href="../index.html"><img src="../images/index.gif" border=0 alt=""></a></div><p></p>

</body>
</html>
