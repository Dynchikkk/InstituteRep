<html>

<head>
<title>4. Использование функций IOCTL </title>
</head>

<body BGCOLOR="#ffffff">

<h2><font SIZE="5" COLOR="#FF0000">4. Использование функций IOCTL</font>
</h2>

<p>4.1. <a HREF="ch4.htm#ch4_1">Получение различной информации</a>
</p>

<p>4.2. <a HREF="ch4.htm#ch4_2">Общее управление
вводом/выводом</a> </p>

<p>В разделе книги, посвященным драйверам, мы
рассказывали о функции управления
вводом/выводом <b>IOCTL</b> - функции <b>44h</b> прерывания <b>INT&nbsp;21h</b>.
Эта функция предоставляет широкие возможности
по управлению устройствами ввода/вывода
посредством обмена управляющей информацией с
драйверами устройств. </p>

<p>В этом разделе мы вновь вернемся к функциям <b>IOCTL</b>
для того, чтобы рассказать об их использовании
при работе с дисковой подсистемой. </p>

<p>Мы покажем, как использовать функцию <b>44h</b>
прерывания <b>INT&nbsp;21h</b> для извлечения
разнообразной информации об открытых файлах по
их файловому индексу, для определения момента
достижения конца файла, для получения информации
об дисководах и для выполнения таких
низкоуровневых операций, как форматирование
дорожки диска, чтение/запись секторов диска и т.д.
</p>

<p>Напомним, при вызове функции <b>44h</b> регистр <b>AL</b>
содержит код выполняемой подфункции. Для
подфункции <b>0Dh</b> (<b>Generic IO Control</b>) в регистре <b>CL</b>
должен находиться код выполняемой операции. </p>

<h3><a NAME="ch4_1"><font SIZE="4" COLOR="#008000">4.1. Получение
различной информации</font></a></h3>

<p>С помощью подфункции <b>00h</b> можно получить
информацию об открытом файле или устройстве по
файловому индексу. </p>

<p>Для удобства работы с этой подфункцией мы
подготовили следующую программу: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      get_devi
*
*.Title     Получить информацию об устройстве
*
*.Descr     Функция получает информацию о файле
*           или об устройстве по его файловому индексу.
*
*
*.Params    int get_devi(int handle, int *info);
*
*           handle      - файловый индекс для
*                         которого необходимо получить
*                         информацию
*
*           info        - указатель на слово, в которое
*                         должна быть записана информация
*
*.Return    0          - если нет ошибок;
*           Код ошибки - если произошла ошибка.
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int get_devi(int handle, int *info) {

         union REGS reg;

// Заполняем регистровые структуры для вызова
// прерывания DOS INT 21h. Код используемой
// подфункции - 00h.

         reg.x.ax = 0x4400;
         reg.x.bx = handle;

// Вызываем прерывание

         intdos(&amp;reg, &amp;reg);

// Проверяем флаг переноса

         if(reg.x.cflag == 0) {

// Если флаг переноса сброшен в 0, ошибок нет.
// Записываем информацию по адресу *info

          *info = reg.x.dx;
          return(0);

         }

// Если флаг переноса установлен в 1, возвращаем
// код ошибки

         else return(reg.x.ax);
}</font>
</pre>

<p>Приведенная выше функция принимает в качестве
первого параметра файловый индекс открытого
файла или устройства и адрес слова, в который она
запишет информацию об устройстве или файле,
связанном с этим файловым индексом. </p>

<p>Вы можете использовать эту функцию так, как это
сделано в следующем примере: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]);

void main(int argc, char *argv[]) {

         int handle;
         int info;
         int rc;

// Открываем файл или устройство с заданным именем

         handle = open(argv[1], O_RDONLY);

// Если открыть невозможно, выводим сообщение
// и завершаем работу программы

         if(handle == -1) {
                printf(&quot;Не могу открыть файл!\n&quot;);
                exit(-1);
         }

// Получаем информацию для файлового индекса handle

         rc = get_devi(handle, &amp;info);

         if(rc != 0) {
                printf(&quot;Ошибка с кодом %d\n&quot;, rc);
                exit(-1);
         }

         printf(&quot;\nСлово информации об устройстве: %04X&quot;,info);

         close(handle);
}</font>
</pre>

<p>В качестве параметра при запуске этой
программы попробуйте задавать имена файлов или
имена устройств, например -<b> CON, AUX</b>, и т.д. </p>

<p>Мы уже описывали формат слова, содержащего
информацию об устройстве или файле, для удобства
приведем его еще раз. </p>

<p>Для устройства:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="67"><i><b>Бит</b></i></td>
    <td WIDTH="422"><i><b>Значение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>0</b></td>
    <td WIDTH="422">Это устройство является стандартным
    устройством ввода. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>1</b></td>
    <td WIDTH="422">Стандартное устройство вывода. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>2</b></td>
    <td WIDTH="422"><b>NUL</b>-устройство. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>3</b></td>
    <td WIDTH="422">Часы.</td>
  </tr>
  <tr>
    <td WIDTH="67"><b>4</b></td>
    <td WIDTH="422">Специальное устройство. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>5</b></td>
    <td WIDTH="422"><b>1</b> - двоичный режим работы; <br>
    <b>0</b> - режим ASCII </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>6</b></td>
    <td WIDTH="422"><b>0</b> - при чтении достигнут конец файла. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>7</b></td>
    <td WIDTH="422"><b>1</b> - это слово информации относится к
    устройству (данный handle относится к устройству); <br>
    <b>0</b> - слово информации относится к файлу. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>8-10</b></td>
    <td WIDTH="422">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>11</b></td>
    <td WIDTH="422"><b>1</b> - Устройство поддерживает команды
    открытия/закрытия. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>12</b></td>
    <td WIDTH="422">Сетевое устройство (только для DOS версии
    3.0 и более поздних версий). </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>13</b></td>
    <td WIDTH="422">Устройство поддерживает вывод до
    состояния занятости. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>14</b></td>
    <td WIDTH="422">Устройство может обрабатывать
    управляющие строки <b>IOCTL</b>, посылаемые
    подфункциями <b>2, 3, 4, 5</b> функции <b>44h</b>. Этот бит
    может быть только прочитан, его установка
    подфункцией <b>1</b> функции <b>44h</b> не производится. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>15</b></td>
    <td WIDTH="422">Зарезервировано. </td>
  </tr>
</table>

<p>Для файла:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="87"><i><b>Бит</b></i></td>
    <td WIDTH="401"><i><b>Значение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>0-5</b></td>
    <td WIDTH="401">Номер дисковода (<b>0-А:, 1-В: </b>и т.д.). </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>6</b></td>
    <td WIDTH="401"><b>0</b> - Была запись в выходной файл. </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>7</b></td>
    <td WIDTH="401"><b>1</b> - это слово информации относится к
    устройству (данный handle относится к устройству); <br>
    <b>0</b> - слово информации относится к файлу. </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>8-11</b></td>
    <td WIDTH="401">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>12</b></td>
    <td WIDTH="401">Сетевое устройство (только для DOS версии
    3.0 и более поздних версий). </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>13-14</b></td>
    <td WIDTH="401">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>15</b></td>
    <td WIDTH="401"><b>1</b> - Данный файл является удаленным
    при работе в сети (только для DOS версии 3.0 и более
    поздних версий). </td>
  </tr>
</table>

<p>Подфункция <b>06h</b> функции <b>44h</b> прерывания <b>INT&nbsp;21h</b>
поможет вам определить момент достижения конца
файла или готовность устройства посимвольной
обработки. </p>

<p>Для проверки условия &quot;Конец файла&quot; или
готовности устройства можно использовать
следующую функцию: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      heof
*
*.Title     Проверить условие &quot;Конец файла&quot;
*
*.Descr     Функция позволяет проверить факт достижения
*           конца файла или готовность устройства
*
*.Params    int heof(int handle);
*
*           handle      - файловый индекс для
*                         которого необходимо получить
*                         информацию о состоянии
*
*.Return    0           - конец файла не достигнут (для файла),
*                         устройство готово (для устройства);
*
*           1           - достигнут конец файла (для файла),
*                         устройство не готово (для устройства);
*
*          -1           - произошла ошибка.
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int heof(int handle) {

         union REGS reg;

// Заполняем регистровые структуры для вызова
// прерывания DOS INT 21h. Код используемой
// подфункции - 06h.

         reg.x.ax = 0x4406;
         reg.x.bx = handle;

// Вызываем прерывание

         intdos(&amp;reg, &amp;reg);

// Проверяем флаг переноса

         if(reg.x.cflag == 0) {

// Если флаг переноса сброшен в 0, ошибок нет.

          if(reg.h.al == 0) return(1);
          else return(0);

         }

// Если флаг переноса установлен в 1, возвращаем
// признак ошибки

         else return(-1);
}</font>
</pre>

<p>Вы можете использовать эту функцию аналогично
функции<b> eof().</b> В приведенном ниже примере
программы, копирующей файлы, мы так и поступили: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys\types.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;

void main(int, char *[]);
void main(int argc, char *argv[]) {

         int source, target, i;
         char *buffer;
         unsigned count;

         if(argc == 3) {

// Открываем исходный копируемый файл

                 if((source = open(argv[1], O_BINARY | O_RDONLY)) == - 1) {

                          printf(&quot;\nОшибка при открытии исходного файла: %d&quot;,
                          errno);
                          exit(-1);

                 }

// Открываем выходной файл. При необходимости создаем
// новый. Если файл уже существует, выводим на экран
// запрос на перезапись содержимого существующего файла

                target = open(argv[2], O_BINARY | O_WRONLY | O_CREAT | O_EXCL,
                                                                         S_IREAD | S_IWRITE);
                if(errno == EEXIST) {

                        printf(&quot;\nФайл существует. Перезаписать? (Y,N)\n&quot;);

// Ожидаем ответ оператора и анализируем его

                        i = getch();
                        if((i == 'y') || (i == 'Y'))
                                target = open(argv[2], O_BINARY | O_WRONLY | O_CREAT | O_TRUNC,
                                                 S_IREAD | S_IWRITE);

                }

// Если выходной файл открыть невозможно, выводим
// сообщение об ошибке и завершаем работу программы

                if(target == -1){
                          printf(&quot;\nОшибка при открытии выходного файла: %d&quot;,
                          errno);
                          exit(-1);
                }

// Будем читать и писать за один раз 10000 байтов

                count = 10000;

// Заказываем буфер для передачи данных

                if((buffer = (char *)malloc(count)) == NULL) {
                          printf(&quot;\nНедостаточно оперативной памяти&quot;);
                          exit(-1);
                }


// Копируем исходный файл

                while(!heof(source)) {

// Читаем count байтов в буфер buffer

                        if((count = read(source, buffer, count)) == -1) {
                          printf(&quot;\nОшибка при чтении: %d&quot;,
                          errno);
                          exit(-1);
                        }

// Выполняем запись count байтов из буфера в выходной файл

                        if((count = write(target, buffer, count)) == - 1) {
                          printf(&quot;\nОшибка при записи: %d&quot;,
                          errno);
                          exit(-1);
                        }
                }

// Закрываем входной и выходной файлы

                close(source);
                close(target);

// Освобождаем память, заказанную под буфер

                free(buffer);
         }

// Если при запуске программы не были указаны
// пути для входного или выходного файла,
// выводим сообщение об ошибке

         else
                  printf(&quot;\n&quot;
                        &quot;Задайте пути для исходного&quot;
                        &quot; и результирующего файлов!\n&quot;);
}</font>
</pre>

<p>Подфункция <b>0Ah</b> функции <b>44h</b> прерывания <b>INT&nbsp;21h</b>
поможет программе, работающей в сети, определить
расположение открытого файла или устройства - на
рабочей станции или на сервере. </p>

<p>Перед вызовом запишите в регистр <b>BX</b> файловый
индекс проверяемого файла или устройства. </p>

<p>После возврата из подфункции регистр <b>DX</b>
содержит слово атрибутов для файла или
устройства. Если самый старший бит в этом слове
равен <b>0</b>, то файл или устройство является
локальным и расположено на рабочей станции. Если
же этот бит равен <b>1</b>, то файл или устройство
удаленное и находится на сервере (подключено к
серверу, если проверяется устройство). </p>

<p>Обычно программы составляют таким образом,
чтобы их работа не зависела от расположения. Но
если такая информация вам когда-либо
понадобится, вы можете воспользоваться
подфункцйией <b>0Ah</b>. </p>

<p>Аналогично для проверки расположения
дисковода можно использовать подфункцию <b>09h</b>. </p>

<p>Перед вызовом запишите в регистр <b>BL</b> код
дисковода (<b>0</b>-текущий дисковод, <b>1</b> <b>- А:, 2 - В:,</b>
и т.д.). Двенадцатый бит регистра <b>DX</b> после
вызова этой функции покажет вам расположение
дисковода: <b>0</b> - локальное, <b>1</b> - удаленное. </p>

<p>Для проверки возможности замены носителя
данных в дисководе вы можете воспользоваться
подфункцией <b>08h</b>. Используя эту подфункцию, вы
сможете отличить НГМД от НМД. Это может вам
понадобиться, например, для операции
форматирования, так как форматирование НГМД и
НМД выполняется по-разному. </p>

<p>Перед вызовом подфункции <b>08h</b> запишите код
устройства в регистр <b>BL</b> (<b>0 </b>-текущий
дисковод, <b>1 - А:, 2 - В:,</b> и т.д.). Если носитель
данных сменный, то после выполнения подфункции
регистр <b>AL</b> будет содержать <b>0</b>, в противном
случае - <b>1</b>. </p>

<p>Эта подфункция не предназначена для работы с
сетевыми устройствами. </p>

<h3><a NAME="ch4_2"><font SIZE="4" COLOR="#008000">4.2. Общее управление
вводом/выводом</font></a></h3>

<p>Подфункция <b>0Dh</b> функции <b>44h</b> прерывания <b>INT&nbsp;21h</b>
обеспечивает механизм взаимодействия между
прикладным программным обеспечением и
драйверами блочных устройств. Эта подфункция
позволяет программам читать и изменять
параметры устройств, предоставляет возможность
выполнять аппаратно-независимое чтение, запись,
форматирование и проверку дорожек диска. </p>

<p>Эта подфункция была уже нами описана в разделе,
посвященном драйверам. </p>

<p>Для удобства приведем формат вызова этй
подфункции еще раз: </p>

<h4><font SIZE="2">0Dh Общее управление вводом/выводом GENERIC
IOCTL</font> </h4>

<p>Вызов:<br>
</p>

<table>
  <tr>
    <td WIDTH="107"><i><b>Регистр</b></i></td>
    <td WIDTH="395"><i><b>Содержание</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>AH</b></td>
    <td WIDTH="395"><b>44h</b></td>
  </tr>
  <tr>
    <td WIDTH="107"><b>AL</b></td>
    <td WIDTH="395"><b>0Dh</b></td>
  </tr>
  <tr>
    <td WIDTH="107"><b>BL</b></td>
    <td WIDTH="395">Номер дисковода (<b>0</b> - текущий дисковод,
    <b>1</b> - дисковод <b>А:</b> и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>CH</b></td>
    <td WIDTH="395">Код категории устройства: <b>08h</b> -
    дисковое устройство </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>CL</b></td>
    <td WIDTH="395">Операция: <br>
    40h - установить параметры устройства; <br>
    60h - получить параметры устройства; <br>
    41h - записать дорожку на логическом устройстве; <br>
    61h - прочитать дорожку на логическом устройстве; <br>
    42h - форматировать дорожку на логическом
    устройстве; <br>
    62h - проверить дорожку на логическом устройстве </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>DS:DX</b></td>
    <td WIDTH="395">Указатель на блок параметров. </td>
  </tr>
</table>

<p>Возврат без ошибки:<br>
</p>

<table>
  <tr>
    <td WIDTH="105"><i><b>Регистр</b></i></td>
    <td WIDTH="396"><i><b>Содержание</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="105"><b>CF</b></td>
    <td WIDTH="396">0</td>
  </tr>
</table>

<p>Возврат с ошибкой:<br>
</p>

<table>
  <tr>
    <td WIDTH="104"><i><b>Регистр</b></i></td>
    <td WIDTH="399"><i><b>Содержание</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="104"><b>CF</b></td>
    <td WIDTH="399">1</td>
  </tr>
  <tr>
    <td WIDTH="104"><b>AX</b></td>
    <td WIDTH="399">Код ошибки</td>
  </tr>
</table>

<p>Формат блока параметров зависит от выполняемой
операции: </p>

<p>CL = 40h/60h (получить/установить параметры
устройства) </p>

<table BORDER="1">
  <tr>
    <td WIDTH="132"><i><b>Смещение</b></i></td>
    <td WIDTH="87"><i><b>Размер</b></i> </td>
    <td WIDTH="283"><i><b>Содержимое поля</b></i></td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(0)</b></td>
    <td WIDTH="87">1</td>
    <td WIDTH="283">Специальные функции: </td>
  </tr>
  <tr>
    <td WIDTH="132">(+1)</td>
    <td WIDTH="87">1</td>
    <td WIDTH="283">Тип устройства, возвращаемый драйвером: <br>
    <br>
    0 - 320/360 К флоппи-диск (5&quot;);<br>
    1 - 1,2 М флоппи-диск (5&quot;);<br>
    2 - 720 К флоппи-диск (3&quot;);<br>
    3 - 8&quot; флоппи-диск нормальной плотности;<br>
    4 - 8&quot; флоппи-диск двойной плотности;<br>
    5 - жесткий диск;<br>
    6 - накопитель на магнитной ленте;<br>
    7 - 1,44 М флоппи-диск (3&quot;) и прочие дисковые
    устройства. </td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(+2)</b></td>
    <td WIDTH="87">2</td>
    <td WIDTH="283">Атрибуты устройства, возвращаемые
    драйвером. В этом поле используются только два
    младших бита. <br>
    Бит 0 - признак заменяемости среды носителя
    данных (0 - заменяемая, 1 - не заменяемая), <br>
    бит 1 - признак наличия аппаратного контроля
    замены дискеты (1 - контроль выполняется, 0 -
    контроль не выполняется). Остальные биты
    зарезервированы и должны содержать 0. </td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(+4)</b></td>
    <td WIDTH="87">2</td>
    <td WIDTH="283">Максимальное количество цилиндров на
    физическом устройстве. Это поле устанавливается
    драйвером. </td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(+6)</b></td>
    <td WIDTH="87">1</td>
    <td WIDTH="283">Тип среды носителя данных. Используется
    для устройств, поддерживающих несколько типов
    носителей данных, например, для флоппи-дисковода
    на 1.2М значение этого поля, равное 0,
    соответствует дискете на 1.2М, а 1 - 360К. </td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(+7)</b></td>
    <td WIDTH="87">31</td>
    <td WIDTH="283"><b>BPB</b> для устройства. Если бит 0 поля
    специальных функций сброшен, то в этом поле
    находится новый <b>BPB</b> для устройства. Если бит 0
    установлен, драйвер устройства возвращает <b>BPB</b>
    для всех последующих запросов на построение <b>BPB</b>.
    </td>
  </tr>
  <tr>
    <td WIDTH="132"><b>(+38)</b></td>
    <td WIDTH="87">?</td>
    <td WIDTH="283">Таблица разметки дорожки, имеет
    переменную длину. </td>
  </tr>
</table>

<p>Биты специальных функций </p>

<table>
  <tr>
    <td WIDTH="576"><i><b>Бит 0:</b></i></td>
  </tr>
  <tr>
    <td WIDTH="576">В операции 60h значение этого бита, равное
    1, используется для извлечения текущего BPB, как
    если бы он был получен по команде драйвера с
    кодом 2 (построить BPB). Значение этого бита, равное
    0, говорит о том, что надо извлечь BPB, используемый
    по умолчанию. Для операции с кодом 40h значение
    бита, равное 1, используется для извлечения
    текущего BPB, значение 0 приводит к использованию
    BPB, подготовленного в данном блоке параметров; </td>
  </tr>
  <tr>
    <td WIDTH="576"><i><b>Бит 1:</b></i></td>
  </tr>
  <tr>
    <td WIDTH="576">Значение этого бита, равное 1 - это
    указание игнорировать все поля в блоке
    параметров, кроме поля описания физической
    структуры дорожки на данном устройстве; </td>
  </tr>
  <tr>
    <td WIDTH="576"><i><b>Бит 2:</b></i></td>
  </tr>
  <tr>
    <td WIDTH="576">Значение этого бита, равное 1, говорит о
    том, что все сектора на этой дорожке имеют
    одинаковый размер </td>
  </tr>
</table>

<p>Таблица разметки дорожки начинается с
двухбайтового слова, содержащего общее
количество секторов на дорожке. Затем для
каждого сектора в таблице находится по два
двухбайтовых слова, содержащих номер сектора (1, 2
и т.д.) и размер сектора. То есть для каждого
сектора в таблице содержится два слова. </p>

<p>Если в поле &quot;специальные функции&quot; бит <b>2</b>
установлен в 1, размеры всех секторов должны быть
одинаковыми. </p>

<p>CL = 41h/61h (записать/прочитать дорожку) </p>

<table BORDER="1">
  <tr>
    <td WIDTH="107"><i><b>Смещение</b></i></td>
    <td WIDTH="91"><i><b>Размер</b></i> </td>
    <td WIDTH="295"><i><b>Содержимое поля</b></i></td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(0)</b></td>
    <td WIDTH="91">1</td>
    <td WIDTH="295">Специальные функции (это поле всегда
    содержит 0) </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(+1)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="295">Номер головки </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(+3)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="295">Номер дорожки </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(+5)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="295">Номер начального сектора (нумерация
    секторов, в отличие от нумерации головок и
    дорожек начинается с 0) </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(+7)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="295">Общее количество секторов на дорожке,
    уменьшенное на единицу </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>(+9)</b></td>
    <td WIDTH="91">4</td>
    <td WIDTH="295"><b>FAR</b>-указатель на буфер обмена с
    диском, в который помещается считываемая
    информация или откуда берется записываемая
    информация </td>
  </tr>
</table>

<p>CL = 42h/62h (форматировать/проверить дорожку) </p>

<table BORDER="1">
  <tr>
    <td WIDTH="109"><i><b>Смещение</b></i></td>
    <td WIDTH="91"><i><b>Размер</b></i> </td>
    <td WIDTH="294"><i><b>Содержимое поля</b></i></td>
  </tr>
  <tr>
    <td WIDTH="109"><b>(0)</b></td>
    <td WIDTH="91">1</td>
    <td WIDTH="294">Специальные функции. Для этой операции
    определен только бит 0. Перед вызовом команды
    значение бита, равное 0, требуется для
    форматирования дорожки. Если этот бит установлен
    в 1, то проверяется возможность использования
    заданного формата дорожки. Если после выполнения
    команды значение бита 0 равно 0, то поддерживается
    заданный формат дорожки и заполенную таблицу
    разметки дорожки можно использовать. Если
    значение бита 0 равно 1, то затребованный формат
    дорожки не поддерживается. </td>
  </tr>
  <tr>
    <td WIDTH="109"><b>(+1)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="294">Номер головки для
    форматирования/проверки </td>
  </tr>
  <tr>
    <td WIDTH="109"><b>(+3)</b></td>
    <td WIDTH="91">2</td>
    <td WIDTH="294">Номер дорожки для
    форматирования/проверки </td>
  </tr>
</table>

<p>Перед началом выполнения операции программа
должна получить и созранить текущие параметры
устройства. Для получения текущих параметров
устройства необходимо выполнить операцию с
кодом <b>60h</b>. Затем программа должна установить
новые параметры устройства, которые будут
использованы в операциях чтения/записи, проверки
или форматирования. Для установки параметров
программа должна выполнить операцию с кодом <b>40h</b>.
</p>

<p>После выполнения операции программа должна
восстановить первоначальные параметры
устройства, выполнив операцию с кодом <b>40h</b>. </p>

<p>Приведем пример программы, иллюстрирующей
применение функции общего управления
вводом/выводом для блочных устройств. </p>

<p>Эта программа выполняет стандартное
форматирование двадцатой дорожки диска <b>А:</b>. </p>

<p>Для работы с блоками параметров файл <b>sysp.h</b>
содержит определения специальных типов данных,
которые будут использованы в программе
форматирования: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

/* Формат дорожки для GENERIC IOCTL */

typedef struct _TRK_LY_ {
        unsigned no;
        unsigned size;
} TRK_LY;


/* Параметры устройства для GENERIC IOCTL */

typedef struct _DPB_ {

        char spec;
        char devtype;
        unsigned devattr;
        unsigned numofcyl;
        char media_type;

        EBPB bpb;
        char reserved[6];

        unsigned trkcnt;
        TRK_LY trk[100];

} DPB;


/* Параметры для форматирования функцией GENERIC IOCTL */

typedef struct _DPB_FORMAT_ {

        char spec;
        unsigned head;
        unsigned track;

} DPB_FORMAT;

#pragma pack()</font>
</pre>

<p>Программа форматирования читает текущие
параметры для диска <b>А:</b>, формирует структуру
дорожки и устанавливает параметры для
выполнения операции форматирования. Затем
программа проверяет возможность использования
указанной структуры дорожки и выполняет
форматирование. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

         union REGS reg;
         struct SREGS segreg;
         DPB _far *dbp;
         DPB_FORMAT _far *dbp_f;

         int sectors, i;

         printf(&quot;\nПрограмма уничтожит содержимое&quot;
                          &quot;\n20-й дорожки диска А:.&quot;
                          &quot;\nЖелаете продолжить? (Y,N)\n&quot;);

// Ожидаем ответ оператора и анализируем его

         i = getch();
         if((i != 'y') &amp;&amp; (i != 'Y')) exit(-1);

// Заказываем память для блока параметров устройства

         dbp = _fmalloc(sizeof(DPB));

// Заказываем память для блока параметров устройства,
// который будет использован для форматирования

         dbp_f = _fmalloc(sizeof(DPB_FORMAT));

         if(dbp == NULL || dbp_f == NULL) {
                printf(&quot;\nМало оперативной памяти!&quot;);
                exit(-1);
         }

// Получаем текущие параметры диска А:

         dbp-&gt;spec = 0;

// Вызываем подфункцию 0Dh для выполнения
// операции чтения текущих параметров диска А:

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0860;
         reg.x.dx =  FP_OFF(dbp);
         segreg.ds = FP_SEG(dbp);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }

// Заполняем блок параметров для форматирования.
// Байт специальных функций содержит значение,
// равное 5. Это означает, что:
//    - используется текущий блок параметров BIOS BPB;
//    - используются все поля в блоке параметров устройства;
//    - все сектора на дорожке имеют одинаковый размер

         dbp-&gt;spec = 5;

// Считываем из BPB количество секторов на дорожке

         sectors = dbp-&gt;bpb.seccnt;

// Подготавливаем таблицу, описывающую формат дорожки

// Записываем количество секторов на дорожке

         dbp-&gt;trkcnt = sectors;

// Для каждого сектора на дорожке в таблицу
// записываем его номер и размер.
// Заметьте, что записывается размер сектора
// в байтах, а не код размера, как это делается
// при форматировании с помощью функции 05h прерывания INT13h

         for(i = 0; i &lt; sectors; i++) {
                dbp-&gt;trk[i].no   = i+1;
                dbp-&gt;trk[i].size = 512;
         }

// Устанавливаем новые параметры для диска А:

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0840;
         reg.x.dx =  FP_OFF(dbp);
         segreg.ds = FP_SEG(dbp);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }

// Подготавливаем блок параметров устройства,
// который будет использован при вызове
// операции проверки возможности форматирования
// дорожки

// В поле специальных функций записываем 1,
// это означает, что будет выполняться проверка
// возможности использования указанного формата дорожки

         dbp_f-&gt;spec = 1;
         dbp_f-&gt;head = 0;
         dbp_f-&gt;track = 20;

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0842;
         reg.x.dx =  FP_OFF(dbp_f);
         segreg.ds = FP_SEG(dbp_f);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }

// Если указанный формат дорожки поддерживается,
// поле специальных функций будет содержать 0.
// Проверяем это.

         if(dbp_f-&gt;spec != 0) {
                printf(&quot;\nФормат дорожки не поддерживается!&quot;);
                exit(-1);
         }

// Заполняем блок параметров для выполнения
// операции форматирования

         dbp_f-&gt;spec = 0;
         dbp_f-&gt;head = 0;
         dbp_f-&gt;track = 20;

// Форматируем дорожку с номером 20, головка 0

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0842;
         reg.x.dx =  FP_OFF(dbp_f);
         segreg.ds = FP_SEG(dbp_f);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }

// Освобождаем буфера

         _ffree(dbp);
         _ffree(dbp_f);

         exit(0);
}</font>
</pre>

<p>Теперь приведем программу, копирующую
содержимое двух первых секторов нулевой дорожки
(головка 0) в первые два сектора двадцатой
дорожки. </p>

<p>Эта программа использует тип данных,
используемый в операциях чтения/записи: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

/* Параметры для чтения/записи функцией GENERIC IOCTL */

typedef struct _DPB_WR_ {

        char spec;
        unsigned head;
        unsigned track;
        unsigned sector;
        unsigned sectcnt;
        void _far *buffer;

} DPB_WR;

#pragma pack()</font>
</pre>

<p>Программа пользуется текущими параметрами
диска <b>А:</b>, поэтому операции чтения текущих
параметров и записи новых параметров не
используются. </p>

<p>Обратите внимание на то, что эта и предыдущая
программа разрушают содержимое двадцатой
дорожки дискеты, поэтому для экспериментов с
этими программами надо подготовить чистую
отформатированную дискету. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

         union REGS reg;
         struct SREGS segreg;
         DPB_WR _far *dbp_wr;
         char buf[2000];

         int sectors, i;

         printf(&quot;\nПрограмма уничтожит содержимое&quot;
                          &quot;\n20-й дорожки диска А:.&quot;
                          &quot;\nЖелаете продолжить? (Y,N)\n&quot;);

// Ожидаем ответ оператора и анализируем его

         i = getch();
         if((i != 'y') &amp;&amp; (i != 'Y')) exit(-1);


// Заказываем память для блока параметров устройства,
// который будет использован для чтения/записи

         dbp_wr = malloc(sizeof(DPB_WR));

         if(dbp_wr == NULL) {
                printf(&quot;\nМало оперативной памяти!&quot;);
                exit(-1);
         }


// Заполняем блок параметров для выполнения
// операции чтения.
// Мы будем читать первые два сектора
// на нулевой дорожке, головка 0.

         dbp_wr-&gt;spec = 0;
         dbp_wr-&gt;head = 0;
         dbp_wr-&gt;track = 0;
         dbp_wr-&gt;sector = 0;
         dbp_wr-&gt;sectcnt = 2;
         dbp_wr-&gt;buffer = buf;

// Выполняем операцию чтения дорожки

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0861;
         reg.x.dx =  FP_OFF(dbp_wr);
         segreg.ds = FP_SEG(dbp_wr);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }


// Заполняем блок параметров для выполнения
// операции записи.
// Только что прочитанные два сектора нулевой
// дорожки будут записаны на 20-ю дорожку.

         dbp_wr-&gt;spec = 0;
         dbp_wr-&gt;head = 0;
         dbp_wr-&gt;track = 20;
         dbp_wr-&gt;sector = 0;
         dbp_wr-&gt;sectcnt = 2;
         dbp_wr-&gt;buffer = buf;

// Выполняем операцию записи

         reg.x.ax = 0x440d;
         reg.h.bl = 1;
         reg.x.cx = 0x0841;
         reg.x.dx =  FP_OFF(dbp_wr);
         segreg.ds = FP_SEG(dbp_wr);

         intdosx(&amp;reg, &amp;reg, &amp;segreg);

// Проверяем флаг переноса

         if(reg.x.cflag != 0) {
                printf(&quot;\nОшибка: %d&quot;,reg.x.ax);
                exit(-1);
         }


// Освобождаем буфер

         free(dbp_wr);

         exit(0);
}</font>
</pre>
</body>
</html>
