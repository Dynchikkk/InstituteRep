<html>

<head>
<title>3. Файловая система DOS</title>
</head>

<body BGCOLOR="#ffffff">

<h2><font SIZE="5" COLOR="#FF0000">3. Файловая система DOS</font> </h2>

<p>3.1. <a HREF="ch3.htm#ch3_1">Получение справочной
информации</a> </p>

<p>3.2. <a HREF="ch3.htm#ch3_2">Создание, удаление и
переименование каталогов</a> </p>

<p>3.3. <a HREF="ch3.htm#ch3_3">Поиск в каталогах</a> </p>

<p>3.4. <a HREF="ch3.htm#ch3_4">Работа с файлами</a> </p>

<p>3.5. <a HREF="ch3.htm#ch3_5">Чтение/запись файлов</a> </p>

<p>3.6. <a HREF="ch3.htm#ch3_6">Позиционирование</a> </p>

<p>3.7. <a HREF="ch3.htm#ch3_7">Изменение атрибутов, времени и
даты файлов</a> </p>

<p>3.8. <a HREF="ch3.htm#ch3_8">Буферизация ввода/вывода</a> </p>

<p>3.9. <a HREF="ch3.htm#ch3_9">Другие функции для работы с
файлами</a> </p>

<p>3.10. <a HREF="ch3.htm#ch3_10">Таблица открытых файлов</a> </p>

<p>Теперь, после того, как мы познакомились с
логической структурой диска в MS-DOS, можно
приступить к изучению одной из самых развитых
подсистем операционной системы - файловой
системы. </p>

<p>Сервис файловой системы доступен программе
через прерывание MS-DOS <b>INT&nbsp;21h</b>. Многочисленные
функции этого прерывания, относящиеся к файловой
системе, можно разбить на группы: 

<ul>
  <li>получение справочной информации; </li>
  <li>работа с каталогами; </li>
  <li>работа с файлами. </li>
</ul>

<p>Функции первой группы позволяют программе
получить разностороннюю информацию, касающуюся
текущего состояния дисковой подсистемы - текущие
используемые диск и каталог, размер свободного
места на диске, параметры логического диска и т.д.
</p>

<p>Функции второй группы выполняют все
необходимые операции с каталогами - создание,
переименование, уничтожение каталогов,
изменение текущего каталога и т.д. </p>

<p>Третья группа функций позволяет программе
выполнять практически любые операции над
файлами - создание, удаление, чтение/запись,
переименование, копирование, пересылка и т.п. </p>

<p>Заметим, что существует два класса функций для
работы с файлами. Первый класс использует
управляющие блоки файлов <b>FCB</b>. Эти функции
исплоьзовались в MS-DOS версий 1.х и имеют в
настоящее время чисто исторический интерес. Вам
они скорее всего никогда не будут нужны, за
исключением одного случая - если вам надо
составить программу, способную работать под
управлением MS-DOS версии 1.0 или 1.1. В этой книге мы
не будем упоминать функции, предназначенные для
работы с файлами через <b>FCB</b>. При необходимости
вы сможете найти информацию об этих функциях в
руководстве по операционной системе MS-DOS. </p>

<p>Второй класс использует файловые индексы (handle).
Этот класс функций впервые появился в MS-DOS версии
2.0. Эти функции аналогичны используемым в
операционной системе UNIX. </p>

<p>Смысл файлового индекса очень прост. Для того
чтобы начать работу с файлом, программа должна
вызывать определенную функцию DOS,
&quot;открывающую&quot; этот файл. Процесс открытия
файла заключается в присвоении этому файлу
определенного числа (индекса) и выполнении
некоторых других инициализирующих действий. Для
выполнения каких-либо операций с файлом
программа, вызывая соответствующую функцию MS-DOS,
должна указать индекс этого файла. </p>

<p>Первые пять файловых индексов зарезервированы
операционной системой: <br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>0</b></td>
    <td WIDTH="442">Стандартное устройство ввода
    (клавиатура) </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="442">Стандартное устройство вывода (экран) </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="442">Стандартное устройство для вывода
    сообщений об ошибках (экран) </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>3</b></td>
    <td WIDTH="442">Стандартное устройство
    последовательного ввода/вывода, обычно это
    асинхронный адаптер <b>COM1</b>. </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="442">Стандартное печатающее устройство
    (обычно первый принтерный порт <b>LPT1</b>) </td>
  </tr>
</table>

<p>Зарезервированные файловые индексы всегда
доступны программе. Для устройств,
соответствующих этим индексам, не требуется
выполнять операцию открытия. </p>

<p>Одно из преимуществ второго класса файловых
функций - возможность одновременной работы с
файлами, находящимися в разных каталогах. </p>

<p>Состав функций MS-DOS, предназначенных для работы
с файловой системой, достаточно разнообразен и
функционально полон. Только в очень редких
случаях, связанных в основном с организацией
защиты информации от несанкционированного
доступа, вам может потребоваться доступ к диску
на более низком уровне. Если ваша программа
использует для работы с файлами только
документированные функции операционной системы,
ее работа не будет зависеть от аппаратных
средств компьютера, от используемой для создания
разделов диска утилиты. </p>

<p>Описание функций MS-DOS, предназначенных для
работы с файловой системой, мы начнем с функций
получения справочной информации. </p>

<h3><a NAME="ch3_1"><font SIZE="4" COLOR="#008000">3.1. Получение
справочной информации</font></a></h3>

<p>Прежде чем мы начнем обзор функций получения
справочной информации о состоянии и параметрах
дисковой подсистемы, введем понятие текущего
диска и текущего каталога. </p>

<p>Если вы запускаете программу, которая
находится в каком-либо каталоге на одном из
дисков, то эти диск и каталог становятся текущими
для MS-DOS. Это можно понимать в том смысле, что
программе не требуется каждый раз при работе с
файлами указывать требуемый диск или каталог. </p>

<p>В любой момент времени программа может узнать
текущие диск или каталог, а также заменить их. Для
этого она должна использовать специальные
функции прерывания <b>INT&nbsp;21h.</b> </p>

<p>Для установки текущего диска можно
использовать функцию <b>0Eh</b>, которая имеет
следующий формат вызова:<br>
</p>

<table>
  <tr>
    <td WIDTH="107"><b>На входе:</b></td>
    <td WIDTH="378"><b>AH</b> = 0Eh </td>
  </tr>
  <tr>
    <td WIDTH="107"></td>
    <td WIDTH="378"><b>DL</b> = Номер дисковода <b>(0 - А:, 1 - В:, и т.д.)</b>
    </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>На выходе:</b></td>
    <td WIDTH="378"><b>AL</b> = Общее количество дисководов в
    системе. Эта величина соответствует параметру <b>LASTDRIVE</b>
    файла <b>CONFIG.SYS.</b> </td>
  </tr>
</table>

<p>Для того чтобы узнать номер текущего дисковода,
программа может воспользоваться функцией <b>19h</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="109"><b>На входе:</b></td>
    <td WIDTH="372"><b>AH</b> = 19h </td>
  </tr>
  <tr>
    <td WIDTH="109"><b>На выходе:</b></td>
    <td WIDTH="372"><b>AL</b> = Номер текущего дисковода <b>(0 - А:, 1
    - В:, и т.д.).</b> </td>
  </tr>
</table>

<p>Функция 3Bh предназначена для установки
текущего каталога:<br>
</p>

<table>
  <tr>
    <td WIDTH="107"><b>На входе:</b></td>
    <td WIDTH="377"><b>AH</b> = 3Bh </td>
  </tr>
  <tr>
    <td WIDTH="107"></td>
    <td WIDTH="377"><b>DL</b> = Номер дисковода <b>(0 - текущий, 1 - А:,
    2 - В:, и т.д.)</b> </td>
  </tr>
  <tr>
    <td WIDTH="107"></td>
    <td WIDTH="377"><b>DS:DX </b>= Адрес буфера, содержащего путь
    каталога, который должен стать текущим. </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>На выходе:</b></td>
    <td WIDTH="377"><b>AX</b> = Код ошибки, если <b>CY</b> установлен
    в <b>1</b>. </td>
  </tr>
</table>

<p>Буфер пути может иметь максимальный размер 64
байта. Он должен содержать путь в формате ASCIIZ, т.е.
строку, закрытую двоичным нулем, например: <b>&quot;path\dirname&quot;,0</b>.
Строка не должна содержать литеры, обозначающие
диск. Если текущим должен стать корневой каталог,
строка должна состоять только из одного
двоичного нуля. </p>

<p>Для того чтобы узнать текущий каталог, вы
можете воспользоваться функцией <b>47h</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="106"><b>На входе:</b></td>
    <td WIDTH="420"><b>AH</b> = 47h </td>
  </tr>
  <tr>
    <td WIDTH="106"></td>
    <td WIDTH="420"><b>DL</b> = Номер дисковода (<b>0</b> - текущий, <b>1
    - А:, 2 - В:</b>, и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="106"></td>
    <td WIDTH="420"><b>DS:SI</b> = Адрес буфера для записи пути
    текущего каталога. </td>
  </tr>
  <tr>
    <td WIDTH="106"><b>На выходе:</b></td>
    <td WIDTH="420"><b>AX</b> = Код ошибки, если флаг переноса <b>CF</b>
    установлен в <b>1</b>. </td>
  </tr>
</table>

<p>Буфер должен иметь размер не менее 64 байтов,
текущий каталог возвращается в формате ASCIIZ без
литеры, обозначающей диск. Если текущим является
корневой каталог, регистровая пара <b>DS:SI </b>будет
указывать на нулевую строку (состоящую из одного
двоичного нуля). </p>

<p>Функции MS-DOS могут помочь вам в получении
информации, необходимой для организации доступа
к диску на уровне секторов и кластеров. При этом
вы будете избавлены от необходимости читать в
память и анализированть содержимое загрузочного
сектора логического диска. </p>

<p>Информация о таблице размещения файлов <b>FAT</b>
для текущего диска может быть получена с помощью
функции <b>1Bh</b> прерывания<b> INT&nbsp;21h</b>, имеющего
следующий формат:<br>
</p>

<table>
  <tr>
    <td WIDTH="113"><b>На входе:</b></td>
    <td WIDTH="369"><b>AH</b> = 1Bh </td>
  </tr>
  <tr>
    <td WIDTH="113"><b>На выходе:</b></td>
    <td WIDTH="369"><b>DS:BX</b> = Адрес первого байта <b>FAT</b>. Это
    байт <b>ID</b> идентификации среды носителя данных,
    соответствует байту <b>media</b> в блоке параметров
    BIOS. </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="369"><b>DX</b> = Общее количество кластеров на
    диске. </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="369"><b>AL</b> = Количество секторов в одном
    кластере. </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="369"><b>CX</b> = Количество байтов в одном
    секторе. </td>
  </tr>
</table>

<p>Дополнительно эта функция возвращает
информацию об общем количестве кластеров на
диске, размере кластера в секторах и размере
сектора в байтах. Для версий MS-DOS, более ранних,
чем 2.0, регистровая пара <b>DS:BX</b> указывала на <b>FAT</b>,
считанный в память. Более поздние версии
операционной системы могут содержать по этому
адресу только часть таблицы размещения файлов. </p>

<p>Для получения аналогичной информации не о
текущем, а о любом диске, используйте функцию <b>1Ch</b>.
Эта функция полностью аналогична предыдущей, за
исключением того, что в регистре <b>DL</b> должен
быть указан код дисковода: <b>0</b> - текущий, <b>1 - А:, 2
- В: </b>и т.д. Эта функция доступна в MS-DOS версии 2.0 и
в более поздних версиях. </p>

<p>Если вас интересует размер свободного места на
диске, вы можете его узнать с помощью функции <b>36h</b>,
имеющей следующий формат: <br>
</p>

<table>
  <tr>
    <td WIDTH="102"><b>На входе:</b></td>
    <td WIDTH="397"><b>AH</b> = 36h </td>
  </tr>
  <tr>
    <td WIDTH="102"></td>
    <td WIDTH="397"><b>DL</b> = Номер дисковода (<b>0</b> - текущий, <b>1
    - А:, 2 - В:</b>, и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="102"><b>На выходе:</b></td>
    <td WIDTH="397"><b>AX</b> = Количество секторов в кластере; <b>0FFFFh</b>,
    если был задан неправильный номер дисковода; </td>
  </tr>
  <tr>
    <td WIDTH="102"></td>
    <td WIDTH="397"><b>BX</b> = Количество свободных кластеров
    на диске. </td>
  </tr>
  <tr>
    <td WIDTH="102"></td>
    <td WIDTH="397"><b>CX</b> = Количество байтов в одном
    секторе. </td>
  </tr>
  <tr>
    <td WIDTH="102"></td>
    <td WIDTH="397"><b>DX</b> = Общее количество кластеров на
    диске. </td>
  </tr>
</table>

<p>Эта функция возвращает в регистре <b>AX</b> число <b>0FFFFh</b>,
если вы неправильно указали номер дисковода. </p>

<p>При обсуждении векторной таблицы связи мы
рассказывали о блоках управления устройствами <b>DDCB</b>.
Поле <b>dev_cb</b> векторной таблицы связи содержит <b>FAR</b>-адрес
цепочки этих блоков. </p>

<p>Приведем еще раз формат блока <b>DDCB</b>. Напомним,
что он изменяется в зависимости от версии DOS. Для
версий 2.х и 3.х блок <b>DDCB</b> имеет следующий формат:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="74"><b>(0)</b></td>
    <td WIDTH="48"><b>1 </b></td>
    <td WIDTH="87"><b>drv_num</b> </td>
    <td WIDTH="310">номер устройства (<b>0</b> соответствует
    устройству <b>А:</b>, <b>1 - В:</b> и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+1)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>drv_numd</b> </td>
    <td WIDTH="310">дополнительный номер устройства внутри
    драйвера </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+2)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>sec_size</b> </td>
    <td WIDTH="310">размер сектора в байтах</td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+4)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>clu_size</b> </td>
    <td WIDTH="310">число, на единицу меньшее количества
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+5)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>clu_base</b> </td>
    <td WIDTH="310">если содержимое этого поля не равно
    нулю, то для получения общего числа секторов в
    кластере надо возвести 2 в степень <b>clu_base </b>и
    получившееся число прибавить к <b>clu_size</b> </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+6)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>boot_siz</b> </td>
    <td WIDTH="310">количество зарезервированных секторов
    (boot-сектора, начало корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+8)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>fat_num</b> </td>
    <td WIDTH="310">количество копий <b>FAT</b></td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+9)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>max_dir</b> </td>
    <td WIDTH="310">максимальное число дескрипторов файлов
    в корневом каталоге (т.е. максимальное число
    файлов, которое может содержать корневой каталог
    на этом устройстве) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+11) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>data_sec</b></td>
    <td WIDTH="310">номер первого сектора данных на диске
    (номер сектора, соответствующего кластеру номер
    2) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+13) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>hi_clust</b></td>
    <td WIDTH="310">максимальное количество кластеров
    (равно увеличенному на 1 количеству кластеров
    данных) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+15) </b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>fat_size</b></td>
    <td WIDTH="310">количество секторов, занимаемых одной
    копией <b>FAT</b> </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+16) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>root_sec</b></td>
    <td WIDTH="310">номер первого сектора корневого
    каталога </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+18) </b></td>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="87"><b>drv_addr</b></td>
    <td WIDTH="310"><b>FAR</b>-адрес заголовка драйвера,
    обслуживающего данное устройство </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+22) </b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>media</b></td>
    <td WIDTH="310">байт описания среды носителя данных </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+23) </b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="87"><b>acc_flag</b></td>
    <td WIDTH="310">флаг доступа, <b>0</b> означает, что к
    устройству был доступ </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+24) </b></td>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="87"><b>next</b></td>
    <td WIDTH="310">адрес следующего блока <b>DDCB</b>, для
    последнего блока в поле смещения находится число
    <b>FFFF</b> </td>
  </tr>
  <tr>
    <td WIDTH="74">&nbsp;</td>
    <td WIDTH="48">&nbsp;</td>
    <td WIDTH="87">&nbsp;</td>
    <td WIDTH="310"><i><b>--------------- только для DOS 2.x --------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+28) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>dir_clu</b></td>
    <td WIDTH="310">номер начального кластера текущего
    каталога (0 для корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+30) </b></td>
    <td WIDTH="48"><b>64</b></td>
    <td WIDTH="87"><b>dir_path</b></td>
    <td WIDTH="310">строка в формате ASCIIZ, содержащая путь к
    текущему каталогу </td>
  </tr>
  <tr>
    <td WIDTH="74">&nbsp;</td>
    <td WIDTH="48">&nbsp;</td>
    <td WIDTH="87">&nbsp;</td>
    <td WIDTH="310"><i><b>--------------- DOS 3.х ----------------------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+28) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>reserv1</b></td>
    <td WIDTH="310">зарезервировано, обычно равно 0 </td>
  </tr>
  <tr>
    <td WIDTH="74"><b>(+30) </b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="87"><b>built</b></td>
    <td WIDTH="310">число <b>FFFF</b> в этом поле означает, что
    блок <b>DDCB</b> был построен </td>
  </tr>
</table>

<p>Формат блока DDCB для DOS версии 4.х:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="56"><b>(0)</b></td>
    <td WIDTH="48"><b>1 </b></td>
    <td WIDTH="89"><b>drv_num</b> </td>
    <td WIDTH="307">номер устройства (<b>0</b> соответствует
    устройству <b>А:, 1 - В: </b>и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+1)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>drv_numd</b> </td>
    <td WIDTH="307">дополнительный номер устройства внутри
    драйвера </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+2)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>sec_size</b> </td>
    <td WIDTH="307">размер сектора в байтах</td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+4)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>clu_size</b> </td>
    <td WIDTH="307">число, на единицу меньшее количества
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+5)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>clu_base</b> </td>
    <td WIDTH="307">если содержимое этого поля не равно
    нулю, то для получения общего числа секторов в
    кластере надо возвести 2 в степень <b>clu_base</b> и
    получившееся число прибавить к <b>clu_size</b> </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+6)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>boot_siz</b> </td>
    <td WIDTH="307">количество зарезервированных секторов
    (boot-сектора, начало корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+8)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>fat_num</b> </td>
    <td WIDTH="307">количество копий <b>FAT</b></td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+9)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>max_dir</b> </td>
    <td WIDTH="307">максимальное число дескрипторов файлов
    в корневом каталоге (т.е. максимальное число
    файлов, которое может содержать корневой каталог
    на этом устройстве) </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+11)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>data_sec</b> </td>
    <td WIDTH="307">номер первого сектора данных на диске
    (номер сектора, соответствующего кластеру номер
    2) </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+13)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>hi_clust</b> </td>
    <td WIDTH="307">максимальное количество кластеров
    (равно увеличенному на 1 количеству кластеров
    данных) </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+15)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>fat_size</b> </td>
    <td WIDTH="307">количество секторов, занимаемых одной
    копией <b>FAT</b> </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+16)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>reserv1</b> </td>
    <td WIDTH="307">зарезервироано</td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+17)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>root_sec</b> </td>
    <td WIDTH="307">номер первого сектора корневого
    каталога</td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+19)</b></td>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="89"><b>drv_addr</b> </td>
    <td WIDTH="307"><b>FAR</b>-адрес заголовка драйвера,
    обслуживающего данное устройство </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+23)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>media</b> </td>
    <td WIDTH="307">байт описания среды носителя данных</td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+24)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="89"><b>acc_flag</b> </td>
    <td WIDTH="307">флаг доступа, <b>0</b> означает, что к
    устройству был доступ </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+25)</b></td>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="89"><b>next</b> </td>
    <td WIDTH="307">адрес следующего блока <b>DDCB</b>, для
    последнего блока в поле смещения находится число
    <b>FFFF</b> </td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+29)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>reserv2</b> </td>
    <td WIDTH="307">зарезервироано</td>
  </tr>
  <tr>
    <td WIDTH="56"><b>(+31)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="89"><b>built</b> </td>
    <td WIDTH="307">число <b>FFFF</b> в этом поле означает, что
    блок <b>DDCB</b> был построен </td>
  </tr>
</table>

<p>Файл <b>sysp.h</b> содержит определение типа <b>DDCB</b>
для MS-DOS версии 4.х: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/* Блок управления устройством DOS */

#pragma pack(1)

typedef struct _DDCB_ {
        unsigned char drv_num;
        unsigned char drv_numd;
        unsigned sec_size;
        unsigned char clu_size;
        unsigned char clu_base;
        unsigned boot_siz;
        unsigned char fat_num;
        unsigned max_dir;
        unsigned data_sec;
        unsigned hi_clust;
        unsigned char fat_size;
        char reserv1;
        unsigned root_sec;
        void far *drv_addr;
        unsigned char media;
        unsigned char acc_flag;
        struct _DDCB_ far *next;
        unsigned reserv2;
        unsigned built;
} DDCB;

#pragma pack()</font>
</pre>

<p>При описании векторной таблицы связи мы
приводили примеры использования блоков <b>DDCB</b>.
Для получения адреса блока <b>DDCB</b> конкретного
дисковода можно воспользоваться
недокументированной функцией <b>32h</b>. Она имеет
следующий формат вызова:<br>
</p>

<table>
  <tr>
    <td WIDTH="99"><b>На входе:</b></td>
    <td WIDTH="393"><b>AH</b> = 32h </td>
  </tr>
  <tr>
    <td WIDTH="99"></td>
    <td WIDTH="393"><b>DL</b> = Номер дисковода (<b>0</b> - текущий, <b>1
    - А:, 2 - В:</b>, и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="99"><b>На выходе:</b></td>
    <td WIDTH="393"><b>AL</b> = 0, если был задан правильный номер
    дисковода;<br>
    <b>0FFh</b>, если был задан неправильный номер
    дисковода; </td>
  </tr>
  <tr>
    <td WIDTH="99"></td>
    <td WIDTH="393"><b>DS:BX</b> = Адрес блока DDCB </td>
  </tr>
</table>

<p>Для получения адреса блока <b>DDCB</b> текущего
диска можно воспользоваться
недокументированной функцией <b>1Fh</b>, которая
имеет формат, аналогичный функции <b>32h</b>, за
исключением того, что не надо задавать номер
дисковода в регистре <b>DL</b>. </p>

<p>Какая еще полезная информация может быть
получена при использовании функций MS-DOS? </p>

<p>С помощью функции <b>33h</b> программа может
проверить или установить флаг Ctrl-Break и узнать
номер диска, с которого выполнялась загрузка
операционной системы:<br>
</p>

<table>
  <tr>
    <td WIDTH="113"><b>На входе:</b></td>
    <td WIDTH="376"><b>AH</b> = 33h </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="376"><b>AL</b> = Код подфункции: <br>
    <b>0</b> - Проверить текущее состояние флага Ctrl-Break; <br>
    <b>1</b> - Установить флаг Ctrl-Break; <br>
    <b>5</b> - Определить номер диска, который был
    использован для загрузки операционной системы. </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="376"><b>DL</b> = Значение устанавливаемого флага
    Ctrl-Break для подфункции <b>1</b> (0 - OFF, 1 - ON). </td>
  </tr>
  <tr>
    <td WIDTH="113"><b>На выходе:</b></td>
    <td WIDTH="376"><b>DL</b> = Текущее состояние флага Ctrl-Break для
    подфункции 0; <br>
    Номер диска, использованного для загрузки
    операционной системы для подфункции <b>5</b> (<b>1 - А:,
    2 - В:</b>, и т.д.). </td>
  </tr>
</table>

<p>Сведения о диске, который был использован для
загрузки операционной системы, могут
понадобиться вам для поиска файла, содержащего
командный интерпретатор или программу <b>DOSSHELL</b>. </p>

<p>Состояние флага Ctrl-Break влияет на возможность
прервать выполнение программы нажатием
комбинации клавиш Ctrl-Break или Ctrl-C. Если флаг
находится в состоянии OFF, DOS проверяет эту
комбинацию клавиш только при вызове функций
стандартного ввода/вывода на консоль, принтер и
последовательный порт. Если флаг установлен в
состояние ON, комбинация клавиш проверяется и при
вызове других функций MS-DOS. Если операционная
система зафиксировала нажатие указанной
комбинации клавиш, она выполняет прерывание <b>INT&nbsp;23h</b>,
которое завершает работу текущей программы. </p>

<p>Функция <b>2Fh</b> возвращает в регистровой паре <b>ES:BX</b>
адрес текущей области <b>DTA</b> (Disk Transfer Area), которая
используется при поиске файлов в каталогах. </p>

<p>Функция <b>54h</b> позволяет программе узнать
текущее состояние флага проверки записывающейся
на диск информации. В регистре <b>AL</b> эта функция
возвращает текущее состояние флага. Если
содержимое регистра равно 1, операционная
система после записи сектора считывает его для
проверки. Разумеется, такая проверка снижает
скорость работы программы. Если после вызова
функции регистр <b>AL</b> содержит 0, проверка записи
не выполняется. </p>

<p>Для установки флага проверки записи можно
использовать функцию <b>2Eh</b>. Перед вызовом
функции в регистр <b>AL</b> необходимо занести новое
значение флага проверки: <b>0</b> - проверка не нужна;
<b>1</b> - должна выполняться проверка записанной
информации. </p>

<p><i><b>Стандартные библиотеки</b></i> трансляторов
Microsoft QC 2.5 и C 6.0 содержат несколько функций,
облегчающих получение справочной информации о
состоянии дисковой подсистемы. </p>

<p>Функция <b>_dos_getdiskfree()</b> использует функцию <b>36h</b>
для получения информации о диске. Файл <b>dos.h</b>
содержит описание этой функции: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _dos_getdiskfree(unsigned drive, 
struct diskfree_t *diskspace);</font>
</pre>

<p>Параметр <b>drive</b> задает номер используемого
дисковода: <b>0 </b>- текущий, <b>1 - А:</b>, и т.д. </p>

<p>Информация возвращается в структуре <b>diskfree_t</b>,
которая определена в файле <b>dos.h:</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">struct diskfree_t
{
        unsigned total_clusters;
        unsigned avail_clusters;
        unsigned sectors_per_cluster;
        unsigned bytes_per_sector;
};</font>
</pre>

<p>В этой структуре:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="238"><b>unsigned total_clusters</b></td>
    <td WIDTH="313">общее количество кластеров на диске; </td>
  </tr>
  <tr>
    <td WIDTH="238"><b>unsigned avail_clusters</b></td>
    <td WIDTH="313">количество свободных кластеров; </td>
  </tr>
  <tr>
    <td WIDTH="238"><b>unsigned sectors_per_cluster</b></td>
    <td WIDTH="313">количество секторов, занимаемых
    кластером; </td>
  </tr>
  <tr>
    <td WIDTH="238"><b>unsigned bytes_per_sector</b></td>
    <td WIDTH="313">размер сектора в байтах. </td>
  </tr>
</table>

<p>Для получения номера текущего диска и для
установки номера текущего диска можно
использовать, соответственно, функции <b>_dos_getdrive()</b>
и <b>_dos_setdrive().</b> </p>

<p>Функция <b>_dos_getdrive()</b> имеет формат: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void _dos_getdrive(unsigned *drive);</font>
</pre>

<p>Эта функция пользуется функцией <b>19h</b> для
получения номера текущего диска, который
записывается по адресу, задаваемому параметром.
Значение <b>1</b> соответствует диску<b> А:, 2 - В:,</b> и
т.д. </p>

<p>Функция <b>_dos_setdrive()</b> предназначена для
установки текущего диска и может быть
использована для определения общего числа
дисков в системе: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void _dos_setdrive(unsigned drive, unsigned *drivecount);</font>
</pre>

<p>Параметр <b>drive</b> опеределяет текущий диск (<b>1 -
А:</b>, и_т.д.), по адресу, задаваемому вторым
параметром, функция записывает общее количество
логических дисков, установленных в системе.
Функция <b>_dos_setdrive()</b> использует функцию <b>0Eh</b>
прерывания<b> INT&nbsp;21h.</b> </p>

<p>Для иллюстрации способов использования
функций <b>_dos_getdrive(),</b> <b>_dos_setdrive(), _dos_getdiskfree()</b> мы
составили следующую программу: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;bios.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

void main(void);
void main(void) {

         struct diskfree_t dinfo;
         unsigned drive, drivecount;

         printf(&quot;\n&quot;
                &quot;\nОпределение параметров текущего логического диска&quot;
                &quot;\n  (C)Фролов А., 1991&quot;
                &quot;\n&quot;);

// Определяем номер текущего диска

         _dos_getdrive(&amp;drive);

// Выводим на экран литеру текущего диска

         printf(&quot;\nТекущий диск:                        %c:\n&quot;,
                'A' + drive - 1);

// Вызываем функцию установки текущего диска.
// Мы не изменяем текущий диск, вызов этой функции
// нужен нам для определения количества установленных
// в системе логических дисков

         _dos_setdrive(drive, &amp;drivecount);

// Получаем характеристики текущего диска

         _dos_getdiskfree(drive, &amp;dinfo);

         printf(&quot;\nОбщее количество кластеров на диске: %d&quot;
                  &quot;\nКоличество свободных кластеров:      %d&quot;
                  &quot;\nКоличество секторов в кластере:      %d&quot;
                  &quot;\nКоличество байтов в секторе:         %d&quot;
                  &quot;\nРазмер диска в байтах:               %ld&quot;
                  &quot;\n&quot;,
                  dinfo.total_clusters,
                  dinfo.avail_clusters,
                  dinfo.sectors_per_cluster,
                  dinfo.bytes_per_sector,
                  (long)dinfo.avail_clusters *
                  dinfo.sectors_per_cluster *
                  dinfo.bytes_per_sector );

         printf(&quot;\nКоличество логических дисков:        %d&quot;
                          &quot;\n&quot;, drivecount);

}</font>
</pre>

<h3><a NAME="ch3_2"><font SIZE="4" COLOR="#008000">3.2. Создание, удаление
и переименование каталогов</font></a></h3>

<p>После форматирования логический диск содержит
корневой каталог. Если диск форматируется как
системный, в этом каталоге могут находится
дескрипторы файлов операционной системы<b> IO.SYS,
MSDOS.SYS, COMMAND.COM.</b> </p>

<p>Операционная система предоставляет программам
пользователя удобный сервис для создания,
уничтожения и переименования каталогов.
Используя сведения, приведенные в этой книге, вы
сможете изменять структуру каталогов сами, не
прибегая к услугам MS-DOS. Однако это следует делать
только тогда, когда операции с каталогами по
каким-то причинам нежелательно выполнять с
использованием функций операционной системы. </p>

<p>Для создания каталога используйте функцию <b>39h</b>
прерывания <b>INT&nbsp;21h:<br>
</b></p>

<table>
  <tr>
    <td WIDTH="116"><b>На входе:</b></td>
    <td WIDTH="375"><b>AH</b> = 39h </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="375"><b>DS:DX</b> = Адрес строки в формате ASCIIZ,
    содержащей имя создаваемого каталога. </td>
  </tr>
  <tr>
    <td WIDTH="116"><b>На выходе:</b></td>
    <td WIDTH="375"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>Строка, имени создаваемого каталога может
содержать полный путь, состоящий из имени диска и
имени каталога, в котором должен быть создан
каталог, или она может состоять только из одного
имени каталога. В последнем случае каталог
создается в текущем каталоге на текущем диске. </p>

<p>Размер строки с именем каталога не должен
превышать по длине 64 байта. </p>

<p>Удалить существующий каталог можно с помощью
функции <b>3Ah</b>. Формат вызова этой функции
аналогичен предыдущему:<br>
</p>

<table>
  <tr>
    <td WIDTH="115"><b>На входе:</b></td>
    <td WIDTH="374"><b>AH</b> = 3Ah </td>
  </tr>
  <tr>
    <td WIDTH="115"></td>
    <td WIDTH="374"><b>DS:DX</b> =Адрес строки в формате ASCIIZ,
    содержащей имя удаляемого каталога. </td>
  </tr>
  <tr>
    <td WIDTH="115"><b>На выходе:</b></td>
    <td WIDTH="374"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>Необходимо заметить, что удалить можно только
пустой каталог. И это понятно, так как если вы в
обход операционной системы удалите непустой
каталог, то описанные в этом каталоге файлы и
каталоги будут потеряны для вас, а занимаемое ими
место невозможно будет распределить другим
файлам. </p>

<p>Для изменения имени каталогов и файлов
предназначена функция <b>56h</b>: <br>
</p>

<table>
  <tr>
    <td WIDTH="123"><b>На входе:</b></td>
    <td WIDTH="367"><b>AH</b> = 56h </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="367"><b>DS:DX</b> = Адрес строки в формате ASCIIZ,
    содержащей старое имя каталога или файла. </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="367"><b>ES:DI </b>= Адрес строки в формате ASCIIZ,
    содержащей новое имя каталога или файла. </td>
  </tr>
  <tr>
    <td WIDTH="123"><b>На выходе:</b></td>
    <td WIDTH="367"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>Переименуемый файл или каталог должен
существовать. Если в имени не указан диск или
каталог, то подразумевается, что файл или каталог
находится в текущем каталоге на текущем диске.
Напротив, каталога или файла с новым именем не
должно быть, иначе функция возвратит признак
ошибки. </p>

<p>Эта функция может перемещать файл из одного
каталога в другой, если вы укажите разные пути.
Каталоги перемещать нельзя, их можно только
переименовывать. </p>

<p>Мы уже рассказывали о функции <b>3Bh</b>, с помощью
которой можно изменить текущий каталог, если это
необходимо.<br>
</p>

<p><b>Стандартные библиотеки</b> трансляторов Microsoft
QC 2.5 и C 6.0 содержат несколько функций,
предназначенных для работы с каталогами. </p>

<p>Функция <b>getcwd()</b> предназначена для определения
текущего каталога. Прототип этой функции описан
в файле <b>direct.h:</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">char *getcwd(char *path, int n);
</font>
</pre>

<p>Первый параметр этой функции - адрес буфера, в
который необходимо занести строку, содержащую
имя текущего каталога. Размер этого буфера
определяется вторым параметром. </p>

<p>Если в качестве первого параметра указать <b>NULL</b>,
функция динамически закажет буфер длиной n
байтов из области кучи. Эту память впоследствии
необходимо будет освободить при помощи функции <b>free()</b>.
Функция<b> getcwd()</b> возвращает указатель на буфер,
содержащий текущий каталог. </p>

<p>Приведем пример простой программы, которая
выводит на экран информацию о текущем каталоге: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;direct.h&gt;

void main(void);
void main(void) {

        printf(&quot;\nТекущий каталог: %s\n&quot;,
                getcwd(NULL,70));

}</font>
</pre>

<p>Для создания и удаления каталогов, изменения
текущего каталога имеются функции <b>mkdir(), rmdir(),
chdir().</b> </p>

<p>Все эти функции имеют один параметр - путь
каталога, который имеет тип <b>(char_*).</b> В случае
успешного выполнения операции функции
возвращают <b>0</b>, при ошибке - <b>1</b>. </p>

<p>Приведем небольшой пример, использующий
перечисленные выше функциии: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;direct.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void main(void);
void main(void) {

         char current_dir[_MAX_DIR];   // _MAX_DIR - максимальная длина
                                                         // пути для каталога.
                                                         // Эта константа описана в
                                                         // файле stdlib.h
         char test_dir[] = &quot;TEST_DIR&quot;;

// Запоминаем текущий каталог

         getcwd( current_dir, _MAX_DIR );

// Пытаемся создать в текущем каталоге новый каталог

         if(!mkdir(test_dir)) {

// Если удалось создать каталог, делаем его текущим

                 chdir(test_dir);
                 printf(&quot;\nКталог создан, для удаления нажмите&quot;
                          &quot;\nлюбую клавишу, для сохранения - Ctrl-C&quot;);

                 getch();

// Для удаления только что созданного каталога
// возвращаемся в каталог более высокого уровня

                 chdir(current_dir);
                 rmdir(test_dir);
         }

// Если каталог с таким именем уже существует или
// произошла другая ошибка при создании каталога,
// выводим сообщение о невозможности создания каталога.

         else printf(&quot;\nНе могу создать каталог!&quot;);
}
</font>
</pre>

<p>Для переименования каталогов (и файлов)
предназначена функция <b>rename():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int rename(char *oldname, char *newname);</font>
</pre>

<p>Способ ее использования очевиден: необходимо
задать старое и новое имена каталогов. Можно
задавать как полный путь, так и просто имя
каталога/файла. В последнем случае операция
переименования выполняется над каталогами или
файлами, находящимися в текущем каталоге. </p>

<p>Функция может возвращать один из кодов ошибки:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="114"><b>ENOENT</b></td>
    <td WIDTH="371">Нет такого файла или каталога </td>
  </tr>
  <tr>
    <td WIDTH="114"><b>EACCES</b></td>
    <td WIDTH="371">Нет прав доступа </td>
  </tr>
  <tr>
    <td WIDTH="114"><b>EXDEV</b></td>
    <td WIDTH="371">Другой диск</td>
  </tr>
</table>

<p>Код ошибки <b>EXDEV</b> возвращается в том случае,
когда программа указывает разные диски для
старого и нового имен файлов или каталогов. </p>

<p>Важное замечание: если вы задаете полный путь, в
строке пути повторяйте символ <b>'\' </b>два раза. Это
нужно для того, чтобы избежать конфликта с
форматом представления констант в языке С.
Например: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">ret_code = rename(&quot;c:\\games&quot;,&quot;c:\\games_new&quot;);</font>
</pre>

<h3><a NAME="ch3_3"><font SIZE="4" COLOR="#008000">3.3. Поиск в каталогах</font></a>
</h3>

<p>Часто перед программистом стоит задача
определения текущего содержимого каталога. При
описании логической структуры диска мы
приводили текст программы, выводящей на экран
содержимого корневого каталога и других
каталогов. Эта программа использовала
загрузочный сектор логического диска и таблицу
размещения файлов. Вы можете использовать такой
способ, однако, если вам не требуется информация
о номерах начальных кластеров файлов и
дескрипторы удаленных файлов, лучше применить
специальные функции MS-DOS, предназначенные для
поиска файлов в каталогах. </p>

<p>Пара функций <b>4Eh</b> и <b>4Fh</b> предназначены для
сканирования каталогов. </p>

<p>Эти функции используются вместе следующим
образом: 

<ul>
  <li>Вызывается функция <b>4Eh</b> для поиска в каталоге
    файла, соответствующего образцу. В образце можно
    использовать символы <b>?</b> и <b>*,</b> которые
    означают, соответственно, один любой символ и
    любое количество любых символов. Информация о
    найденном файле располагается в специальной
    области, назначенной каждой работающей
    программе - области <b>DTA</b>. </li>
  <li>Вызывается в цикле функция <b>4Fh</b> для поиска
    остальных файлов, удовлетворяющих образцу,
    заданному при вызове функции <b>4Eh</b>. Условие
    завершения цикла - отсутствие в каталоге
    указанных файлов. <br>
  </li>
</ul>

<p>Приведем формат вызова функций <b>4Eh</b> и <b>4Fh</b>. </p>

<p>Функция <b>4Eh</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="123"><b>На входе:</b></td>
    <td WIDTH="365"><b>AH</b> = 4Eh </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="365"><b>CX</b> = Атрибуты файла, которые будут
    использованы при поиске. Будут найдены файлы,
    имеющие заданный в этом регистре атрибут. </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="365"><b>DS:DX</b> = Адрес строки в формате ASCIIZ,
    содержащей путь каталогаили файла. </td>
  </tr>
  <tr>
    <td WIDTH="123"><b>На выходе:</b></td>
    <td WIDTH="365"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>Функция <b>4Fh</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="124"><b>На входе:</b></td>
    <td WIDTH="365"><b>AH</b> = 4Fh </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>На выходе:</b></td>
    <td WIDTH="365"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>Обе функции устанавливают флаг переноса в том
случае, когда каталог не содержит файлов,
удовлетворяющих заданному критерию поиска. </p>

<p>Для работы с областью <b>DTA</b> MS-DOS имеет две
функции. Это функция <b>2Fh</b>, позволяющая получить
адрес области <b>DTA</b> (она возвращает этот адрес в
регистрах <b>ES:BX</b>), и функция <b>1Ah</b>,
предназначенная для установки своей области <b>DTA</b>
(адрес новой области <b>DTA</b> должен быть указан в
регистрах <b>DS:DX</b>). </p>

<p>Напомним, что по умолчанию область <b>DTA</b>
занимает 128 байтов в префиксе сегмента программы <b>PSP</b>
со смещением <b>80h</b>. </p>

<p>В случае успешного поиска функции <b>4Eh</b> и <b>4Fh</b>
помещают в <b>DTA</b> информацию о найденных файлах в
следующем формате: <br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="59"><b>(0)</b></td>
    <td WIDTH="48"><b>20</b></td>
    <td WIDTH="343">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="59"><b>(+21)</b></td>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="343">Атрибуты найденного файла </td>
  </tr>
  <tr>
    <td WIDTH="59"><b>(+22)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="343">Поле времени последнего обновления
    фалйла </td>
  </tr>
  <tr>
    <td WIDTH="59"><b>(+24)</b></td>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="343">Поле даты последнего обновления фалйла </td>
  </tr>
  <tr>
    <td WIDTH="59"><b>(+26)</b></td>
    <td WIDTH="48"><b>4</b></td>
    <td WIDTH="343">Длина файла </td>
  </tr>
  <tr>
    <td WIDTH="59"><b>(+30)</b></td>
    <td WIDTH="48"><b>13</b></td>
    <td WIDTH="343">Имя файла и расширение в формате ASCIIZ</td>
  </tr>
</table>

<p>Номер начального класетра, распределенного
файлу или каталогу, невозможно получить с
помощью функций <b>4Eh</b> и <b>4Fh</b>. </p>

<p>Стандартные библиотеки трансляторов Microsoft QC 2.5
и C 6.0 содержат две функции, предназначенные для
сканирования каталогов - <b>_dos_findfirst()</b> и <b>_dos_findnext()</b>.
</p>

<p>Приведем прототипы этих функций, описанные в
файле <b>dos.h</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int _dos_findfirst(char *pattern, struct find_t *found,
                                unsigned attr);
int _dos_findnext(struct find_t *found);</font>
</pre>

<p>В этих функциях параметр <b>pattern</b> определяет
образец для поиска файлов, параметр <b>attr</b> -
атрибуты файла - используется в качестве
дополнительного критерия поиска. Параметр <b>found</b>
представляет собой указатель на структуру, в
которую будет записываться информация о
найденных файлах. Эта структура определена в
файле <b>dos.h</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">struct find_t {
        char reserved[21];      // Зарезервировано для DOS
        char attrib;            // Атрибуты файла
        unsigned wr_time;       // Время изменения файла
        unsigned wr_date;       // Дата изменения файла
        long size;              // Размер файла в байтах
        char name[13];          // Имя файла и расширение
};</font>
</pre>

<p>Приведем текст программы просмотра
содержимого каталога. Программа принимает из
командной строки параметр - образец для показа
файлов. Если вы укажете параметр <b>*.*</b>, будет
выведена информация обо всех файлах. Можно
задавать полный путь: <b>c:\*.*</b>. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void main(int argc, char *argv[]) ;
void print_info(struct find_t *find);
char *time_conv(unsigned time, char *char_buf);
char *date_conv(unsigned date, char *char_buf);

void main(int argc, char *argv[]) {

         struct find_t find;

// Находим первый файл, удовлетворяющий критериям поиска.
// В качестве критерия используем образец, полученный
// из командной строки. Для поиска используем файлы с любыми
// атрибутами.

         if(!_dos_findfirst(argv[1], 0xffff, &amp;find)) {

                  printf(&quot;\n&quot;
                         &quot;\nИмя файла    Аттр. Дата        Время     Размер&quot;
                         &quot;\n------------ ----- ----------  --------  ------&quot;);

// Выводим информацию о первом найденном файле на экран

                  print_info(&amp;find);
         }
         else {
                  printf(&quot;Задайте образец для поиска файлов !&quot;);
                  exit(-1);
         }

// Выводим информацию об остальных найденных файлах

         while(!_dos_findnext(&amp;find)) print_info( &amp;find );

         exit(0);
}

// Функция для вывода информации о найденных файлах

void print_info(struct find_t *pfind) {

         char timebuf[10], datebuf[12];

// Преобразуем формат даты и времени последнего изменения файла

         date_conv(pfind-&gt;wr_date, datebuf);
         time_conv(pfind-&gt;wr_time, timebuf);

// Выводим содержимое дескриптора файла

                printf(&quot;\n%-12s&quot;,pfind-&gt;name);
                printf(&quot; %02X    %8s  %8s %8ld &quot;,
                        pfind-&gt;attrib,
                        datebuf,
                        timebuf,
                        pfind-&gt;size);
}

// Функция преобразования формата времени

char *time_conv(unsigned t, char *buf) {

         int h, m;

         h = (t &gt;&gt; 11) &amp; 0x1f, m = (t &gt;&gt; 5) &amp; 0x3f;
         sprintf(buf, &quot;%2.2d:%02.2d:%02.2d&quot;, h % 12, m, (t &amp; 0x1f) * 2);
         return buf;
}

// Функция преобразования формата даты

char *date_conv(unsigned d, char *buf) {

         sprintf(buf, &quot;%2.2d.%02.2d.%04.2d&quot;,
                                 d &amp; 0x1f,(d &gt;&gt; 5) &amp; 0x0f, (d &gt;&gt; 9) + 1980);
         return buf;
}</font>
</pre>

<p>При запуске программы с параметром *.com на экран
будет выведена информация: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Имя файла    Аттр. Дата        Время     Размер
------------ ----- ----------  --------  ------
CURDIR.COM   20    24.02.1991  08:40:24     5879 
DIRCTL.COM   20    24.02.1991  09:10:30     6273 
DISK_CTL.COM 20    13.01.1991  03:26:34     8177 
DISKA.COM    20    19.01.1991  10:08:58       27 
DISKB.COM    20    04.02.1991  08:57:34     6186 
DISKINFO.COM 20    24.02.1991  04:08:42     6075 
DISKSHOW.COM 20    31.01.1991  09:48:34     6989 
PARTSHOW.COM 20    07.02.1991  06:12:02     7357 
DIRM.COM     20    26.02.1991  11:59:50     6346 </font>
</pre>

<h3><a NAME="ch3_4"><font SIZE="4" COLOR="#008000">3.4. Работа с файлами</font></a>
</h3>

<p>В этом разделе мы рассмотрим функции MS-DOS,
предназначенные для создания, переименования,
удаления и перемещения файлов. Операции чтения
из файла и записи в файл будут описаны в
следующем разделе. </p>

<p>Для создания файла предназначена функция <b>3Ch</b>
прерывания <b>INT 21h</b>. С помощью этой функции может
быть создан файл как в текущем, так и в любом
другом каталоге. Если файл с указанным именем уже
существует, он обрезается до нулевой длины.
Будьте осторожны при использовании этой функции
- она может уничтожить нужный вам файл. </p>

<p>Дополнительно функция <b>3Ch</b> выполняет
операцию открытия только что созданного файла,
возвращая программе файловый индекс. При
создании файла программа может указать
требуемые атрибуты, которые будут использованы
другими функциями для определения возможности
предоставления доступа к файлу. </p>

<p>Приведем формат вызова функции создания файла:<br>
</p>

<table>
  <tr>
    <td WIDTH="116"><b>На входе:</b></td>
    <td WIDTH="382"><b>AH</b> = 3Ch </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="382"><b>CX</b> = Атрибуты создаваемого файла: <br>
    <b>00h</b> - обычный файл;<br>
    <b>01h </b>- только читаемый файл;<br>
    <b>02h</b> - скрытый файл;<br>
    <b>04h </b>- системный файл. </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="382"><b>DS:DX</b> = Адрес строки, содержащей путь
    создаваемого файла </td>
  </tr>
  <tr>
    <td WIDTH="116"><b>На выходе:</b></td>
    <td WIDTH="382"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    Файловый индекс, если флаг переноса сброшен в 0. </td>
  </tr>
</table>

<p>При выполнении этой функции возможны следующие
ошибки: 

<ul>
  <li>отсутствует какой-либо элемент в пути для
    создаваемого файла, например, диск или каталог; </li>
  <li>была сделана попытка создать файл в корневом
    каталоге, но корневой каталог переполнен; </li>
  <li>в указаннном каталоге уже есть файл с таким
    именем, и этот файл имеет атрибут &quot;Только
    читаемый&quot;; </li>
  <li>пользователь, который работает в сети, не имеет
    прав доступа для выполнения указанной операции. </li>
</ul>

<p>Операционная система игнорирует попытки
создания с помощью этой функции каталогов или
метки диска. </p>

<p>Для того, чтобы случайно не уничтожить
содержимое файла с таким же именем, как и
создаваемый, программа может использовать
функцию <b>5Bh</b>. Эта функция проверяет заданный
путь на предмет наличия указанного файла. Если
такой файл уже существует, функция возвращает
программе признак ошибки. </p>

<p>Формат вызова функции:<br>
</p>

<table>
  <tr>
    <td WIDTH="133"><b>На входе:</b></td>
    <td WIDTH="396"><b>AH</b> = 5Bh </td>
  </tr>
  <tr>
    <td WIDTH="133"></td>
    <td WIDTH="396"><b>CX</b> = Атрибуты создаваемого файла: <br>
    <b>00h</b> - обычный файл;<br>
    <b>01h</b> - только читаемый файл;<br>
    <b>02h</b> - скрытый файл;<br>
    <b>04h</b> - системный файл. </td>
  </tr>
  <tr>
    <td WIDTH="133"></td>
    <td WIDTH="396"><b>DS:DX </b>= Адрес строки, содержащей путь
    создаваемого файла </td>
  </tr>
  <tr>
    <td WIDTH="133"><b>На выходе:</b></td>
    <td WIDTH="396"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    Файловый индекс, если флаг переноса сброшен в <b>0</b>.
    </td>
  </tr>
</table>

<p>Если вам требуется временный файл, вы можете
создать его с помощью функции <b>5Ah</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="122"><b>На входе:</b></td>
    <td WIDTH="386"><b>AH</b> = 5Ah </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="386"><b>CX</b> = Атрибуты создаваемого файла: <br>
    <b>00h</b> - обычный файл;<br>
    <b>01h</b> - только читаемый файл;<br>
    <b>02h</b> - скрытый файл;<br>
    <b>04h</b> - системный файл. </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="386"><b>DS:DX</b> = Адрес буфера, в который функция
    запишет путь созданного временного файла. Размер
    этого буфера должен быть по крайней мере 13
    байтов. </td>
  </tr>
  <tr>
    <td WIDTH="122"><b>На выходе:</b></td>
    <td WIDTH="386"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>;<br>
    Файловый индекс, если флаг переноса сброшен в <b>0</b>.
    </td>
  </tr>
</table>

<p>Операционная система не будет автоматически
удалять созданный временный файл после
завершения работы программы или перезагрузки.
Программа должна сама удалить этот файл. </p>

<p>Перед тем, как начать работу с файлом, его нужно
открыть. Функции, создающие новые файлы,
открывают новые файлы автоматически. Для того,
чтобы открыть существующий файл, вы можете
воспользоваться функцией <b>3Dh</b>:<br>
</p>

<table>
  <tr>
    <td WIDTH="122"><b>На входе:</b></td>
    <td WIDTH="374"><b>AH</b> = 3Dh </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="374"><b>AL</b> = Требуемый режим доступа: <br>
    <br>
    <i><b>Бит 7: флаг наследования</b></i> <br>
    <br>
    0 - файловый индекс наследуется порожденным
    процессом <br>
    1 - файловый индекс не наследуется порожденным
    процессом<br>
    <br>
    <i><b>Биты 4...6: режим разделения</b></i> <br>
    <br>
    000 - режим совместимости <br>
    001 - запрещение всех видов доступа <br>
    010 - запрещение записи <br>
    011 - запрещение чтения <br>
    100 - разрешение всех видов доступа <br>
    <br>
    <i><b>Бит 3:0 - зарезервировано <br>
    <br>
    Биты 0...2: вид доступа <br>
    <br>
    </b></i>000 - чтение <br>
    001 - запись <br>
    010 - чтение/запись </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="374"><b>DS:DX</b> = Адрес строки, содержащей путь
    открываемого файла </td>
  </tr>
  <tr>
    <td WIDTH="122"><b>На выходе:</b></td>
    <td WIDTH="374"><b>AX</b> = Код ошибки, если флаг переноса <b>CF</b>
    был установлен в <b>1</b>; <br>
    Файловый индекс, если флаг переноса сброшен в <b>0</b>.
    </td>
  </tr>
</table>

<p>С помощью функции <b>3Dh</b> можно открыть любой
файл (но не каталог). Если требуется вид доступа
&quot;запись&quot;, открываемый файл не должен иметь
атрибут &quot;Только читаемый&quot;. </p>

<p>Для использования битов <b>4...7</b> (управляющих
доступом к файлу другими программами в сети)
должна быть запущена программа <b>SHARE.EXE.</b> </p>

<p>Если используется бит наследования, то
порожденному процессу наследуются запрошенный
при открытии файла вид доступа. </p>

<p>Операционная система MS-DOS версии 4.0 имеет в
своем составе функцию <b>6Ch</b>, обладающую
расширенными возможностями по созданию и
открытию файлов:<br>
</p>

<table>
  <tr>
    <td WIDTH="105"><b>На входе:</b></td>
    <td WIDTH="448"><b>AH</b> = 6Ch </td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>AL</b> = 00h</td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>BX</b> = байт флагов расширенного режима
    открытия файла </td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>CX</b> = атрибуты создаваемого файла,
    используется только при создании файлов </td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>DX</b> = выполняемая функция, если файл
    существует или не существует: <br>
    <br>
    Биты 0-3 регистра <b>DX</b> задают действие, если файл
    существует:<br>
    <br>
    0000h - если файл существует, вернуть признак ошибки<br>
    0001h - если файл существует, открыть его <br>
    0002h - если файл существует, заместить и открыть
    его<br>
    <br>
    Биты 4-7 регистра <b>DX</b> задают действие, если файл
    не существует: <br>
    <br>
    0000h - если файл не существует, вернуть признак
    ошибки<br>
    0001h - если файл не существует, создать и открыть
    его </td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>DS:SI</b> = Адрес строки, содержащей путь
    открываемого файла </td>
  </tr>
  <tr>
    <td WIDTH="105"><b>На выходе:</b></td>
    <td WIDTH="448"><b>AX</b> = Код ошибки, если флаг переноса <b>CF</b>
    был установлен в <b>1</b>;<br>
    Файловый индекс, если флаг переноса сброшен в <b>0</b>.
    </td>
  </tr>
  <tr>
    <td WIDTH="105"></td>
    <td WIDTH="448"><b>CX</b> = Код выполненных действий:<br>
    0 - файл был открыт <br>
    1 - файл был создан и открыт <br>
    2 - файл был замещен и открыт </td>
  </tr>
</table>

<p>Регистр <b>BX</b> на входе задает флаги
расширенного режима открытия файла в следующем
формате:<br>
</p>

<table>
  <tr>
    <td WIDTH="91"><i><b>Биты</b></i></td>
    <td WIDTH="416"><i><b>Назначение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>0...2</b></td>
    <td WIDTH="416">Режим доступа при чтении/записи </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>3</b></td>
    <td WIDTH="416">Зарезервировано, должно быть равно 0 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>4...6</b></td>
    <td WIDTH="416">Режим разделения </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>7</b></td>
    <td WIDTH="416">Флаг наследования </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>8...12</b></td>
    <td WIDTH="416">Зарезервировано, должно быть равно 0 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>13</b></td>
    <td WIDTH="416"><b>0</b> - Режим обычного использования
    обработчика критических ошибок <b>INT&nbsp;24h</b> <br>
    <b>1</b> - Блокировка обработчика критических ошибок<b>
    INT&nbsp;24h. </b>Для того, чтобы узнать причину ошибки,
    программа должна использовать функцию <b>59h</b>
    прерывания <b>INT&nbsp;21h </b>MS-DOS. </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>14</b></td>
    <td WIDTH="416">Управление буферизацией: <br>
    <b>0</b> - Использование стандартной для MS-DOS
    буферизации.<br>
    <b>1</b> - Отмена буферизации. Использование этого
    режима замедлит работу с диском, однако
    вероятность потери информации при аварии в
    питающей сети уменьшится. </td>
  </tr>
</table>

<p>Описанная выше функция является как бы
комбинацией функций <b>3Dh</b> и <b>3Ch</b> (открытие и
создание файла). Она удобна, но при ее
использовании программа должна убедиться в том,
что версия используемой операционной системы не
ниже, чем 4.0. </p>

<p>Удалить файл можно при помощи функции <b>41h</b>
прерывания<b> INT&nbsp;21h:<br>
</b></p>

<table>
  <tr>
    <td WIDTH="117"><b>На входе:</b></td>
    <td WIDTH="381"><b>AH</b> = 41h </td>
  </tr>
  <tr>
    <td WIDTH="117"></td>
    <td WIDTH="381"><b>DS:DX</b> = Адрес строки в формате ASCIIZ,
    содержащей имя удаляемого файла. </td>
  </tr>
  <tr>
    <td WIDTH="117"><b>На выходе:</b></td>
    <td WIDTH="381"><b>AL</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>. </td>
  </tr>
</table>

<p>С помощью этой функции нельзя удалить файл,
имеющий атрибут &quot;Только читаемый&quot;. </p>

<p>Под удалением файла понимается вычеркивание
файла из каталога и освобождение всех
принадлежавших ранее этому файлу кластеров. Эти
кластеры отмечаются в таблице размещения файлов
как свободные. Уничтожения информации на диске
при стирании файлов не происходит, поэтому в
некоторых случаях можно полностью восстановить
случайно удаленные файлы. </p>

<p>Стандартные библиотеки трансляторов Microsoft QC 2.5
и C 6.0 содержат функции для работы с файлами. Эти
функции можно разделить на две группы - функции
ввода/вывода низкого уровня и функции
ввода/вывода потоком. Вторая группа функций
использует буферизацию и будет рассмотрена в
разделе, посвященном буферизованному
вводу/выводу. </p>

<p>Функции ввода/вывода низкого уровня
отображаются на описанные выше функции
прерывания<b> INT&nbsp;21h</b> (и функции этого же
прерывания, предназначенные для чтения/записи,
позиционирования и т.д.). </p>

<p>Для создания файла можно использовать функцию<b>
creat()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int creat(char *filename, int mode);</font>
</pre>

<p>Эта функция и ее параметры описаны в файлах <b>io.h,
sys\types.h, sys\stat.h, errno.h.</b> </p>

<p>Первый параметр определяет путь создаваемого
файла и его имя. Если файл с указанным именем
существует, и не имеет атрибута &quot;Только
читаемый&quot;, функция сбрасывает длину файла до
нуля. Предыдущее содержимое файла при этом
уничтожается. </p>

<p>Второй параметр позволяет задать атрибуты
создаваемого файла. Он может иметь следующие
значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="107"><b>S_IWRITE</b></td>
    <td WIDTH="393">для создаваемого файла разрешена
    операция записи; </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>S_IREAD</b></td>
    <td WIDTH="393">для создаваемого файла разрешена
    операция чтения; </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>S_IREAD | S_IWRITE</b></td>
    <td WIDTH="393">для создаваемого файла разрешены
    операции чтения и записи. </td>
  </tr>
</table>

<p>В операционных системах MS-DOS и OS/2 невозможно
создать файл, в который можно было бы писать, но
из которого было бы нельзя читать информацию.
Поэтому задание второго параметра как<b> S_IWRITE</b>
приведет к созданию такого файла, для которого
разрешены как операция записи, так и операция
чтения. </p>

<p>После создания файла функция<b> creat()</b> открывает
новый файл и возвращает файловый индекс (<b>handle</b>)
или код ошибки. </p>

<p>Мощная функция <b>open()</b> предназначена как для
открытия существующих файлов, так и для создания
новых: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int open(char *filename, int oflag [, int pmode]);</font>
</pre>

<p>Первый и третий параметры в этой функции
аналогичны параметрам функции <b>creat(),</b> причем
третий параметр нужен только при создании нового
файла. Квадратные скобки указывают на то, что
этот параметр является необязательным. </p>

<p>Параметр oflag может являться результатом
битовой операции <b>ИЛИ</b> над следующими
константами, определенными в файле <b>fcntl.h: <br>
</b></p>

<table BORDER="1">
  <tr>
    <td WIDTH="124"><b>O_APPEN</b></td>
    <td WIDTH="404">при записи в файл информация будет
    добавляться в конец файла; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_BINARY</b></td>
    <td WIDTH="404">файл открывается для работы в двоичном
    режиме (игнорируются управляющие символы, такие
    как конец строки); </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_CREAT</b></td>
    <td WIDTH="404">создается новый файл и открывается для
    записи; эта константа игнорируется, если
    указанный в первом параметре файл уже
    существует; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_EXCL</b></td>
    <td WIDTH="404">используется вместе с <b>O_CREAT</b>; если
    указанный в первом параметре файл существует,
    функция возвратит признак ошибки; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_RDONLY</b></td>
    <td WIDTH="404">файл открывается только для чтения,
    попытка записи в файл приведет к тому, что
    функция записи вернет признак ошибки; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_RDWR</b></td>
    <td WIDTH="404">файл открывается как для чтения, так и
    для записи; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_TEXT</b></td>
    <td WIDTH="404">файл открывается в текстовом режиме; </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_TRUNC</b></td>
    <td WIDTH="404">существующий файл открывается и
    обрезается до нулевой длины (если для этого файла
    разрешена операция записи); </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>O_WRONLY</b></td>
    <td WIDTH="404">файл открывается только для записи (в
    операционных системах MS-DOS и OS/2 для файла,
    открытого с признаком<b> O_WRONLY</b> разрешено
    выполнение операции чтения). </td>
  </tr>
</table>

<p>Для того, чтобы закрыть файл, открытый
функциями <b>creat()</b> или <b>open()</b>, нужно
использовать функцию <b>close():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int close(int handle);</font>
</pre>

<p>В качестве параметра функции передается
файловый индекс, полученный при открытии или
создании файла. Функция возвращает <b>0</b> при
успешном закрытии файла, или <b>-1</b> при ошибке. </p>

<p>Код ошибки для этой и других функций
cтандартных библиотек трансляторов Microsoft QC 2.5 и C
6.0 записывается в глобальную переменную errno. </p>

<h3><a NAME="ch3_5"><font SIZE="4" COLOR="#008000">3.5. Чтение/запись
файлов</font></a></h3>

<p>После того, как вы открыли файл, можно выполнять
над ним операции чтения/записи. Для записи данных
в файл предназначена функция <b>40h</b> прерывания <b>INT&nbsp;21h</b>.
В качестве параметров для этой функции
необходимо задать файловый индекс, полученный
при открытии существующего файла или создании
нового, адрес буфера, содержащего записываемые
данные и количество записываемых байтов: <br>
</p>

<table>
  <tr>
    <td WIDTH="112"><b>На входе:</b></td>
    <td WIDTH="378"><b>AH</b> = 40h </td>
  </tr>
  <tr>
    <td WIDTH="112"></td>
    <td WIDTH="378"><b>BX</b> = файловый индекс открытого файла </td>
  </tr>
  <tr>
    <td WIDTH="112"></td>
    <td WIDTH="378"><b>CX</b> = количество записываемых байтов </td>
  </tr>
  <tr>
    <td WIDTH="112"></td>
    <td WIDTH="378"><b>DS:DX</b> = Адрес буфера, содержащего
    записываемые данные </td>
  </tr>
  <tr>
    <td WIDTH="112"><b>На выходе:</b></td>
    <td WIDTH="378"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    Количество действительно записанных байтов,
    если флаг переноса <b>CF</b> сброшен в <b>0</b>. </td>
  </tr>
</table>

<p>При записи данные попадают в то место внутри
файла, которое определяется содержимым так
называемого файлового указателя позиции. При
создании нового файла этот указатель
сбрасывается в 0, что соответствует началу файла.
При открытии файла с помощью функции <b>3Dh</b>
указатель также устанавливается на начало файла.
Операция записи в файл с помощью функции <b>40h</b>
продвигает указатель вперед к концу файла на
количество записываемых байтов. </p>

<p>По мере увеличения размера файла ему будут
распределяться все новые и новые кластеры из
числа отмеченных как свободные. </p>

<p>Если вам необходимо перезаписать содержимое
файла, а не дописывать данные в конец, необходимо
воспользоваться функцией позиционирования. Эта
функция позволяет управлять содержимым
файлового указателя позиции, она будет описана в
следующем разделе. </p>

<p>Следует учитывать, что количество
действительно записанных байтов может не
совпадать с заданным в регистре <b>CX</b> при вызове
функции <b>40h</b>. Такая ситуация возможна, например,
при записи в файл, открытый в текстовом режиме,
байта<b> Ctrl-Z (1Ah)</b>. Этот байт означает конец
текстового файла. Другая возможная причина -
отсутствие свободного места на диске. </p>

<p>Если функция вызывается с содержимым регистра <b>CX</b>,
равным <b>0</b>, файл будет обрезан или расширен до
текущего положения файлового указателя. </p>

<p>Разумеется, что если программа, выполняющая
запись в файл, работает в сети, она должна иметь
соответствующие права доступа к каталогу и
файлу. </p>

<p>Функция <b>40h</b> может выполнять запись не только
в файл, но и в устройство посимвольной обработки,
предварительно открытое функцией <b>3Dh</b>. Об этом
мы говорили в разделах книги, посвященных
драйверам. </p>

<p>Для чтения данных из файла (или устройства
посимвольной обработки) предназначена функция <b>3Fh</b>
прерывания<b> INT&nbsp;21h</b>: <br>
</p>

<table>
  <tr>
    <td WIDTH="123"><b>На входе:</b></td>
    <td WIDTH="368"><b>AH</b> = 3Fh </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="368"><b>BX</b> = файловый индекс открытого файла </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="368"><b>CX</b> = количество читаемых байтов </td>
  </tr>
  <tr>
    <td WIDTH="123"></td>
    <td WIDTH="368"><b>DS:DX</b> = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="123"><b>На выходе:</b></td>
    <td WIDTH="368"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    Количество действительно прочитанных байтов,
    если флаг переноса <b>CF</b> сброшен в <b>0</b>. </td>
  </tr>
</table>

<p>Эта функция используется аналогично функции
записи. Для нее верны все замечания, касающиеся
файлового указателя позиции, количества
действительно прочитанных байтов и прав доступа.
</p>

<p>Если ваша программа составлена на языке
программирования С, для записи и чтения данных
она может воспользоваться функциями <b>write()</b> и<b>
read()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int write(int handle, void *buffer, unsigned count);

int read(int handle, void *buffer, unsigned count);</font>
</pre>

<p>Эти функции работают аналогично функциям <b>40h</b>
и <b>3Fh</b> прерывания <b>INT&nbsp;21h</b>. Параметр <b>handle</b>
определяет файл, для которого необходимо
выполнить операцию записи или чтения. Параметр <b>buffer</b>
- указатель на буфер, который содержит данные для
записи или в который необходимо поместить
прочитанные данные. Количество
записываемых/читаемых байтов определяется
третьим параметром - <b>count</b>. </p>

<p>После выполнения операции функция возвращает
количество действительно записанных или
прочитанных данных или <b>-1 </b>при ошибке. Будьте
внимательны, если вы записываете или читаете
больше 32К байтов - вы можете получить признак
ошибки, хотя передача данных выполнилась
правильно. Большие массивы данных можно
записывать по частям. </p>

<p>В качестве примера мы приведем программу
копирования файлов, которая пользуется
описанными выше функциями ввода/вывода: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;io.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys\types.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;

void main(int, char *[]);
void main(int argc, char *argv[]) {

         int source, taget, i;
         char *buffer;
         unsigned count;

         if(argc == 3) {

// Открываем исходный копируемый файл

                 if((source = open(argv[1], O_BINARY | O_RDONLY)) == - 1) {

                          printf(&quot;\nОшибка при открытии исходного файла: %d&quot;,
                          errno);
                          exit(-1);

                 }

// Открываем выходной файл. При необходимости создаем
// новый. Если файл уже существует, выводим на экран
// запрос на перезапись содержимого существующего файла

                taget = open(argv[2], O_BINARY | O_WRONLY | O_CREAT | O_EXCL,
                                                 S_IREAD | S_IWRITE);
                if(errno == EEXIST) {

                        printf(&quot;\nФайл существует. Перезаписать? (Y,N)\n&quot;);

// Ожидаем ответ оператора и анализируем его

                        i = getch();
                        if((i == 'y') || (i == 'Y'))
                                taget = open(argv[2], O_BINARY | O_WRONLY | O_CREAT | O_TRUNC,
                                                                 S_IREAD | S_IWRITE);

                }

// Если выходной файл открыть невозможно, выводим
// сообщение об ошибке и завершаем работу программы

                if(taget == -1){
                          printf(&quot;\nОшибка при открытии выходного файла: %d&quot;,
                          errno);
                          exit(-1);
                }

// Будем читать и писать за один раз 10000 байтов

                count = 10000;

// Заказываем буфер для передачи данных

                if((buffer = (char *)malloc(count)) == NULL) {
                          printf(&quot;\nНедостаточно оперативной памяти&quot;);
                          exit(-1);
                }


// Копируем исходный файл

                while(!eof(source)) {

// Читаем count байтов в буфер buffer

                        if((count = read(source, buffer, count)) == -1) {
                          printf(&quot;\nОшибка при чтении: %d&quot;,
                          errno);
                          exit(-1);
                        }

// Выполняем запись count байтов из буфера в выходной файл

                        if((count = write(taget, buffer, count)) == - 1) {
                          printf(&quot;\nОшибка при записи: %d&quot;,
                          errno);
                          exit(-1);
                        }
                }

// Закрываем входной и выходной файлы

                close(source);
                close(taget);

// Освобождаем память, заказанную под буфер

                free(buffer);
         }

// Если при запуске программы не были указаны
// пути для входного или выходного файла,
// выводим сообщение об ошибке

         else
                  printf(&quot;\n&quot;
                                &quot;Задайте пути для исходного&quot;
                                &quot; и результирующего файлов!\n&quot;);
}</font>
</pre>

<p>В приведенной программе для определения конца
исходного файла использована функция <b>eof():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int eof(int handle);</font>
</pre>

<p>Для файла с файловым индексом <b>handle</b> эта
функция возвращает одно из трех значений:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="356">достигнут конец файла; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>0</b></td>
    <td WIDTH="356">конец файла не достигнут; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>-1</b></td>
    <td WIDTH="356">ошибка, например, неправильно указан <b>handle</b>.
    </td>
  </tr>
</table>

<p>Программа, которая читает файл с помощью
функции <b>3Fh</b> прерывания<b> INT&nbsp;21h</b>, может
определить момент достижения конца файла,
анализируя код ошибки в регистре <b>AX</b>. </p>

<h3><a NAME="ch3_6"><font SIZE="4" COLOR="#008000">3.6. Позиционирование</font></a>
</h3>

<p>Управляя содержимым файлового указателя
позиции, программа может произвольно считывать
или перезаписывать различные участки файла, то
есть организовать прямой доступ к содержимому
файла. Прямой доступ к файлу может вам
понадобится, например, для создания систем
управления базами данных. </p>

<p>Установить файловый указатель в нужную вам
позицию можно с помощью функции <b>42h</b> прерывания<b>
INT&nbsp;21h</b> MS-DOS:<br>
</p>

<table>
  <tr>
    <td WIDTH="137"><b>На входе:</b></td>
    <td WIDTH="367"><b>AH</b> = 42h </td>
  </tr>
  <tr>
    <td WIDTH="137"></td>
    <td WIDTH="367"><b>AL</b> = метод кодирования: <br>
    00h абсолютное смещение от начала файла <br>
    01h смещение от текущей позиции <br>
    02h смещение от конца файла </td>
  </tr>
  <tr>
    <td WIDTH="137"></td>
    <td WIDTH="367"><b>BX</b> = файловый индекс открытого файла </td>
  </tr>
  <tr>
    <td WIDTH="137"></td>
    <td WIDTH="367"><b>CX</b> = старший байт смещения </td>
  </tr>
  <tr>
    <td WIDTH="137"></td>
    <td WIDTH="367"><b>DX</b> = младший байт смещения </td>
  </tr>
  <tr>
    <td WIDTH="137"><b>На выходе:</b></td>
    <td WIDTH="367"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    Младший байт текущей позиции, если флаг переноса <b>CF</b>
    сброшен в 0. </td>
  </tr>
  <tr>
    <td WIDTH="137"></td>
    <td WIDTH="367"><b>DX</b> = Старший байт текущей позиции </td>
  </tr>
</table>

<p>Функция позволяет указывать новое значение
указателя либо как абсолютное смещение от начала
файла, либо как смещение от текущей позиции, либо
как смещение от конца файла. В последних двух
случаях используется смещение со знаком. Для
указания смещения или абсолютной позиции
программа должна задать в регистрах <b>CX, DX</b>
32-битовое значение. </p>

<p>Если использовать метод кодирования <b>02h</b> и
задать нулевое смещение, функция установит
указатель на конец файла. Это обстоятельство
может быть использовано для определения размера
файла в байтах. </p>

<p>Что произойдет, если при использовании методов
кодирования <b>01h</b> или <b>02h</b> попытаться
установить указатель позиции до начала файла? </p>

<p>Функция <b>42h</b> при этом не возвратит признак
ошибки, однако если будет сделана попытка
прочитать или записать данные, то
соответствующая функция чтения/записи
завершится с ошибкой. </p>

<p>Стандартные библиотеки трансляторов Microsoft QC 2.5
и C 6.0 содержат функции, предназначенные для
управления содержимым файлового указателя
позиции и получения текущего значения этого
указателя. Это функции <b>lseek(), tell(), filelength()</b>. </p>

<p>Функция<b> lseek()</b> работает аналогично только что
описанной функции <b>42h</b>. Приведем ее прототип: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">long lseek(int handle, long offset, int origin);</font>
</pre>

<p>Первый параметр определяет файл, для которого
выполняется операция позиционирования. Параметр
<b>offset</b> определяет смещение. Последний параметр
задает метод кодирования смещения. Он может
принимать следующие значения, описанные в фале <b>stdio.h</b>:
<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="107"><b>SEEK_SET</b></td>
    <td WIDTH="385">Абсолютное смещение от начала файла </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>SEEK_CUR</b></td>
    <td WIDTH="385">Смещение относительно текущей позиции </td>
  </tr>
  <tr>
    <td WIDTH="107"><b>SEEK_END</b></td>
    <td WIDTH="385">Смещение относительно конца файла </td>
  </tr>
</table>

<p>Функция возвращает величину текущего смещения
в байтах относительно начала файла или<b> -1L</b>, в
случае ошибки. Как и для остальных функций
библиотеки С, код ошибки находится в глобальной
переменной <b>errno</b>. </p>

<p>Вы, конечно, можете использовать функцию<b> lseek()</b>
для определения размера файла или текущей
файловой позиции. Однако для того, чтобы узнать
размер файла, лучше воспользоваться специальной
функцией<b> filelength()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">long filelength(int handle);</font>
</pre>

<p>Функция возвращает размер файла в байтах. Файл
задается параметром <b>handle</b>. В случае ошибки
функция возвращает значение<b> -1L.</b> </p>

<p>Для того, чтобы определить текущую файловую
позицию, можно использовать функцию <b>tell()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">long tell(int handle);</font>
</pre>

<p>Эта функция возвращает текущую позицию для
файла, определенного параметром <b>handle</b>, или <b>-1L</b>,
в случае ошибки. </p>

<p>Для демонстрации использования функций
позиционирования приведем простую программу,
которая для заданного файла и позиции внутри
файла отображает содержимое одного байта.
Дополнительно программа определяет размер файла
и текущую позицию после чтения байта. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

void main(void);
void main(void) {

         int handle;
         long position, length;
         char buffer[2], fname[80];

// Запрашиваем имя файла, с которым будем работать

         printf(&quot;Введите имя файла: &quot;);
         gets(fname);

// Открываем файл

         handle = open(fname, O_BINARY | O_RDONLY);

// Если такого файла нет, выводим сообщение об ошибке
// и завершаем работу программы

         if(handle == -1) {
                printf(&quot;\nНет такого файла!&quot;);
                exit(-1);
         }

// Определяем и выводим на экран размер файла в байтах

         length = filelength(handle);

         printf(&quot;\nДлина файла %s составляет %ld байтов\n&quot;, fname, length);

// Запрашиваем позицию для чтения и отображения байта

         do {

                  printf(&quot;Введите позицию: &quot;);
                  scanf(&quot;%ld&quot;, &amp;position);

         } while(position &gt; length);

// Устанавливаем заданную позицию

         lseek(handle, position, SEEK_SET);

// Читаем один байт в буфер, начиная с установленной
// позиции

         if(read(handle, buffer, 1) == -1) {

// Для вывода сообщения об ошибке используем функцию perror(),
// которая добавляет к сообщению, заданному в параметре,
// расшифрованное системное сообщение об ошибке.
// Код ошибки функция perror() берет из переменной errno.

                perror(&quot;Ошибка при чтении&quot;);
                exit(-1);
         }

// Выводим считанный байт на экран

         printf( &quot;Смещение: %ld; байт: %02.2x ('%c')\n&quot;,
                        position, (unsigned char)*buffer, *buffer);

// Определяем текущую позицию и выводим ее
// на экран

         position = tell(handle);
         printf(&quot;\nТекущая позиция в файле: %ld\n&quot;, position);

// Закрываем файл

         close(handle);
}</font>
</pre>

<h3><a NAME="ch3_7"><font SIZE="4" COLOR="#008000">3.7. Изменение
атрибутов, времени и даты файлов</font></a></h3>

<p>Напомним: атрибуты файла, время и дата его
последней модификации, а также размер файла
хранятся в дескрипторе файла. Дескриптор файла
находится в каталоге. </p>

<p>Операционная система предоставляет вам все
необходимые средства для изменения всех полей
дескриптора файла, кроме номера начального
кластера. Для изменения этого номера вам
придется работать с каталогом через таблицу
размещения файлов <b>FAT</b>. Вам придется сначала
считать каталог по кластерам с помощью
прерывания<b> INT&nbsp;25h,</b> модифицировать нужные
поля и записать каталог обратно на диск при
помощи прерывания <b>INT&nbsp;26h.</b> </p>

<p>Для работы с полем атрибутов файла
предназначена функция <b>43h</b> прерывания <b>INT&nbsp;21h:<br>
</b></p>

<table>
  <tr>
    <td WIDTH="116"><b>На входе:</b></td>
    <td WIDTH="372"><b>AH</b> = 43h </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="372"><b>AL</b> = выполняемая операция: <br>
    00h чтение атрибутов файла <br>
    01h установка новых атрибутов файла </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="372"><b>CX</b> = новые атрибуты файла, если <b>AL</b> =
    01h: <br>
    Биты:<br>
    5 - бит архивации <br>
    4 - каталог <br>
    3 - метка диска <br>
    2 - системный файл <br>
    1 - скрытый файл <br>
    0 - только читаемый файл </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="372"><b>DS:DX</b> = путь файла в формате ASCIIZ </td>
  </tr>
  <tr>
    <td WIDTH="116"><b>На выходе:</b></td>
    <td WIDTH="372"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b> </td>
  </tr>
  <tr>
    <td WIDTH="116"></td>
    <td WIDTH="372"><b>CX</b> = Если не было ошибки, этот регистр
    содержит атрибуты файла </td>
  </tr>
</table>

<p>При изменении атрибутов файла допустимо
указывать комбинации битов в регистре <b>CX</b>. </p>

<p>Если ваша программа работает в сети, она должна
иметь соответствующие права доступа к каталогу,
содержащему файл, для которого программа
собирается изменять байт атрибутов. </p>

<p>Для работы с полями времени и даты последней
модификации файла предназначена функция <b>57h</b>
прерывания <b>INT&nbsp;21h:<br>
</b></p>

<table>
  <tr>
    <td WIDTH="113"><b>На входе:</b></td>
    <td WIDTH="397"><b>AH</b> = 57h </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>AL</b> = выполняемая операция: <br>
    00h чтение даты и времени <br>
    01h установка даты и времени </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>BX</b> = файловый индекс открытого файла </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>CX</b> = время</td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>DX</b> = дата</td>
  </tr>
  <tr>
    <td WIDTH="113"><b>На выходе:</b></td>
    <td WIDTH="397"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b> </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>CX</b> = Если не было ошибки, этот регистр
    содержит время последнего изменения файла </td>
  </tr>
  <tr>
    <td WIDTH="113"></td>
    <td WIDTH="397"><b>DX</b> = Если не было ошибки, этот регистр
    содержит дату последнего изменения файла </td>
  </tr>
</table>

<p>Для того, чтобы изменить время или дату
последней модификации файла с помощью этой
функции, файл предварительно должен быть открыт.
Формат времени и даты для этой функции такой же,
как и используемый в дескрипторе каталога.
Приведем эти форматы еще раз для удобства. </p>

<p>Формат поля времени: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">15            11 10               5 4                   0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Часы (0...23) ¦  Минуты (0...59) ¦  Секунды/2 (0...29) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Формат поля даты:

15             9 8               5 4              0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Год (0...119) ¦  Месяц (1...12) ¦  День (1...31) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>Стандартные библиотеки трансляторов Microsoft QC 2.5
и C 6.0 содержат функции для чтения и изменения
атрибутов файлов и времени/даты их последней
модификации. </p>

<p>Для определения атрибутов файла можно
использовать функцию <b>_dos_getfileattr()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _dos_getfileattr(char *path, unsigned *attrib);</font>
</pre>

<p>Эта функция получает атрибуты файла, заданного
первым аргументом, и записывает байт атрибутов в
младший байт по адресу, указанному вторым
параметром. </p>

<p>В случае успешного завершения функция
возвращает <b>0</b>, в противном случае она
возвращает код ошибки, полученный от
операционной системы и устанавливает глобальную
переменную errno в значение <b>ENOENT</b>, что означает
отсутствие указанного в параметре <b>path</b> файла. </p>

<p>Для изменения атрибутов файла можно
использовать функцию <b>_dos_setfileattr():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _dos_setfileattr(char *path, unsigned attrib);</font>
</pre>

<p>Параметр <b>attrib</b> может принимать следующие
значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="128"><b>_A_ARCH</b></td>
    <td WIDTH="366">установка бита архивации </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_HIDDEN</b></td>
    <td WIDTH="366">файл скрытый </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_NORMAL</b></td>
    <td WIDTH="366">обычный файл </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_RDONLY</b></td>
    <td WIDTH="366">только читаемый файл </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_SUBDIR</b></td>
    <td WIDTH="366">каталог</td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_SYSTEM</b></td>
    <td WIDTH="366">системный файл </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>_A_VOLID</b></td>
    <td WIDTH="366">метка диска </td>
  </tr>
</table>

<p>Для определения времени последней модификации
файла можно использовать функцию<b> _dos_getftime():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _dos_getftime(int handle, unsigned *date, unsigned *time);</font>
</pre>

<p>Перед использованием этой функции программа
должна открыть файл. Дата и время записываются по
адресу, указываемому, соответственно, вторым и
третьим параметрами. </p>

<p>Если вам надо изменить время или дату последней
модификации файла, используйте функцию<b>
_dos_setftime():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _dos_setftime(int handle, unsigned date, unsigned time);</font>
</pre>

<p>Параметры этой функции аналогичны
используемым в функции <b>_dos_getftime()</b>, за
исключением того, что в качестве второго и
третьего параметра применяются не указатели, а
непосредственные значения даты и времени. </p>

<p>Приведем программу, изменяющую при запуске
значение бита файла атрибутов &quot;Только
читаемый&quot; для файла, имя которого передается
программе в качестве параметра: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(int argc, char *argv[]);
void main(int argc, char *argv[]) {

         unsigned fattr;

         _dos_getfileattr(argv[1], &amp;fattr);

         _dos_setfileattr(argv[1], fattr ^ _A_RDONLY);
}</font>
</pre>

<p>Программа сначала считывает байт атрибутов,
затем инвертирует соответствующий бит и
устанавливает новое значение байта атрибутов. </p>

<h3><a NAME="ch3_8"><font SIZE="4" COLOR="#008000">3.8. Буферизация
ввода/вывода</font></a></h3>

<p>Ввод/вывод для дисков в операционной системе
MS-DOS буферизован. Это означает, что данные не
сразу записываются на диск, а накапливаются в
специальном массиве (буфере). По мере заполнения
буфер сбрасывается на диск. При чтении
информация заполняет весь входной буфер,
независимо от количества байтов, которые
программа читает из файла. В дальнейшем, если
программе потребуются данные, которые уже были
считаны с диска и записаны во входной буфер, она
получит данные непосредственно из этого буфера.
Обращения к диску при этом не будет. </p>

<p>Буферизация сокращает затраты времени на
ввод/вывод, особенно в тех случаях, когда
программе периодически требуется одни и те же
участки файлов. При копировании файлов
буферизация сокращает время на перемещение
головок от исходного файла к результирующему и
обратно, причем эффект получается тем больше, чем
больше размер используемого буфера. </p>

<p>Операционная система MS-DOS имеет несколько
буферов. Их количество зависит от оператора <b>BUFFERS</b>,
находящегося в файле <b>CONFIG.SYS</b>. Этот оператор
позволяет определить от 2 до 99 буферов. Если файл <b>CONFIG.SYS</b>
не содержит оператора <b>BUFFERS</b>, по умолчанию
используются два буфера. </p>

<p>При увеличении количества буферов
увеличивается вероятность того, что нужная часть
файла уже считана и находится в оперативной
памяти. Однако необходимо учитывать, что для
хранения буферов расходуется основная
оперативная память. Кроме того, с ростом
количества буферов увеличивается время,
необходимое операционной системе на анализ
состояния буферов, что может привести к снижению
производительности. Значительное снижение
скорости работы наступает при количестве
буферов порядка 50. </p>

<p>Обычно для машин класса AT с диском размером 20-40
мегабайтов рекомендуется использовать 32 буфера,
однако для каждого конкретного случая может
потребоваться подбор этого параметра для
оптимизации производительности системы. </p>

<p>Если ваша программа интенсивно использует
обращение к каталогам файловой системы, вы
можете использовать утилиту MS-DOS <b>FASTOPEN</b>,
которая запоминает в оперативной памяти
расположение на диске файлов и каталогов,
уменьшая интенсивность обращения к диску.
Например, при использовании следующей команды в
оперативной памяти будет храниться информация о
расположении максимально о 100 файлах и каталогах:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FASTOPEN c:=100</font>
</pre>

<p>В операционной системе MS-DOS версии 4.0 вы можете
указать для утилиты <b>FASTOPEN</b> опцию<b> /X</b>. Эта
опция вызывает размещение информации о файлах и
каталогах в дополнительной (<b>expanded</b>) памяти. Для
этой версии операционной системы вызов утилиты <b>FASTOPEN</b>
лучше всего выполнять через оператор <b>INSTALL</b>
файла <b>CONFIG.SYS:</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">INSTALL=C:\DOS\FASTOPEN d: =(n,m) ... [/X]</font>
</pre>

<p>В приведенной выше строке используются
следующие обозначения: <br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>d:</b></td>
    <td WIDTH="446">обозначение диска; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>n</b></td>
    <td WIDTH="446">количество файлов или каталогов, для
    которых необходимо запомнить расположение,
    может иметь значение от 1 до 999, по умолчанию
    используется 34; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>m</b></td>
    <td WIDTH="446">количество буферов для
    фрагментированных файлов, может иметь значение
    от 1 до 999, по умолчанию используется 34; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>/X</b></td>
    <td WIDTH="446">задает расположение буферов в
    дополнительной памяти. </td>
  </tr>
</table>

<p>Еще один способ организовать буферизацию
ввода/вывода для жестких дисков - использовать
драйвер <b>SMARTDRV.SYS. </b>Этот драйвер позволяет
создать для диска кэш-память в расширенной или
дополнительной памяти. Например, следующая
строка в файле <b>CONFIG.SYS</b> определяет дисковый кэш
размером 530 килобайтов, размещенный в
расширенной памяти: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">device=c:\dos\smartdrv.sys 530</font>
</pre>

<p>Кэш-память особенно эффективна при работе с
базами данных, когда вам периодически требуется
одна и та же информация. Если создать кэш-память
достаточно большого размера, можно значительно
сократить количество обращений к диску. </p>

<p>Если вы используете кэш-память для диска, не
следует задавать оператор <b>BUFFERS</b> в файле <b>CONFIG.SYS
</b>или пользоваться утилитой <b>FASTOPEN</b>, так как это
приведет к многократной буферизации и вызовет
излишние пересылки данных в оперативной памяти. </p>

<p>Буферизация данных имеет и свои недостатки.
Если в результате аварии в питающей сети или по
какой-то другой причине компьютер выключился, то
информация, хранящаяся в буферах и не записанная
на диск, будет потеряна. </p>

<p>При закрытии файла все буфера, связанные с ним,
сбрасываются на диск. Если вам надо сбросить
буфера, не закрывая файл, это можно сделать с
помощью функции <b>68h</b> прерывания <b>INT&nbsp;21h</b>: <br>
</p>

<table>
  <tr>
    <td WIDTH="128"><b>На входе:</b></td>
    <td WIDTH="360"><b>AH</b> = 68h </td>
  </tr>
  <tr>
    <td WIDTH="128"></td>
    <td WIDTH="360"><b>BX</b> = файловый индекс открытого файла </td>
  </tr>
  <tr>
    <td WIDTH="128"><b>На выходе:</b></td>
    <td WIDTH="360"><b>AX</b> = Код ошибки, если был установлен в <b>1</b>
    флаг переноса <b>CF</b>; <br>
    <b>0</b>, если операция выполнена успешно. </td>
  </tr>
</table>

<p>Дополнительно обновляется дескриптор файла в
каталоге, а именно поля времени, даты и размера
файла. </p>

<p>Обратите также внимание на функцию
расширенного открытия файлов <b>6Ch</b>, входящую в
состав MS-DOS версии 4.0. Эта функция позволяет при
открытии файла отменить буферизацию. </p>

<p>Стандартные библиотеки трансляторов Microsoft QC 2.5
и C 6.0 содержат многочисленные функции,
использующие собственный механизм буферизации
при работе с файлами. Их часто называют функциями
потокового ввода/вывода. Такую буферизацию не
следует путать с буферизацией, выполняемой
операционной системой. Имена всех этих функций
начинаются на<b> f - fopen(), fclose(), fprintf()</b> и т.д. </p>

<p>Функции потокового ввода/вывода хорошо описаны
во многих учебных пособиях по языку
программирования Си, поэтому мы приведем лишь
краткий обзор этих функций, делая акцент на
особенностях их применения. </p>

<p>При использовании функций потокового
ввода/вывода файлы открываются функцией<b> fopen()</b>,
закрываются функцией<b> fclose()</b>. Эти функции не
только открывают и закрывают файлы (получают и
освобождают их файловый индекс), но и,
соответственно, создают и уничтожают структуру
типа <b>FILE</b>, описанную в файле <b>stdio.h</b> и
связанную с данным файлом: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">extern FILE  {

                char *_ptr;     // положение текущего символа
                int   _cnt;       // количество оставшихся байтов
                char *_base;    // адрес буфера
                char  _flag;     // флаг управления доступом
                char  _file;     // файловый индекс

} _NEAR _CDECL _iob[];</font>
</pre>

<p>Для организации потокового ввода/вывода
вначале необходимо при помощи функции <b>fopen()</b>
открыть файл. Функция <b>fopen()</b> имеет следующий
прототип: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FILE *fopen(char *filename, char *mode);</font>
</pre>

<p>Первый параметр указывает на строку,
содержащую путь открываемого файла, второй - на
строку режима открытия файла. Возможны следующие
режимы:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>&quot;r&quot;</b></td>
    <td WIDTH="439">файл открывается для чтения; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>&quot;w&quot;</b></td>
    <td WIDTH="439">файл открывается для записи; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>&quot;a&quot;</b></td>
    <td WIDTH="439">файл открывается для записи, данные
    будут добавляться в конец файла. </td>
  </tr>
</table>

<p>К буквам <b>r, w, a</b> справа могут добавляться
буквы <b>t</b> и <b>b</b>. </p>

<p>Буква <b>t</b> означает, что файл будет открыт в
текстовом режиме, <b>b</b> - в двоичном. Для двоичного
режима не производится обработка таких символов,
как конец строки, конец файла и т.д. </p>

<p>Строка режима открытия файла может
дополнительно содержать символ <b>'+'</b>. Этот
символ означает, что для файла разрешены
операции чтения и записи одновременно. </p>

<p>Для закрытия файлов, открытых для ввода/вывода
потоком, должна использоваться функция<b> fclose()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fclose(FILE *stream);</font>
</pre>

<p>При закрытии файла освобождаются и
сбрасываются на диск все буфера, распределенные
этому файлу. </p>

<p>Если вы открыли файл с помощью низкоуровневой
функции <b>open()</b>, вы можете создать поток для
этого файла, используя функцию <b>fdopen():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FILE *fdopen(int handle, char *mode);</font>
</pre>

<p>В качестве первого параметра используется
файловый индекс, полученный от функции <b>open(),</b>
второй параметр аналогичен парметру <b>mode</b> для
функции <b>fopen()</b>. </p>

<p>Для того чтобы закрыть поток, созданный
функцией <b>fdopen(),</b> необходимо использовать
функцию<b> fclose()</b>, а не <b>close()</b>. </p>

<p>Для открытого потока вы можете узнать файловый
индекс с помощью функции <b>fileno():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fileno(FILE *stream);</font>
</pre>

<p>Функция возвращает файловый индекс, связанный
с данным потоком. </p>

<p>Существуют потоки, соответствующие
стандартным устройствам ввода, вывода, вывода
сообщений об ошибках, стандартное устройство
последовательного ввода/вывода и стандартное
устройство печати. Для использования этих
потоков не требуются процедуры открытия и
закрытия. Для работы с потоками,
соответствующими стандартным устройствам
ввода/вывода, в функциях необходимо указывать:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="81"><b>stdin</b></td>
    <td WIDTH="406">стандартное устройство ввода; </td>
  </tr>
  <tr>
    <td WIDTH="81"><b>stdout</b></td>
    <td WIDTH="406">стандартное устройство вывода; </td>
  </tr>
  <tr>
    <td WIDTH="81"><b>stderr</b></td>
    <td WIDTH="406">стандартное устройство для вывода
    сообщений об ошибках; </td>
  </tr>
  <tr>
    <td WIDTH="81"><b>stdaux</b></td>
    <td WIDTH="406">стандартное последовательное
    устройство ввода/вывода; </td>
  </tr>
  <tr>
    <td WIDTH="81"><b>stdprn</b></td>
    <td WIDTH="406">стандартное печатающее устройство. </td>
  </tr>
</table>

<p>Для работы со стандартными устройствами
ввода/вывода в библиотеках трансляторов для
языка программирования Си имеется
соответствующий набор функций, которые должны
быть вам хорошо известны - <b>printf(), scanf(), putchar()</b> и
т.д.. Мы не будем их описывать для экономии места. </p>

<p>Приведем обзор функций, предназначенных для <i><b>потокового
ввода/вывода</b></i>. </p>

<p>Для записи данных в поток предназначена
функция <b>fwrite()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">size_t fwrite(void *buffer, size_t size,
                        size_t count, FILE *stream);</font>
</pre>

<p>Эта функция записывает в файл <b>stream</b> блоки
информации, каждый из которых имеет длину <b>size</b>
байтов. Количество блоков - <b>count</b>. Данные для
записи расположены по адресу <b>buffer</b>. </p>

<p>Если файл открыт в текстовом режиме, каждый
символ возврата каретки <b>CR</b> заменяется на два
символа - возврата каретки <b>CR</b> и перевода
строки <b>LF</b>. </p>

<p>Функция возвращает количество действительно
записанных блоков информации, без учета замены
символа <b>CR</b> в текстовом режиме. </p>

<p>Чтение данных потоком можно выполнить с
помощью функции <b>fread()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">size_t fread(void *buffer, size_t size,
                        size_t count, FILE *stream);</font>
</pre>

<p>Эта функция используется аналогично
предыдущей. Для распознавания конца файла и
обнаружения ошибок после вызова этой функции
необходимо использовать функции<b> feof() </b>и <b>ferror().</b>
</p>

<p>Если при использовании функции <b>fread() </b>вы
задали значения параметров <b>size</b> или <b>count</b>,
равные нулю, функция <b>fread()</b> не изменяет
содержимое буфера <b>buffer</b>. </p>

<p>Для позиционирования внутри файла, открытого
потоком с помощью функции <b>fopen()</b>, предназначена
функция <b>fseek()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fseek(FILE *stream, long offset, int origin);</font>
</pre>

<p>В этой функции параметр <b>offset</b> задает новое
содержимое указателя текущей позиции в файле <b>stream</b>,
а параметр <b>origin</b> - определяет способ задания
новой позиции. Этот оператор может иметь
значения, аналогичные используемым в функции<b>
lseek()</b>: <br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="124"><b>SEEK_SET</b></td>
    <td WIDTH="375">Абсолютное смещение от начала файла </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>SEEK_CUR</b></td>
    <td WIDTH="375">Смещение относительно текущей позиции </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>SEEK_END</b></td>
    <td WIDTH="375">Смещение относительно конца файла </td>
  </tr>
</table>

<p>При открытии файла указатель текущей позиции
устанавливается на начало файла. Операции
ввода/вывода вызывают увеличение значения этого
указателя на количество прочитанных/записанных
байтов. </p>

<p>Функция <b>fseek()</b> позволяет вам установить
указатель за конец файла, однако при попытке
установаит указатель до начала файла функция
возвратит признак ошибки - ненулевое значение. </p>

<p>При использовании функции <b>fseek() </b>для
позиционирования внутри файлов, открытых в
текстовом режиме, необходимо учитывать
особенность обработки текстовых файлов -
автоматическую замену символа возврата каретки <b>CR</b>
на пару символов: возврат каретки <b>CR</b> и перевод
строки <b>LF</b>. Для текстовых файлов функция <b>fseek()</b>
будет правильно работать только в следующих двух
случаях: 

<ul>
  <li>поиск со смещением <b>offset</b>, равным нулю, при
    любом значении параметра <b>origin</b>; </li>
  <li>поиск выполняется относительно начала файла,
    причем в качестве смещения <b>offset</b> используется
    значение, полученное специальной функцией<b> ftell()</b>.
  </li>
</ul>

<p>Функция <b>ftell()</b> возвращает текущее значение
указателя позиции для файла, или<b> -1</b> при ошибке:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">long ftell(FILE *stream);</font>
</pre>

<p>Пара функций<b> ftell() - fseek()</b> позволит вам
правильно организовать позиционирование для
файлов, открытых в текстовом режиме. </p>

<p>Есть еще одна возможность организовать
позиционирование внутри файлов, открытых
потоком - использовать пару функций <b>fgetpos() - fsetpos()</b>:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fgetpos(FILE *stream, fpos_t *pos);

int fsetpos(FILE *stream, fpos_t *pos);</font>
</pre>

<p>Эти две функции используют для запоминания и
установки позиции переменную с типом<b> fpos_t,</b>
определенным в файле <b>stdio.h. </b>Функция <b>fgetpos()</b>
записывает в эту переменную текущую позицию в
потоке <b>stream</b>. Содержимое переменной затем
может быть использовано для установки позиции в
потоке с помощью функции<b> fsetpos().</b> </p>

<p>Обе эти функции возвращают нулевое значение в
случае успешного завершения работы, или
ненулевое - при ошибке. </p>

<p>Среди функций потокового ввода/вывода можно
выделить группу функций форматного ввода/вывода.
Это такие функции, как <b>fputc(), fgetc(), fputs(), fgets(), fprintf(),
fscanf()</b>. </p>

<p>Функции форматного ввода/вывода сильно
облегчают запись/чтение таких элементов данных,
как отдельные байты, текстовые строки, числа в
различных форматах. </p>

<p>Для записи в поток отдельных байтов
используется функция <b>fputc():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fputc(int c, FILE *stream);</font>
</pre>

<p>Байт c записывается в файл stream начиная с текущей
позиции. После записи текущая позиция
увеличивается на единицу. Функция возвращает
записываемый байт или значение <b>EOF</b>, которое
служит признаком ошибки. </p>

<p>Для побайтового чтения содержимого файла,
открытого потоком, удобно использовать функцию<b>
fgetc():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fgetc(FILE *stream);</font>
</pre>

<p>Эта функция возвращает считанный из файла и
преобразованный к типу <b>int</b> байт из потока <b>stream</b>.
После чтения байта текущая позиция в файле
увеличивается на единицу. </p>

<p>При достижении конца файла или в случае ошибок
функция <b>fgetc() </b>возвращает значение <b>EOF</b>.
Однако для проверки на ошибку или конец файла
лучше пользоваться специальными функциями<b>
ferror()</b> и <b>feof()</b>. Если вы открыли файл в двоичном
режиме, единственный способ определить момент
достижения конца файла - использовать функцию <b>feof()</b>,
так как значение константы <b>EOF</b> может
находиться в любом месте двоичного файла. </p>

<p>Для работы со строками предназначены функции <b>fputs()</b>
и<b> fgets()</b>. </p>

<p>Функция<b> fputs()</b> предназначена для вывода
строки в файл, открытый потоком: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fputs(char *string, FILE *stream);</font>
</pre>

<p>Первый параметр определяет выводимую строку,
второй - файл, в который эта строка выводится.
Двоичный ноль, закрывающий строку, в выходной
файл не копируется. После вывода строки
содержимое текущего указателя позиции
увеличивается на количество записанных байтов. </p>

<p>Для ввода строк из текстового файла удобна
функция <b>fgets():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fgets(char *string, int n, FILE *stream);</font>
</pre>

<p>Функция читает байты из потока <b>stream</b> и
записывает их в буфер <b>string</b> до тех пор, пока не
произойдет одно из двух событий - будет прочитан
символ новой строки <b>'\n'</b> или количество
прочитанных символов не будет равно <b>n-1</b>. </p>

<p>После того, как байты будут прочитаны в буфер, в
конец образованной из этих байтов строки функция
записывает двоичный ноль. Если был прочитан
символ новой строки<b> '\n'</b>, он тоже записывается
в буфер. </p>

<p>Для анализа достижения конца файла или ошибок
необходимо использовать функции <b>feof()</b> и<b> ferror()</b>.
</p>

<p>Для форматного вывода в файл содержимого
переменных удобно использовать функцию <b>fprintf()</b>:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fprintf(FILE *stream, char *format [,arg]...);</font>
</pre>

<p>Эта функция аналогична хорошо известной вам
функции форматного вывода на экран<b> printf(),</b> с
которой обычно начинают изучение языка
программирования Си. Вспомните такую программу: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
main() {
   printf(&quot;Hello, world!&quot;);
}</font>
</pre>

<p>Функция<b> fprintf()</b> имеет дополнительно один
параметр - <b>stream</b>, который определяет выходной
файл. </p>

<p>После завершения работы функция возвращает
количество записанных байтов или отрицательную
величину, если при записи произошла ошибка. </p>

<p>Для форматного ввода информации из файла можно
использовать функцию <b>fscanf()</b>, аналогичную
известной вам функции <b>scanf():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fscanf(FILE *stream, char *format [,arg]...);</font>
</pre>

<p>Эта функция читает данные, начиная с текущей
позиции в потоке <b>stream</b>, в переменные,
определенные аргументами <b>arg</b>. Каждый аргумент
должен являться указателем на переменную,
соответствующую типу, определенному в строке
формата <b>format</b>. </p>

<p>Функция<b> fscanf()</b> возвращает количество успешно
считанных и преобразованных в указанный формат
полей. Те поля, которые были считаны, но не
преобразовывались, в возвращаемом функцией
значении не учитываются. </p>

<p>При достижении конца файла функция возвращает
значение <b>EOF</b>. Если функция возвратила нулевое
значение, это означает, что преобразование полей
не производилось. </p>

<p>Рассмотрим теперь функции, управляющие
буферизацией для потокового ввода/вывода. </p>

<p>Функция <b>setbuf()</b> позволяет вам заменить
системный буфер на свой собственный: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void setbuf(FILE *stream, char *buffer);</font>
</pre>

<p>Параметр <b>buffer</b> должен указывать на
подготовленный пользователем массив, имеющий
размер <b>BUFSIZ</b> байтов. Константа <b>BUFSIZ</b> описана
в файле <b>stdio.h.</b> </p>

<p>Функция <b>setvbuf()</b> позволяет программе не только
указать свой буфер, но и задать его размер: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int setvbuf(FILE *stream, char *buffer, int mode,
                        size_t size);</font>
</pre>

<p>Параметр <b>stream</b> должен указывать на открытый
поток, причем для этого потока до вызова функции <b>setvbuf()</b>
нельзя выполнять операции чтения/записи. </p>

<p>Параметр <b>buffer</b> должен указыват на
подготовленный программой буфер размером <b>size</b>
байтов. Этот буфер будет использоваться для
работы с потоком <b>stream</b>. </p>

<p>Параметр <b>mode</b> может иметь значения<b> _IOFBF, _IOLBF,
_IONBF</b>. Если <b>mode</b> равно <b>_IOFBF</b> или <b>_IOLBF</b>,
параметр <b>size</b> указывает размер буфера. Если
параметр mode равен<b> _IONBF</b>, буферизация не
используется, парметры <b>buffer</b> и <b>size</b>
игнорируются. </p>

<p>Параметры <b>_IOFBF</b> и <b>_IOLBF</b> эквивалентны. </p>

<p>Если в качестве адреса буфера <b>buffer</b> задать
значение <b>NULL</b>, функция автоматически закажет
буфер размером <b>size</b>. </p>

<p>Функция <b>setvbuf() </b>возвращает ноль при успешном
завершении и ненулевую величину, если указан
неправильный парметр <b>mode</b> или неправильный
размер буфера <b>size</b>. </p>

<p>Для чего может понадобиться изменение размера
буфера? </p>

<p>Главным образом - для сокращения времени,
необходимого для позиционирования магнитных
головок при выполнении операций одновременно
над несколькими файлами, например, при
копировании файлов, слиянии нескольких файлов в
один и т.д. </p>

<p>При закрытии потока функцией <b>fclose()</b>
содержимое буфера записывается на диск. Если
программе необходимо выполнить запись
содержимого буфера на диск без закрытия файла,
она может воспользоваться функцией<b> fflush():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int fflush(FILE *stream);</font>
</pre>

<p>Эта функция возвращает ноль при успешной
записи буфера на диск, а так же в тех случаях,
когда поток либо совсем не имеет буферов, либо
открыт только для чтения. При ошибке
возвращается значение <b>EOF</b>. </p>

<p>Если поток открыт только для чтения, функция<b>
fflush()</b> очищает содержимое буфера, связанного с
этим потоком. </p>

<p>В качестве примера приведем текст программы,
копирующей содержимое текстового файла.
Программа копирует этот файл три раза. В первый
раз одна использует буфер стандартного размера,
затем увеличивает размер буфера в десять раз, и,
наконец, копирует файл без использования
механизма буферизации. Каждый раз программа
измеряет продолжительность копирования файла с
помощью функции <b>clock()</b>, входящей в состав
стандартных библиотек трансляторов Microsoft QC 2.5 и C
6.0. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

void filecpy(FILE *stream_from, FILE *stream_to);

// Буфера для файлов

char buf1[BUFSIZ * 10];
char buf2[BUFSIZ * 10];

void main(int argc, char *argv[]) {

         time_t start, end;
         FILE *stream_from, *stream_to;


         if(argc &lt; 3) {
                  printf(&quot;Задайте имена файлов!\n&quot;);
                  exit(-1);
         }

// Открываем файлы и используем для копирования
// буфер стандартного размера

         if((stream_from = fopen(argv[1], &quot;rt&quot;)) == NULL) {
                  printf(&quot;Задайте имя входного файла!\n&quot;);
                  exit(-1);
         }
         stream_to = fopen(argv[2], &quot;wt+&quot;);

// Определяем время начала копирования

         start = clock();

// Выполняем копирование файла

         filecpy(stream_from,stream_to);

// Определяем время завершения копирования

         end = clock();

// Выводим время копирования при использовании
// буферов стандартного размера

         printf(&quot;Время копирования: %5.1f Размер буфера, байтов: %d\n&quot;,
                 ((float)end - start) / CLK_TCK, BUFSIZ);


// Задаем свой буфер большего размера

         if((stream_from = fopen(argv[1], &quot;rt&quot;)) == NULL) exit(-1);
         stream_to = fopen(argv[2], &quot;wt+&quot;);

// Устанавливаем буфера как для входного,
// так и для выходного файлов

         setvbuf(stream_from, buf1, _IOFBF, sizeof(buf1));
         setvbuf(stream_to,   buf2, _IOFBF, sizeof(buf2));

// Копируем файл и измеряем продолжительность
// копирования

         start = clock();
         filecpy(stream_from,stream_to);
         end = clock();

         printf(&quot;Время копирования: %5.1f Размер буфера: %d\n&quot;,
                 ((float)end - start) / CLK_TCK, BUFSIZ * 10);

// Копируем без использования буферизации

         if((stream_from = fopen(argv[1], &quot;rt&quot;)) == NULL) exit(-1);
         stream_to = fopen(argv[2], &quot;wt+&quot;);

         setvbuf(stream_from, NULL, _IONBF, 0);
         setvbuf(stream_to,   NULL, _IONBF, 0);

         start = clock();
         filecpy(stream_from,stream_to);
         end = clock();

         printf(&quot;Время копирования: %5.1f Буферизация не используется\n&quot;,
                 ((float)end - start) / CLK_TCK);

         exit(0);
}

// Функция для копирования файлов

void filecpy(FILE *stream_from, FILE *stream_to) {

         char linebuf[256];

// Цикл копирования. Условие выхода из цикла -
// конец входного файла

         while(!feof(stream_from)) {

// Читаем в буфер linebuf одну строку

                  if(fgets(linebuf, 255, stream_from) == NULL) break;

// Записываем содержимое буфера linebuf
// в выходной файл

                  if(fputs(linebuf, stream_to) != 0) break;
         }

// Закрываем входной и выходной файлы

         fclose(stream_from);
         fclose(stream_to);

}</font>
</pre>

<h3><a NAME="ch3_9"><font SIZE="4" COLOR="#008000">3.9. Другие функции для
работы с файлами</font></a></h3>

<p>В задачу данной книги не входит описание всех
функций стандартных библиотек трансляторов
Microsoft QC 2.5 и C 6.0, предназначенных для работы с
дисками и файловой системой. Но мы приведем еще
несколько интересных и полезных на наш взгляд
функций. </p>

<p>Как мы уже отметили, программа может
использовать два режима ввода/вывода для файлов -
текстовый и двоичный. Для переключения этого
режима для открытого файла можно использовать
функцию <b>setmode():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int setmode(int handle, int mode);</font>
</pre>

<p>Первый параметр - файловый индекс. Второй
параметр может принимать два значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="102"><b>O_TEXT</b></td>
    <td WIDTH="375">установить текстовый режим; </td>
  </tr>
  <tr>
    <td WIDTH="102"><b>O_BINARY</b></td>
    <td WIDTH="375">установить двоичный режим. </td>
  </tr>
</table>

<p>Функция <b>setmode() </b>должна вызываться перед
началом ввода/вывода в открытый файл. </p>

<p>Мы рассказывали о позиционировании внутри
файла. Если вам нужно просто установить
указатель позиции на начало файла, открытого для
потокового ввода/вывода, вы можете
воспользоваться функцией<b> rewind():</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void rewind(FILE *stream);</font>
</pre>

<p>Если вам нужно переназначить ввод/вывод для
стандартных устройств (потоков <b>stdin, stdout, stderr</b>),
вы можете использовать функцию<b> freopen()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FILE *freopen(char *filename, char *mode, FILE *stream);</font>
</pre>

<p>Функция <b>freopen()</b> закрывает файл, с которым был
связан поток <b>stream</b>, и переназначает этот поток
файлу, определенному параметром <b>filename</b>.
Параметр <b>mode</b> задается так же, как и для функции<b>
fopen()</b>. </p>

<p>Можно переназначить файловый индекс для файла,
открытого функцией <b>open()</b>. Для этого можно
воспользоваться одной из двух функций - <b>dup()</b>
или <b>dup2()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int dup(int handle);

int dup2(int handle1, int handle2);</font>
</pre>

<p>Первая функция связывает с открытым файлом еще
один файловый индекс. Этот индекс она возвращает
при успешном завершении. В случае ошибки она
возвращает значение<b> -1</b>. </p>

<p>Новый файловый индекс может быть использован
для любых операций над файлом. </p>

<p>Функция<b> dup2() </b>переназначает файловый индекс <b>handle2</b>,
связывая его с тем же файлом, которому
соответствует файловый индекс <b>handle1</b>. Если во
время вызова функции <b>dup2()</b> с файловым индексом <b>handle2</b>
связан какой-либо открытый файл, этот файл
закрывается. В случае успешного завершения
функция <b>dup2()</b> возвращает нулевое значение.
Если произошла ошибка, возвращается значение <b>-1</b>.
</p>

<h3><a NAME="ch3_10"><font SIZE="4" COLOR="#008000">3.10. Таблица открытых
файлов</font></a></h3>

<p>В первой книге при описании векторной таблицы
связи мы говорили о том, что для всех открытых
файлов MS-DOS хранит различную информацию в
специальной таблице. Ее адрес находится в поле <b>file_tab</b>
векторной таблицы связи. </p>

<p>В этой таблице для каждого открытого файла
хранится информация о количестве файловых
индексов (<b>file handle</b>), связанных с данным файлом,
режиме открытия файла (чтение, запись и т.д.),
слово информации об устройстве, указатель на
заголовок драйвера, обслуживающего данное
устройство, элемент дескриптора файла (дата,
время, имя файла, номер начального кластера,
распределенного файлу), номер последнего
прочитанного кластера и т.д. </p>

<p>Теперь, когда вы изучили способы работы с
файлами, имеет смысл еще раз вернуться к разделу,
посвященному таблице открытых файлов. </p>

<p>Вы можете самостоятельно экспериментировать с
этой таблицей. Можно, например, попробовать
создать несколько файловых индексов для
какого-либо файла и посмотреть после этого
содержимое поля, в котором находится количество
файловых индексов, связанных с данным файлом. </p>

<p>Можно попробовать организовать чтение файла
порциями размером в один кластер, при этом каждый
раз выводить содержимое поля, в котором
находится номер последнего прочитанного
кластера. Это один из самых простых способов
получить список кластеров, распределенных
данному файлу. </p>

<p>Однако не обольщайтесь - все что связано с
таблицей файлов, отсутствует в документации по
операционной системе MS-DOS. Используя эту таблицу
для определения списка кластеров или для
каких-либо других целей, вы рискуете потерять
совместимость с последующими версиями
операционной системы.<br>
</p>
</body>
</html>
