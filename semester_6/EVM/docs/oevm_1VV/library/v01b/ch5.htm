<html>

<head>
<title>5. Обработка критических ошибок</title>
</head>

<body BGCOLOR="#ffffff">

<h2><font SIZE="5" COLOR="#FF0000">5. Обработка критических
ошибок</font> </h2>

<p>Операционная система MS-DOS позволяет программам
устанавливать собственный обработчик
критических ошибок аппаратуры. Мы уже говорили о
том, что вектор <b>0000:0090,</b> соответствующий
прерыванию <b>INT&nbsp;24h,</b> содержит адрес
обработчика критических ошибок. Этот обработчик
получает управление от операционной системы,
когда драйвер какого-либо устройства
обнаруживает ошибку аппаратуры. </p>

<p>Обратите внимание на то, что обработчик
критических ошибок не вызывается при работе с
диском через прерывания MS-DOS <b>INT&nbsp;25h/26h,</b> и, тем
более, при работе с диском на уровне прерывания <b>INT&nbsp;13h</b>
<u>BIOS</u><font SIZE="1">BIOS</font>. </p>

<p>При запуске программы MS-DOS копирует адрес
обработчика в префикс сегмента программы <b>PSP</b>,
а после завершения работы программы -
восстанавливает его из <b>PSP</b>. </p>

<p>Стандартный обработчик MS-DOS выводит на экран
сообщение: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Abort, Retry, Ignore, Fail?</font>
</pre>

<p>Если ваша программа должна сама обрабатывать
ошибки аппаратуры, она может установить свой
собственный обработчик критических ошибок. </p>

<p>Когда обработчик получает управление, регистры
процессора содержат информацию, необходимую для
определения причины и места появления ошибки:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="71"><b>AH</b></td>
    <td WIDTH="427">информация об ошибке:<br>
    Биты: <br>
    <b>0</b> - тип операции: <br>
    0 - чтение, 1 - запись <br>
    <b>1...2</b> область диска, где произошла ошибка: <br>
    00 - системные файлы; <br>
    01 - область <b>FAT</b> <br>
    10 - область каталога; <br>
    11 - область данных <br>
    <b>3</b> - 1 - возможен выход с кодом <b>FAIL</b> <br>
    <b>4</b> - 1 - возможен выход с кодом <b>RETRY</b> <br>
    <b>5</b> - 1 - возможен выход с кодом <b>IGNORE</b> <br>
    <b>6</b> зарезервирован, равен 0<br>
    <b>7</b> тип устройства: 0 - диск; 1 - символьное
    устройство </td>
  </tr>
  <tr>
    <td WIDTH="71"><b>AL</b></td>
    <td WIDTH="427">номер диска (если бит 7 регистра <b>AH</b>
    равен 0) </td>
  </tr>
  <tr>
    <td WIDTH="71"><b>DI</b></td>
    <td WIDTH="427">код ошибки (биты 0...7, остальные биты не
    определены) </td>
  </tr>
  <tr>
    <td WIDTH="71"><b>BP:SI</b></td>
    <td WIDTH="427">адрес заголовка драйвера устройства, на
    котором произошла ошибка </td>
  </tr>
</table>

<p>Биты <b>3, 4, 5</b> определены только для DOS версии 3.0
и для более поздних версий. </p>

<p>Обработчик критических ошибок не должен
пользоваться функциями MS-DOS с кодами, большими
чем <b>0Ch</b> (из-за того, что функции MS-DOS не
реентерабельны). </p>

<p>Программа может вывести на экран сообщение об
ошибке и запросить оператора о необходимых
действиях. Ей разрешено также получить
дополнительную уточняющую информацию об ошибке
с помощью функции <b>59h</b> прерывания <b>INT&nbsp;21h</b>
или узнать версию DOS с помощью функции <b>30h</b>
этого же прерывания. Дополнительная информация
об устройстве, в котором произошла ошибка, может
быть получена с использованием адреса заголовка
драйвера устройства, который передается
операционной системой при вызове обработчика в
регистрах <b>BP:SI.</b> </p>

<p>Для определения номера функции DOS, в которой
произошла критическая ошибка,
программа-обработчик может выполнить анализ
стека. Когда обработчик получает управление,
стек имеет следующую структуру: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Адрес возврата в DOS для команды IRET

IP
CS
FLAGS

Содержимое регистров программы перед вызовом INT_21h

AX, BX, CX, DX, SI, DI, BP, DS, ES

Адрес возврата в программу, вызвавшую функцию DOS

IP
CS
FLAGS</font>
</pre>

<p>Выполнив анализ регистра <b>AH</b>, можно
определить номер функции DOS, при вызове которой
произошла ошибка, а зная содержимое остальных
регистров - и все параметры этой функции. </p>

<p>После выполнения всех необходимых действий,
программа обработки критических ошибок должна
возвратить в регистре <b>AL</b> код действия, которое
должна выполнить операционная система для
обработки данной ошибки:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>0</b></td>
    <td WIDTH="448">игнорировать ошибку; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>1</b></td>
    <td WIDTH="448">повторить операцию; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>2</b></td>
    <td WIDTH="448">аварийно закончить задачу, используя
    адрес завершения, записанный в векторе
    прерывания <b>INT&nbsp;23h</b>; </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>3</b></td>
    <td WIDTH="448">вернуть программе управление с
    соответствующим кодом ошибки (этот код можно
    задавать только для DOS версии 3.0 и для более
    поздних версий). </td>
  </tr>
</table>

<p>Если вы пользуетесь операционной системой MS-DOS
версии 4.0, то при открытии файлов с помощью
функции <b>6Ch</b> программа может заблокировать
вызов обработчика критических ошибок. </p>

<p>Для составления программы обработки
критических ошибок вы можете воспользоваться
языком ассемблера или функциями стандартных
библиотек трансляторов Microsoft QC 2.5 и C 6.0 <b>_dos_getvect(),
_dos_setvect(), _chain_intr().</b> Однако лучше всего
использовать специально предназначенные для
этого (и входящие в состав стандартных библиотек
указанных трансляторов) функции <b>_harderr(), _hardresume()</b>
и<b> _hardretn().</b> </p>

<p>Функция <b>_harderr() </b>предназначена для установки
нового обработчика критических ошибок, она имеет
следующий прототип: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void _harderr(void (_far *handler)());</font>
</pre>

<p>Параметр <b>handler</b> - указатель на новую функцию
обработки критических ошибок. </p>

<p>Функции<b> _hardresume()</b> и <b>_hardretn()</b> должны быть
использованы в обработчике критичеких ошибок,
установленном функцией<b> _harderr().</b> </p>

<p>Функция<b> _hardresume()</b> возвращает управление
операционной системе, она имеет прототип: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">_hardresume(int result);</font>
</pre>

<p>Парметр result может иметь следующие значения (в
соответствии с необходимыми действиями):<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="217"><b>_HARDERR_ABORT</b></td>
    <td WIDTH="271">аварийно завершить программу; </td>
  </tr>
  <tr>
    <td WIDTH="217"><b>_HARDERR_FAIL</b></td>
    <td WIDTH="271">вернуть код ошибки; </td>
  </tr>
  <tr>
    <td WIDTH="217"><b>_HARDERR_IGNORE</b></td>
    <td WIDTH="271">игнорировать ошибку; </td>
  </tr>
  <tr>
    <td WIDTH="217"><b>_HARDERR_RETRY</b></td>
    <td WIDTH="271">повторить операцию. </td>
  </tr>
</table>

<p>Эти параметры описаны в файле <b>dos.h.</b> </p>

<p>Функция <b>_hardretn() </b>возвращает управление
непосредственно программе, передавая ей код
ошибки, определяемый параметром функции <b>error</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void _hardretn(int error);</font>
</pre>

<p>При этом программа получает после возврата из
вызванной ей функции DOS код ошибки <b>error</b>. Если
ошибка произошла при выполнении функции с
номером, большим чем <b>38h</b>, дополнительно
устанавливается в <b>1</b> флаг переноса. Если номер
функции был меньше указанного значения, в
регистр <b>AL</b> записывается величина <b>FFh</b>. </p>

<p>Функция обработки критических ошибок <b>handler</b>
имеет следующие параметры: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void _far handler(unsigned deverror, unsigned errcode,
                           unsigned _far *devhdr);</font>
</pre>

<p>Первый параметр - код ошибки устройства. Он
равен содержимому регистра <b>AX</b> при вызове
обработчика прерывания <b>INT&nbsp;24h</b>. Аналогично,
параметр <b>errcode</b> соответствует содержимому
регистра <b>DI</b> - код ошибки. Третий параметр - <b>devhdr</b>
- это указатель на заголовок драйвера устройства
(передаваемый в регистрах <b>BP:SI</b>). </p>

<p>Для демонстрации использования функций
установки обработчика критических ошибок
приведем программу, которая пытается создать
каталог на диске <b>А:.</b> Эта программа сама
обрабатывает критические ошибки, запрашивая у
оператора информацию о необходимых действиях. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">// Эту программу можно запускать только из командной
// строки. При запуске из интегрированной среды QC
// или PWB возможен конфликт с используемым в этих
// средах обработчиком критических ошибок.


#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;
#include &lt;bios.h&gt;

void main(void);
void _far hhandler(unsigned deverr,
                                 unsigned doserr, unsigned _far *hdr);
void _bios_str(char *p);

void main() {

// Устанавливаем обработчик критических ошибок

         _harderr(hhandler);

// Моделируем критическую ошибку. Выполняем попытку создать
// каталог на диске А:. Если мы &quot;забудем&quot; вставить
// в дисковод дискету, будет вызван обработчик
// критической ошибки

         printf(&quot;\nВставьте (или не вставляйте) дискету в дисковод A:&quot;
                   &quot;\nи нажмите любую клавишу...&quot;
                   &quot;\n&quot;);

         getch();

// Создаем каталог

         if(mkdir(&quot;a:\test_ctl&quot;)) {

                  printf(&quot;\nОшибка при создании каталога&quot; );
                  exit(-1);

         }
         else {

                  printf(&quot;\nУспешное создание каталога&quot;);

// Удаляем только что созданный каталог

                  rmdir(&quot;a:test_ctl&quot;);
                  exit(0);

         }
}


// Новый обработчик критических ошибок

void _far hhandler(unsigned deverr,
                                 unsigned doserr, unsigned _far *hdr) {

         int ch;
         static char buf[200], tmpbuf[10];

// Выводим сообщение о критической ошибке

         sprintf(buf,&quot;\n\r&quot;
                                 &quot;\n\rКод ошибки устройтсва: %04.4X&quot;
                                 &quot;\n\rКод ошибки DOS:        %d&quot;
                                 &quot;\n\r\n\r&quot;
                                 &quot;\n\rВыполняемые действия:&quot;
                                 &quot;\n\r  0 - повторить&quot;
                                 &quot;\n\r  1 - отменить&quot;
                                 &quot;\n\r  2 - завершить&quot;
                                 &quot;\n\r----&gt; ?&quot;,
                                 deverr,
                                 doserr);

         _bios_str(buf);

// Вводим ответ с клавиатуры

         ch = _bios_keybrd(_KEYBRD_READ) &amp; 0x00ff;
         _bios_str(&quot;\n\r&quot;);

         switch(ch) {

                  case '0':       // Пытаемся повторить операцию
                  default:

                                _hardresume(_HARDERR_RETRY);

                  case '2':       // Завершаем работу программы

                                _hardresume(_HARDERR_ABORT);

                  case '1':       // Возврат в DOS с кодом ошибки

                                _hardretn(doserr);

         }
}

// Программа для вывода строки символов на экран
// с помощью функции BIOS 0Eh

void _bios_str(char *ptr) {

         union REGS inregs, outregs;
         char *start = ptr;

         inregs.h.ah = 0x0e;
         for(; *ptr; ptr++) {

                  inregs.h.al = *ptr;
                  int86(0x10, &amp;inregs, &amp;outregs);

         }
}</font>
</pre>
</body>
</html>
