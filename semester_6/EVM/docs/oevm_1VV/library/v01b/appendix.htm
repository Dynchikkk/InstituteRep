<html>

<head>
<title>Приложения</title>
</head>

<body BGCOLOR="#ffffff">

<h1><font SIZE="5" COLOR="#800000">7. Приложения</font></h1>

<p>7.1. <a HREF="appendix.htm#a7_1">Управляющие блоки MS-DOS</a> </p>

<p>7.2. <a HREF="appendix.htm#a7_2">Контроллер прерываний 8259</a> </p>

<p>7.3. <a HREF="appendix.htm#a7_3">Сегментная адресация памяти</a>
</p>

<p>7.4. <a HREF="appendix.htm#a7_4">Содержимое файла sysp.h</a> </p>

<p><font FACE="Arial">7.5 <a HREF="appendix.htm#a7_5">Содержимое файла
sysp.inc</a></font> </p>

<p><font FACE="Arial">7.6. <a HREF="appendix.htm#a7_6">MS-DOS версии 5.0</a></font> </p>

<h2><a NAME="a7_1"><font SIZE="5" COLOR="#FF0000">7.1. Управляющие блоки
MS-DOS</font></a></h2>

<p>7.1.1. <a HREF="appendix.htm#a7_1_1">Векторная таблица связи
MS-DOS</a> </p>

<p>7.1.2. <a HREF="appendix.htm#a7_1_2">Блок управления памятью MCB</a>
</p>

<p>7.1.3. <a HREF="appendix.htm#a7_1_3">Префикс программного
сегмента PSP</a> </p>

<p>7.1.4. <a HREF="appendix.htm#a7_1_4">Формат блока DDCB</a> </p>

<p>7.1.5. <a HREF="appendix.htm#a7_1_5">Формат таблицы файлов DFT</a> </p>

<p>7.1.6. <a HREF="appendix.htm#a7_1_6">Заголовок драйвера</a> </p>

<p>7.1.7. <a HREF="appendix.htm#a7_1_7">Формат элемента массива
дисковой информации</a> </p>

<p>7.1.8. <a HREF="appendix.htm#a7_1_8">Заголовок EXE-файла</a> </p>

<p>7.1.9. <a HREF="appendix.htm#a7_1_9">Атрибуты драйвера</a> </p>

<p>7.1.10. <a HREF="appendix.htm#a7_1_10">Заголовок запроса</a> </p>

<p>7.1.11. <a HREF="appendix.htm#a7_1_11">Слово состояния
устройства</a> </p>

<p>7.1.12. <a HREF="appendix.htm#a7_1_12">Коды ошибок</a> </p>

<p>7.1.13. <a HREF="appendix.htm#a7_1_13">Блок BPB</a> </p>

<p>7.1.14. <a HREF="appendix.htm#a7_1_14">Форматы запросов для
различных команд</a> </p>

<p>7.1.15. <a HREF="appendix.htm#a7_1_15">Команды драйвера</a> </p>

<p>7.1.16. <a HREF="appendix.htm#a7_1_16">Коды идентификации типа
компьютера</a> </p>

<p>7.1.17. <a HREF="appendix.htm#a7_1_17">Таблица параметров для
жестких дисков</a> </p>

<p>7.1.18. <a HREF="appendix.htm#a7_1_18">Параметры флоппи-дисков</a>
</p>

<p>7.1.19. <a HREF="appendix.htm#a7_1_19">Таблица параметров
дискеты</a> </p>

<p>7.1.20. <a HREF="appendix.htm#a7_1_20">Таблица параметров
жесткого диска</a> </p>

<p>7.1.21. <a HREF="appendix.htm#a7_1_21">Команды контроллера НГМД</a>
</p>

<p>7.1.22. <a HREF="appendix.htm#a7_1_22">Регистры состояния
контроллера</a> </p>

<p>7.1.23. <a HREF="appendix.htm#a7_1_23">Код ошибки при работе с
диском на уровне BIOS</a> </p>

<p>7.1.24. <a HREF="appendix.htm#a7_1_24">Формат первого сектора
жесткого диска</a> </p>

<p>7.1.25. <a HREF="appendix.htm#a7_1_25">Элементы таблицы разделов
диска</a> </p>

<p>7.1.26. <a HREF="appendix.htm#a7_1_26">Формат записи BOOT для DOS
версий до 4.0</a> </p>

<p>7.1.27. <a HREF="appendix.htm#a7_1_27">Формат BPB для DOS версий до
4.0</a> </p>

<p>7.1.28. <a HREF="appendix.htm#a7_1_28">Формат BOOT-сектора для MS-DOS
версии 4.0</a> </p>

<p>7.1.29. <a HREF="appendix.htm#a7_1_29">Расширенный блок
параметров BIOS</a> </p>

<p>7.1.30. <a HREF="appendix.htm#a7_1_30">Байт-описатель среды media</a>
</p>

<p>7.1.31. <a HREF="appendix.htm#a7_1_31">Обозначение кластеров в FAT</a>
</p>

<p>7.1.32. <a HREF="appendix.htm#a7_1_32">Формат дескриптора файла</a>
</p>

<p>7.1.33. <a HREF="appendix.htm#a7_1_33">Байт атрибутов файла</a> </p>

<p>7.1.34. <a HREF="appendix.htm#a7_1_34">Формат поля времени</a> </p>

<p>7.1.35. <a HREF="appendix.htm#a7_1_35">Формат даты обновления
файла</a> </p>

<p>7.1.36. <a HREF="appendix.htm#a7_1_36">Формат блока DDCB для версий
2.х и 3.х</a> </p>

<p>7.1.37. <a HREF="appendix.htm#a7_1_37">Формат блока DDCB для DOS
версии 4.х</a> </p>

<p>7.1.38. <a HREF="appendix.htm#a7_1_38">Идентификатор BIOS</a> </p>

<h3><a NAME="a7_1_1"><font SIZE="4" COLOR="#008000">7.1.1. Векторная
таблица связи MS-DOS</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="68"><b>(-2) 2 </b></td>
    <td WIDTH="95"><b>mcb_seg</b> </td>
    <td WIDTH="346">сегмент первого управляющего блока
    памяти <b>(MCB)</b> </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(0) 4 </b></td>
    <td WIDTH="95"><b>dev_cb</b> </td>
    <td WIDTH="346">указатель на первый блок управления
    устройствами DOS <b>(DOS Device Control Block)</b> </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+4) 4 </b></td>
    <td WIDTH="95"><b>file_tab</b> </td>
    <td WIDTH="346">указатель на таблицу файлов DOS</td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+8) 4</b></td>
    <td WIDTH="95"><b>clock_dr</b> </td>
    <td WIDTH="346">указатель на драйвер <b>CLOCK$,</b>
    установленный или резидентный </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+12) 4</b></td>
    <td WIDTH="95"><b>con_dr</b> </td>
    <td WIDTH="346">указатель на актуальный драйвер <b>CON</b>,
    установленный или резидентный </td>
  </tr>
  <tr>
    <td WIDTH="68">&nbsp;</td>
    <td WIDTH="95">&nbsp;</td>
    <td WIDTH="346"><i><b>----------- DOS 2.x ----------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+16) 1</b></td>
    <td WIDTH="95"><b>num_lgdr</b> </td>
    <td WIDTH="346">число логических драйверов в системе</td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+17) 2</b></td>
    <td WIDTH="95"><b>max_btbl</b> </td>
    <td WIDTH="346">максимальное число байтов/блоков любого
    блочного устройства </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+19) 4</b></td>
    <td WIDTH="95"><b>disk_buf</b> </td>
    <td WIDTH="346">указатель на первый дисковый буфер</td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+23) -</b></td>
    <td WIDTH="95"><b>null_dr</b> </td>
    <td WIDTH="346">начало драйвера <b>NUL</b> - первого драйвера
    в списке драйверов DOS </td>
  </tr>
  <tr>
    <td WIDTH="68">&nbsp;</td>
    <td WIDTH="95">&nbsp;</td>
    <td WIDTH="346"><i><b>----------- DOS 3.x, 4.x , 5.0-----------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+16) 2 </b></td>
    <td WIDTH="95"><b>max_btbl</b> </td>
    <td WIDTH="346">максимальное число байтов в блоке
    блочного устройства </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+18) 4</b></td>
    <td WIDTH="95"><b>disk_buf</b> </td>
    <td WIDTH="346">указатель на первый дисковый буфер</td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+22) 4</b></td>
    <td WIDTH="95"><b>drv_info</b> </td>
    <td WIDTH="346">укзатель на массив информации об
    устройствах </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+26) 4</b></td>
    <td WIDTH="95"><b>fcb_tabl</b> </td>
    <td WIDTH="346">указатель на таблицу <b>FCB</b></td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+30) 2</b></td>
    <td WIDTH="95"><b>fcb_size</b> </td>
    <td WIDTH="346">размер таблицы <b>FCB</b></td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+32) 1</b></td>
    <td WIDTH="95"><b>num_bdev</b> </td>
    <td WIDTH="346">число блочных устройств</td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+33) 1</b></td>
    <td WIDTH="95"><b>lastdriv</b> </td>
    <td WIDTH="346">значение <b>LASTDRIVE</b> в файле <b>CONFIG.SYS</b> (по
    умолчанию равно 5) </td>
  </tr>
  <tr>
    <td WIDTH="68"><b>(+34)</b></td>
    <td WIDTH="95"><b>null_dr</b> </td>
    <td WIDTH="346">начало драйвера <b>NUL</b> - первого драйвера
    в списке драйверов DOS </td>
  </tr>
</table>

<h3><a NAME="a7_1_2"><font SIZE="4" COLOR="#008000">7.1.2. Блок управления
памятью MCB</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="67"><b>(0) 1 </b></td>
    <td WIDTH="97"><b>type</b></td>
    <td WIDTH="346">тип блока <b>MCB</b> (<b>M</b> или <b>Z</b>)</td>
  </tr>
  <tr>
    <td WIDTH="67"><b>(+1) 2</b></td>
    <td WIDTH="97"><b>owner</b></td>
    <td WIDTH="346">параграф владельца блока (если 0, то блок
    описывает сам себя) </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>(+3) 2</b></td>
    <td WIDTH="97"><b>size</b></td>
    <td WIDTH="346">число параграфов в этом блоке (один
    параграф имеет размер 16 байт) </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>(+5) 11</b></td>
    <td WIDTH="97"><b>reserve</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
</table>

<h3><a NAME="a7_1_3"><font SIZE="4" COLOR="#008000">7.1.3. Префикс
программного сегмента PSP</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="82"><b>(0) 2 </b></td>
    <td WIDTH="92"><b>int20h</b> </td>
    <td WIDTH="348">двоичный код команды <b>int&nbsp;20h </b>(программы
    могут использовать эту команду для завершения
    своей работы) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+2) 2</b></td>
    <td WIDTH="92"><b>mem_top</b> </td>
    <td WIDTH="348">нижняя граница доступной памяти в
    системе в параграфах </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+4) 1</b></td>
    <td WIDTH="92"><b>reserv1</b> </td>
    <td WIDTH="348">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+5) 5</b></td>
    <td WIDTH="92"><b>call_dsp</b> </td>
    <td WIDTH="348">команда вызова <b>FAR CALL</b> диспетчера MS-DOS </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+10) 4</b></td>
    <td WIDTH="92"><b>term_adr</b> </td>
    <td WIDTH="348">адрес завершения <b>(Terminate Address)</b> </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+14) 4</b></td>
    <td WIDTH="92"><b>cbrk_adr</b> </td>
    <td WIDTH="348">адрес обработчика Ctrl-Break</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+18) 4</b></td>
    <td WIDTH="92"><b>crit_err</b> </td>
    <td WIDTH="348">адрес обработчика критической ошибки</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+22) 2</b></td>
    <td WIDTH="92"><b>parn_psp</b> </td>
    <td WIDTH="348">сегмент <b>PSP</b> программы, запустившей
    данную программу (программы-родителя) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+24) 20</b></td>
    <td WIDTH="92"><b>file_tab</b> </td>
    <td WIDTH="348">таблица открытых файлов, если здесь
    находятся байты <b>0FFH</b>, то таблица не
    используется </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+44) 2</b></td>
    <td WIDTH="92"><b>env_seg</b> </td>
    <td WIDTH="348">сегмент блока памяти, содержащего
    переменные среды </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+46) 4</b></td>
    <td WIDTH="92"><b>ss_sp</b> </td>
    <td WIDTH="348">адрес стека <b>SS:SP </b>программы</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+50) 2</b></td>
    <td WIDTH="92"><b>max_open</b> </td>
    <td WIDTH="348">максимальное число открытых файлов</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+52) 4</b></td>
    <td WIDTH="92"><b>file_tba</b> </td>
    <td WIDTH="348">адрес таблицы открытых файлов</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+56) 24</b></td>
    <td WIDTH="92"><b>reserv2</b> </td>
    <td WIDTH="348">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+80) 3</b></td>
    <td WIDTH="92"><b>disp</b></td>
    <td WIDTH="348">диспетчер функций DOS</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+83) 9</b></td>
    <td WIDTH="92"><b>reserv3</b> </td>
    <td WIDTH="348">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+92) 16</b></td>
    <td WIDTH="92"><b>fcb1</b> </td>
    <td WIDTH="348">форматируется как стандартный <b>FCB</b>,
    если первый аргумент командной строки содержит
    правильное имя файла </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+108) 20</b></td>
    <td WIDTH="92"><b>fcb2</b> </td>
    <td WIDTH="348">заполняется для второго аргумента
    командной строки аналогично <b>fcb1</b> </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+128) 1</b></td>
    <td WIDTH="92"><b>p_size</b> </td>
    <td WIDTH="348">число значащих символов в
    неформатированной области параметров, либо
    буфер обмена с диском <b>DTA</b>, назначенный по
    умолчанию </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+129) 127 </b></td>
    <td WIDTH="92"><b>parm</b> </td>
    <td WIDTH="348">неформатированная область параметров,
    заполняется при запуске программы из командной
    строки </td>
  </tr>
</table>

<h3><a NAME="a7_1_4"><font SIZE="4" COLOR="#008000">7.1.4. Формат блока DDCB</font></a></h3>

<p><i><b>для DOS версий 2.х и 3.х:</b></i> </p>

<table BORDER="1">
  <tr>
    <td WIDTH="82"><b>(0) 1 </b></td>
    <td WIDTH="93"><b>drv_num</b> </td>
    <td WIDTH="346">номер устройства (0 соответствует
    устройству <b>А:,</b> 1 - <b>В:</b> и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+1) 1</b></td>
    <td WIDTH="93"><b>drv_numd</b> </td>
    <td WIDTH="346">дополнительный номер устройства внутри
    драйвера </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+2) 2</b></td>
    <td WIDTH="93"><b>sec_size</b> </td>
    <td WIDTH="346">размер сектора в байтах</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+4) 1</b></td>
    <td WIDTH="93"><b>clu_size</b> </td>
    <td WIDTH="346">число, на единицу меньшее количества
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+5) 1</b></td>
    <td WIDTH="93"><b>clu_base</b> </td>
    <td WIDTH="346">число, являющееся степенью 2 числа
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+6) 2</b></td>
    <td WIDTH="93"><b>boot_siz</b> </td>
    <td WIDTH="346">количество зарезервированных секторов
    (boot-сектора, начало корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+8) 1</b></td>
    <td WIDTH="93"><b>fat_num</b> </td>
    <td WIDTH="346">количество копий <b>FAT</b></td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+9) 2</b></td>
    <td WIDTH="93"><b>max_dir</b> </td>
    <td WIDTH="346">максимальное число дескрипторов файлов
    в корневом каталоге (т.е. максимальное число
    файлов, которое может содержать корневой каталог
    на этом устройстве) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+11) 2</b></td>
    <td WIDTH="93"><b>data_sec</b> </td>
    <td WIDTH="346">номер первого сектора данных на диске
    (номер сектора, соответствующего кластеру номер
    2) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+13) 2</b></td>
    <td WIDTH="93"><b>hi_clust</b> </td>
    <td WIDTH="346">максимальное количество кластеров
    (равно увеличенному на 1 количеству кластерова
    данных) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+15) 1</b></td>
    <td WIDTH="93"><b>fat_size</b> </td>
    <td WIDTH="346">количество секторов, занимаемых одной
    копией <b>FAT</b> </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+16) 2</b></td>
    <td WIDTH="93"><b>root_sec</b> </td>
    <td WIDTH="346">номер первого сектора корневого
    каталога</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+18) 4</b></td>
    <td WIDTH="93"><b>drv_addr</b> </td>
    <td WIDTH="346"><b>FAR</b>-адрес заголовка драйвера,
    обслуживающего данное устройство </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+22) 1</b></td>
    <td WIDTH="93"><b>media</b> </td>
    <td WIDTH="346">байт описания среды носителя данных</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+23) 1</b></td>
    <td WIDTH="93"><b>acc_flag</b> </td>
    <td WIDTH="346">флаг доступа, 0 означает, что к
    устройству был доступ </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+24) 4</b></td>
    <td WIDTH="93"><b>next</b></td>
    <td WIDTH="346">адрес следующего блока <b>DDCB</b>, для
    последнего блока в поле смещения находится число
    <b>FFFF</b> </td>
  </tr>
  <tr>
    <td WIDTH="82">&nbsp;</td>
    <td WIDTH="93">&nbsp;</td>
    <td WIDTH="346"><i><b>----------- только для DOS 2.x --------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+28) 2</b></td>
    <td WIDTH="93"><b>dir_clu</b> </td>
    <td WIDTH="346">номер начального кластера текущего
    каталога (0 для корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+30) 64</b></td>
    <td WIDTH="93"><b>dir_path</b> </td>
    <td WIDTH="346">строка в формате ASCIIZ, содержащая путь к
    текущему каталогу </td>
  </tr>
  <tr>
    <td WIDTH="82">&nbsp;</td>
    <td WIDTH="93">&nbsp;</td>
    <td WIDTH="346"><i><b>--------------- DOS 3.х -------------------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+28) 2</b></td>
    <td WIDTH="93"><b>reserv1</b> </td>
    <td WIDTH="346">зарезервировано, обычно равно 0</td>
  </tr>
  <tr>
    <td WIDTH="82"><b>(+30) 2</b></td>
    <td WIDTH="93"><b>built</b> </td>
    <td WIDTH="346">число <b>FFFF</b> в этом поле означает, что
    блок <b>DDCB</b> был построен </td>
  </tr>
</table>

<p><i><b>для DOS версии 4.х </b></i>: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="83"><b>(0) 1 </b></td>
    <td WIDTH="92"><b>drv_num</b> </td>
    <td WIDTH="348">номер устройства (0 соответствует
    устройству <b>А:</b>, 1 - <b>В:</b> и т.д.) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+1) 1</b></td>
    <td WIDTH="92"><b>drv_numd</b> </td>
    <td WIDTH="348">дополнительный номер устройства внутри
    драйвера </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+2) 2</b></td>
    <td WIDTH="92"><b>sec_size</b> </td>
    <td WIDTH="348">размер сектора в байтах</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+4) 1</b></td>
    <td WIDTH="92"><b>clu_size</b> </td>
    <td WIDTH="348">число, на единицу меньшее количества
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+5) 1</b></td>
    <td WIDTH="92"><b>clu_base</b> </td>
    <td WIDTH="348">число, являющееся степенью 2 числа
    секторов в кластере </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+6) 2</b></td>
    <td WIDTH="92"><b>boot_siz</b> </td>
    <td WIDTH="348">количество зарезервированных секторов
    (boot-сектора, начало корневого каталога) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+8) 1</b></td>
    <td WIDTH="92"><b>fat_num</b> </td>
    <td WIDTH="348">количество копий <b>FAT</b></td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+9) 2</b></td>
    <td WIDTH="92"><b>max_dir</b> </td>
    <td WIDTH="348">максимальное число дескрипторов файлов
    в корневом каталоге (т.е. максимальное число
    файлов, которое может содержать корневой каталог
    на этом устройстве) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+11) 2</b></td>
    <td WIDTH="92"><b>data_sec</b> </td>
    <td WIDTH="348">номер первого сектора данных на диске
    (номер сектора, соответствующего кластеру номер
    2) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+13) 2</b></td>
    <td WIDTH="92"><b>hi_clust</b> </td>
    <td WIDTH="348">максимальное количество кластеров
    (равно увеличенному на 1 количеству кластеров
    данных) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+15) 1</b></td>
    <td WIDTH="92"><b>fat_size</b> </td>
    <td WIDTH="348">количество секторов, занимаемых одной
    копией <b>FAT</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+16) 1</b></td>
    <td WIDTH="92"><b>reserv1</b> </td>
    <td WIDTH="348">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+17) 2</b></td>
    <td WIDTH="92"><b>root_sec</b> </td>
    <td WIDTH="348">номер первого сектора корневого
    каталога</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+19) 4</b></td>
    <td WIDTH="92"><b>drv_addr</b> </td>
    <td WIDTH="348"><b>FAR</b>-адрес заголовка драйвера,
    обслуживающего данное устройство </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+23) 1</b></td>
    <td WIDTH="92"><b>media</b> </td>
    <td WIDTH="348">байт описания среды носителя данных</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+24) 1</b></td>
    <td WIDTH="92"><b>acc_flag</b> </td>
    <td WIDTH="348">флаг доступа, 0 означает, что к
    устройству был доступ </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+25) 4</b></td>
    <td WIDTH="92"><b>next</b></td>
    <td WIDTH="348">адрес следующего блока <b>DDCB</b>, для
    последнего блока в поле смещения находится число
    <b>FFFF</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+29) 2</b></td>
    <td WIDTH="92"><b>reserv2</b> </td>
    <td WIDTH="348">зарезервироано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+31) 2</b></td>
    <td WIDTH="92"><b>built</b> </td>
    <td WIDTH="348">число <b>FFFF</b> в этом поле означает, что
    блок <b>DDCB</b> был построен </td>
  </tr>
</table>

<h3><a NAME="a7_1_5"><font SIZE="4" COLOR="#008000">7.1.5. Формат таблицы
файлов DFT</font></a></h3>

<p><i><b>для DOS 3.х:</b></i> </p>

<table BORDER="1">
  <tr>
    <td WIDTH="83"><b>(0) 4</b></td>
    <td WIDTH="96"><b>next</b></td>
    <td WIDTH="346">указатель на следущую таблицу файлов</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+4) 2</b></td>
    <td WIDTH="96"><b>file_count</b> </td>
    <td WIDTH="346">количество файлов в этой таблице</td>
  </tr>
  <tr>
    <td WIDTH="83">&nbsp;</td>
    <td WIDTH="96">&nbsp;</td>
    <td WIDTH="346"><i><b>----- Дальше идут блоки DFCB в количестве
    file_count штук -----</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(0) 2</b></td>
    <td WIDTH="96"><b>handl_num</b> </td>
    <td WIDTH="346">количество файловых чисел, связанных с
    данным файлом <b>(file handle)</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+2) 1</b></td>
    <td WIDTH="96"><b>access_mode</b> </td>
    <td WIDTH="346">режим доступа к файлу, заданный при
    открытии файла </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+3) 2</b></td>
    <td WIDTH="96"><b>reserv1</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+5) 2</b></td>
    <td WIDTH="96"><b>dev_info</b> </td>
    <td WIDTH="346">информация <b>IOCTL</b>, полученная для
    устройства, на котором расположен этот файл
    (подробно формат и назначение этого поля будут
    расмотрены в главе, посвященной драйверам) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+7) 4</b></td>
    <td WIDTH="96"><b>driver</b> </td>
    <td WIDTH="346">указатель на драйвер, обслуживающий
    устройство, содержащее файл </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+11) 2</b></td>
    <td WIDTH="96"><b>first_clu</b> </td>
    <td WIDTH="346">номер первого кластера, распределенного
    файлу </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+13) 2</b></td>
    <td WIDTH="96"><b>time</b></td>
    <td WIDTH="346">время последнего изменения файла в
    упакованном формате </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+15) 2</b></td>
    <td WIDTH="96"><b>date</b></td>
    <td WIDTH="346">дата последнего изменения файла в
    упакованном формате </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+17) 4</b></td>
    <td WIDTH="96"><b>fl_size</b> </td>
    <td WIDTH="346">размер файла в байтах</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+21) 4</b></td>
    <td WIDTH="96"><b>offset</b> </td>
    <td WIDTH="346">текущее смещение внутри файла в байтах</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+25) 2</b></td>
    <td WIDTH="96"><b>reserv2</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+27) 2</b></td>
    <td WIDTH="96"><b>last_clu</b> </td>
    <td WIDTH="346">номер только что прочитанного кластера</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+29) 3</b></td>
    <td WIDTH="96"><b>reserv3</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+32) 11</b></td>
    <td WIDTH="96"><b>filename</b> </td>
    <td WIDTH="346">имя файла в формате <b>FCB</b> (имя выравнено
    на левую границу поля, дополнено пробелами до 8
    символов, справа к нему прилегает 3 символа
    расширения без точки) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+43) 2</b></td>
    <td WIDTH="96"><b>reserv4</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+45) 2</b></td>
    <td WIDTH="96"><b>ownr_psp</b> </td>
    <td WIDTH="346"><b>PSP</b> программы, открывшей файл</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+47) 2</b></td>
    <td WIDTH="96"><b>reserv5</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
</table>

<p><i><b>для DOS 4.х:</b></i> </p>

<table BORDER="1">
  <tr>
    <td WIDTH="85"><b>(0) 4</b></td>
    <td WIDTH="114"><b>next</b></td>
    <td WIDTH="346">указатель на следущую таблицу файлов</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+4) 2</b></td>
    <td WIDTH="114"><b>file_count</b> </td>
    <td WIDTH="346">количество файлов в этой таблице</td>
  </tr>
  <tr>
    <td WIDTH="85">&nbsp;</td>
    <td WIDTH="114">&nbsp;</td>
    <td WIDTH="346"><i><b>-------- Дальше идут блоки DFCB в
    количестве file_count штук ------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(0) 2</b></td>
    <td WIDTH="114"><b>handl_num</b> </td>
    <td WIDTH="346">количество файловых чисел, связанных с
    данным файлом <b>(file handle)</b> </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+2) 1</b></td>
    <td WIDTH="114"><b>access_mode</b> </td>
    <td WIDTH="346">режим доступа к файлу, заданный при
    открытии файла </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+3) 2</b></td>
    <td WIDTH="114"><b>reserv1</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+5) 2</b></td>
    <td WIDTH="114"><b>dev_info</b> </td>
    <td WIDTH="346">информация <b>IOCTL</b>, полученная для
    устройства, на котором расположен этот файл
    (подробно формат и назначение этого поля будут
    расмотрены в главе, посвященной драйверам) </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+7) 4</b></td>
    <td WIDTH="114"><b>driver</b> </td>
    <td WIDTH="346">указатель на драйвер, обслуживающий
    устройство, содержащее файл </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+11) 2</b></td>
    <td WIDTH="114"><b>first_clu</b> </td>
    <td WIDTH="346">номер первого кластера, распределенного
    файлу </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+13) 2</b></td>
    <td WIDTH="114"><b>time</b> </td>
    <td WIDTH="346">время последнего изменения файла в
    упакованном формате </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+15) 2</b></td>
    <td WIDTH="114"><b>date</b> </td>
    <td WIDTH="346">дата последнего изменения файла в
    упакованном формате </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+17) 4</b></td>
    <td WIDTH="114"><b>fl_size</b> </td>
    <td WIDTH="346">размер файла в байтах</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+21) 4</b></td>
    <td WIDTH="114"><b>offset</b> </td>
    <td WIDTH="346">текущее смещение внутри файла в байтах</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+25) 2</b></td>
    <td WIDTH="114"><b>reserv2</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+27) 2</b></td>
    <td WIDTH="114"><b>reserv7</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+29) 3</b></td>
    <td WIDTH="114"><b>reserv3</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+32) 1</b></td>
    <td WIDTH="114"><b>reserv4</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+33) 11</b></td>
    <td WIDTH="114"><b>filename</b> </td>
    <td WIDTH="346">имя файла в формате <b>FCB</b> (имя выравнено
    на левую границу поля, дополнено пробелами до 8
    символов, справа к нему прилегает 3 символа
    расширения без точки) </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+44) 2</b></td>
    <td WIDTH="114"><b>reserv5</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+46) 2</b></td>
    <td WIDTH="114"><b>ownr_psp</b> </td>
    <td WIDTH="346"><b>PSP</b> программы, открывшей файл</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+48) 2</b></td>
    <td WIDTH="114"><b>reserv6</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+50) 2</b></td>
    <td WIDTH="114"><b>last_clu</b> </td>
    <td WIDTH="346">номер только что прочитанного кластера</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+52) 4</b></td>
    <td WIDTH="114"><b>reserv8</b> </td>
    <td WIDTH="346">зарезервировано</td>
  </tr>
</table>

<h3><a NAME="a7_1_6"><font SIZE="4" COLOR="#008000">7.1.6. Заголовок
драйвера</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="86"><b>(0) 4</b></td>
    <td WIDTH="113"><b>next</b></td>
    <td WIDTH="347">указатель на заголовок следующего
    драйвера. Если смещение адреса следующего
    драйвера равно <b>FFFF</b>, это последний драйвер в
    цепочке </td>
  </tr>
  <tr>
    <td WIDTH="86"><b>(+4) 2</b></td>
    <td WIDTH="113"><b>attrib</b> </td>
    <td WIDTH="347">атрибуты драйвера</td>
  </tr>
  <tr>
    <td WIDTH="86"><b>(+6) 2</b></td>
    <td WIDTH="113"><b>strateg</b> </td>
    <td WIDTH="347">смещение программы стратегии драйвера</td>
  </tr>
  <tr>
    <td WIDTH="86"><b>(+8) 2</b></td>
    <td WIDTH="113"><b>interrupt</b> </td>
    <td WIDTH="347">смещение программы обработки
    прерывания для драйвера </td>
  </tr>
  <tr>
    <td WIDTH="86"><b>(+10) 8</b></td>
    <td WIDTH="113"><b>dev_name</b> </td>
    <td WIDTH="347">имя устройства для символьных устройств
    или количество обслуживаемых устройств для
    блочных устройств. </td>
  </tr>
</table>

<h3><a NAME="a7_1_7"><font SIZE="4" COLOR="#008000">7.1.7. Формат элемента
массива дисковой информации</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="88"><b>(0) 64</b></td>
    <td WIDTH="94"><b>path</b></td>
    <td WIDTH="354">текущий путь доступа для диска</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+64) 2</b></td>
    <td WIDTH="94"><b>reserv1</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+66) 2</b></td>
    <td WIDTH="94"><b>reserv2</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+68) 1</b></td>
    <td WIDTH="94"><b>reserv3</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+69) 4</b></td>
    <td WIDTH="94"><b>ddcb</b></td>
    <td WIDTH="354">адрес соответствующего <b>DDCB</b></td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+73) 2</b></td>
    <td WIDTH="94"><b>cdir_clu</b> </td>
    <td WIDTH="354">первый кластер текущего каталога на
    диске. <b>0</b> соответствует корневому каталогу,<b> -1</b>
    - если к диску еще не обращались </td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+75) 2</b></td>
    <td WIDTH="94"><b>reserv4</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+77) 2</b></td>
    <td WIDTH="94"><b>reserv5</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+79) 2</b></td>
    <td WIDTH="94"><b>reserv6</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="88">&nbsp;</td>
    <td WIDTH="94">&nbsp;</td>
    <td WIDTH="354"><i><b>---------------- для DOS 4.х -----------------</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="88"><b>(+81) 7</b></td>
    <td WIDTH="94"><b>reserv7</b> </td>
    <td WIDTH="354">зарезервировано</td>
  </tr>
</table>

<h3><a NAME="a7_1_8"><font SIZE="4" COLOR="#008000">7.1.8. Заголовок
EXE-файла</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="83"><b>(0) 2 </b></td>
    <td WIDTH="98"><b>signature</b> </td>
    <td WIDTH="353">два байта <b>'MZ'</b> <b>(4Dh, 5Ah),</b>
    индентифицирующие файл в формате <b>EXE</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+2) 2</b></td>
    <td WIDTH="98"><b>part_pag</b> </td>
    <td WIDTH="353">длина последней страницы программы в
    байтах (страница содержит 512 байт) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+4) 2</b></td>
    <td WIDTH="98"><b>file_size</b> </td>
    <td WIDTH="353">размер программы в страницах по 512 байт</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+6) 2</b></td>
    <td WIDTH="98"><b>rel_item</b> </td>
    <td WIDTH="353">число элементов в таблице расположения
    сегментов </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+8) 2</b></td>
    <td WIDTH="98"><b>hdr_size</b> </td>
    <td WIDTH="353">размер заголовка файла в параграфах
    (длина параграфа - 16 байт) </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+10) 2</b></td>
    <td WIDTH="98"><b>min_mem</b> </td>
    <td WIDTH="353">минимальное количество памяти в
    параграфах, которое нужно зарезервировать в
    памяти за концом загруженной программы </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+12) 2</b></td>
    <td WIDTH="98"><b>max_mem</b> </td>
    <td WIDTH="353">максимальное количество памяти в
    параграфах, которое нужно зарезервировать в
    памяти за концом загруженной программы </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+14) 2</b></td>
    <td WIDTH="98"><b>ss_reg</b> </td>
    <td WIDTH="353">величина смещения от начала программы,
    которая используется для загрузки сегментного
    регистра стека <b>SS</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+16) 2</b></td>
    <td WIDTH="98"><b>sp_reg</b> </td>
    <td WIDTH="353">величина смещения от начала программы,
    которая используется для загрузки регистра <b>SP</b>
    </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+18) 2</b></td>
    <td WIDTH="98"><b>chk_summ</b> </td>
    <td WIDTH="353">контрольная сумма всех слов в файле</td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+20) 2</b></td>
    <td WIDTH="98"><b>ip_reg</b> </td>
    <td WIDTH="353">значение для регистра <b>IP</b>, которое
    будет использовано при начальном запуске
    программы </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+22) 2</b></td>
    <td WIDTH="98"><b>cs_reg</b> </td>
    <td WIDTH="353">смещение от начала программы для
    установки сегментного регистра кода <b>CS</b> </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+24) 2</b></td>
    <td WIDTH="98"><b>relt_off</b> </td>
    <td WIDTH="353">смещение от начала файла таблицы
    расположения сегментов программы </td>
  </tr>
  <tr>
    <td WIDTH="83"><b>(+26) 2</b></td>
    <td WIDTH="98"><b>overlay</b> </td>
    <td WIDTH="353">номер оверлея, равен 0 для основного
    модуля </td>
  </tr>
</table>

<h3><a NAME="a7_1_9"><font SIZE="4" COLOR="#008000">7.1.9. Атрибуты
драйвера</font></a></h3>

<p><i><b>Символьное устройство</b></i> </p>

<table BORDER="1">
  <tr>
    <td WIDTH="57"><i><b>Бит</b></i></td>
    <td WIDTH="415"><i><b>Назначение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>0</b></td>
    <td WIDTH="415"><b>1</b> - драйвер обслуживает стандартное
    устройство ввода; <br>
    <b>0</b> - этот драйвер не обслуживает стандартное
    устройство ввода </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>1</b></td>
    <td WIDTH="415"><b>1</b> - драйвер обслуживает стандартное
    устройство вывода;<br>
    <b>0</b> - драйвер не обслуживает стандартное
    устройство вывода </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>2</b></td>
    <td WIDTH="415"><b>1</b> - это драйвер стандартного
    устройства <b>NUL</b>;<br>
    <b>0</b> - драйвер не обслуживает устройство <b>NUL</b> </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>3</b></td>
    <td WIDTH="415"><b>1</b> - драйвер обслуживает часы </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>4</b></td>
    <td WIDTH="415">Зарезервировано, бит должен быть равен 0 </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>5</b></td>
    <td WIDTH="415">Зарезервировано, бит должен быть равен 0 </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>6</b></td>
    <td WIDTH="415"><b>1</b> - разрешено использование
    драйвером функций <b>GENERIC IOCTL</b> (для версий DOS,
    более поздних, чем 3.2); <br>
    <b>0</b> - функции <b>GENERIC IOCTL</b> не поддерживаются </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>7-10</b></td>
    <td WIDTH="415">Эти биты зарезервированы и должны быть
    равны 0 </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>11</b></td>
    <td WIDTH="415"><b>1</b> - поддерживаются функции
    открытия/закрытия устройства <b>(OPEN/CLOSE)</b> для
    символьных устройств; <br>
    <b>0</b> - функции <b>OPEN/CLOSE</b> для символьных устройств
    не поддерживаются </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>12</b></td>
    <td WIDTH="415">Зарезервировано, бит должен быть равен 0 </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>13</b></td>
    <td WIDTH="415"><b>1</b> - для символьных устройств
    поддерживается функция вывода до получения
    состояния занятости устройства; <br>
    <b>0</b> - функция вывода до состояния занятости не
    поддерживается </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>14</b></td>
    <td WIDTH="415"><b>1</b> - поддерживаются функции <b>IOCTL</b>; <br>
    <b>0</b> - функции <b>IOCTL</b> не поддерживаются </td>
  </tr>
  <tr>
    <td WIDTH="57"><b>15</b></td>
    <td WIDTH="415"><b>1</b> - символьное устройство; <br>
    <b>0</b> - блочное устройство </td>
  </tr>
</table>

<p><i><b>Блочное устройство</b></i> </p>

<table BORDER="1">
  <tr>
    <td WIDTH="70"><i><b>Бит</b></i></td>
    <td WIDTH="454"><i><b>Назначение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>0</b></td>
    <td WIDTH="454">Зарезервировано, бит должен быть равен 0 </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>1</b></td>
    <td WIDTH="454"><b>1</b> - драйвер поддерживает 32-битовую
    адресацию сектора (для версий DOS, начиная с 4.00 и
    более поздних); если установлен этот бит, поле
    номера сектора всех запросов является двойным
    словом, добавляемым в конец заголовка запроса,
    старое поле номера сектора должно содержать -1); <br>
    <b>0</b> - используется 16-битовая адресация сектора </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>2-5</b></td>
    <td WIDTH="454">Эти биты зарезервированы и должны быть
    равны 0 </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>6</b></td>
    <td WIDTH="454"><b>1</b> - поддерживаются логические
    устройства (используется блочными драйверами
    для управления &quot;виртуальными&quot;
    флоппи-дисками, создаваемые драйвером <b>DRIVER.SYS</b>
    в DOS версии 3.2 и более поздних версиях); <br>
    <b>0</b> - логические устройства для блочных
    драйверов не поддерживаются; </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>7-10</b></td>
    <td WIDTH="454">Эти биты зарезервированы и должны быть
    равны 0 </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>11</b></td>
    <td WIDTH="454"><b>1</b> - единица в этом бите означает, что
    драйвер поддерживает функцию проверки замены
    носителя данных в устройстве (например, замены
    дискеты), используется для DOS версий 3.00 и более
    поздних; <br>
    <b>0</b> - для блочных устройств функция проверки
    замены носителя данных не поддерживается </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>12</b></td>
    <td WIDTH="454">Зарезервировано, бит должен быть равен 0 </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>13</b></td>
    <td WIDTH="454"><b>1</b> - драйвер не использует стандартное
    IBM-устройство, и необходимо выдать запрос на
    построение блока параметров <u><b>BIOS</b></u><font SIZE="1">BIOS</font><b>
    BPB</b>; <br>
    <b>0</b> - используется IBM-устройство </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>14</b></td>
    <td WIDTH="454"><b>1</b> - поддерживаются функции <b>IOCTL</b>; <br>
    <b>0</b> - функции <b>IOCTL</b> не поддерживаются </td>
  </tr>
  <tr>
    <td WIDTH="70"><b>15</b></td>
    <td WIDTH="454"><b>1</b> - символьное устройство; <br>
    <b>0</b> - блочное устройство </td>
  </tr>
</table>

<h3><a NAME="a7_1_10"><font SIZE="4" COLOR="#008000">7.1.10. Заголовок
запроса</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="78"><b>(0) 1</b></td>
    <td WIDTH="97"><b>size</b></td>
    <td WIDTH="339">Длина запроса в байтах (длина заголовка
    запроса плюс длина переменной части запроса) </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+1) 1</b></td>
    <td WIDTH="97"><b>unit</b></td>
    <td WIDTH="339">Номер устройства (используется для
    блочных устройств, указывает, с каким именно
    устройством, обслуживаемым драйвером, будет
    работать операционная система) </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+2) 1</b></td>
    <td WIDTH="97"><b>cmd</b></td>
    <td WIDTH="339">Код команды, которую требуется
    выполнить (может иметь значение от <b>0</b> до <b>18h</b>) </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+3) 2</b></td>
    <td WIDTH="97"><b>status</b> </td>
    <td WIDTH="339">Слово состояния устройства, заполняется
    драйвером перед возвратом управления
    операционной системе </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+5) 8</b></td>
    <td WIDTH="97"><b>reserved</b> </td>
    <td WIDTH="339">Зарезервировано</td>
  </tr>
</table>

<h3><a NAME="a7_1_11"><font SIZE="4" COLOR="#008000">7.1.11. Слово состояния
устройства</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="78"><i><b>Бит</b></i></td>
    <td WIDTH="447"><i><b>Назначение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>0-7</b></td>
    <td WIDTH="447">Код ошибки устройства (если команда
    выполнилась с ошибкой и драйвер установил
    признак ошибки (бит <b>15</b>) в единицу, то в это поле
    он должен записать код ошибки). </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>8</b></td>
    <td WIDTH="447">Команда выполнена. Этот бит всегда
    устанавливается драйвером перед тем, как он
    возвращает управление операционной системе. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>9</b></td>
    <td WIDTH="447">Занято. Этот бит устанавливается
    обработчиком команды, когда физическое
    устройство занято выполнением предыдущей
    операции и поэтому не может выполнить требуемую
    команду. Этот бит используется также для
    передачи такой информации, как &quot;буфер
    клавиатуры не пуст&quot;, &quot;среда носителя данных
    заменяемая&quot; (в команде проверки возможности
    замены среды носителя данных). </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>10-14</b></td>
    <td WIDTH="447">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>15</b></td>
    <td WIDTH="447">Признак ошибки. Устанавливается
    драйвером, когда он не может обработать запрос
    или произошла физическая либо логическая ошибка
    при обработке правильного запроса. Биты <b>0-7</b>
    при этом должны содержать код ошибки. </td>
  </tr>
</table>

<h3><a NAME="a7_1_12"><font SIZE="4" COLOR="#008000">7.1.12. Коды ошибок</font><font
SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="61"><i><b>Код</b></i></td>
    <td WIDTH="418"><i><b>Описание</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0</b></td>
    <td WIDTH="418">Нарушение защиты от записи. Была
    предпринята попытка записи информации на
    защищенное от записи устройство. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>1</b></td>
    <td WIDTH="418">Неизвестное устройство. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>2</b></td>
    <td WIDTH="418">Устройство не готово. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>3</b></td>
    <td WIDTH="418">Неизвестная команда. Затребованная
    команда не поддерживается драйвером. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>4</b></td>
    <td WIDTH="418">Ошибка <b>CRC</b>. При выполнении команды
    обнаружена ошибка циклического кода проверки. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>5</b></td>
    <td WIDTH="418">Неправильная длина запроса. Поле длины в
    заголовке запроса содержит неверное значение. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>6</b></td>
    <td WIDTH="418">Ошибка при поиске дорожки (дорожка не
    найдена). </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>7</b></td>
    <td WIDTH="418">Неизвестный носитель данных. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>8</b></td>
    <td WIDTH="418">Сектор не найден. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>9</b></td>
    <td WIDTH="418">Нет бумаги в принтере. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Ah</b></td>
    <td WIDTH="418">Ошибка записи.</td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Bh</b></td>
    <td WIDTH="418">Ошибка чтения.</td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Ch</b></td>
    <td WIDTH="418">Общая ошибка.</td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Dh</b></td>
    <td WIDTH="418">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Eh</b></td>
    <td WIDTH="418">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="61"><b>0Fh</b></td>
    <td WIDTH="418">Неразрешенная замена диска (только для
    DOS версии 3.0 и более поздних версий). </td>
  </tr>
</table>

<h3><a NAME="a7_1_13"><font SIZE="4" COLOR="#008000">7.1.13. Блок BPB</font><font
SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="75"><b>(0) 2</b></td>
    <td WIDTH="85"><b>sect_siz</b> </td>
    <td WIDTH="341">Количество байтов в одном секторе диска.</td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+2) 1</b></td>
    <td WIDTH="85"><b>clustsiz</b> </td>
    <td WIDTH="341">Количество секторов в одном кластере.</td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+3) 2</b></td>
    <td WIDTH="85"><b>res_sect</b> </td>
    <td WIDTH="341">Количество зарезервированных секторов.</td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+5) 1</b></td>
    <td WIDTH="85"><b>fat_cnt</b> </td>
    <td WIDTH="341">Количество таблиц <b>FAT</b>.</td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+6) 2</b></td>
    <td WIDTH="85"><b>root_siz</b> </td>
    <td WIDTH="341">Максимальное количество файловых
    дескрипторов, содержащихся в корневом каталоге
    диска. </td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+8) 2</b></td>
    <td WIDTH="85"><b>tot_sect</b> </td>
    <td WIDTH="341">Общее количество секторов на носителе
    данных (в разделе DOS). </td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+10) 1</b></td>
    <td WIDTH="85"><b>media</b> </td>
    <td WIDTH="341">Байт-описатель среды носителя данных.</td>
  </tr>
  <tr>
    <td WIDTH="75"><b>(+11) 2</b></td>
    <td WIDTH="85"><b>fat_size</b> </td>
    <td WIDTH="341">Количество секторов, занимаемых одной
    копией <b>FAT</b>. </td>
  </tr>
</table>

<h3><a NAME="a7_1_14"><font SIZE="4" COLOR="#008000">7.1.14. Форматы
запросов для различных команд</font></a></h3>

<ul>
  <li>0 - Инициализация </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="78"><b>(0) 13</b></td>
    <td WIDTH="85"><b>header</b> </td>
    <td WIDTH="342">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+13) 1</b></td>
    <td WIDTH="85"><b>n_units</b> </td>
    <td WIDTH="342">Количество устройств, обслуживаемых
    драйвером. Это поле заполняется только блочным
    драйвером. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+14) 4</b></td>
    <td WIDTH="85"><b>end_addr</b> </td>
    <td WIDTH="342">Конечный <b>FAR</b>-адрес резидентной части
    кода драйвера. В это поле драйвер записывает
    адрес байта памяти, следующего за той частью кода
    драйвера, которая должна стать резидентной. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+18) 4</b></td>
    <td WIDTH="85"><b>parm</b></td>
    <td WIDTH="342"><b>FAR</b>-адрес строки параметров
    инициализации драйвера из файла <b>CONFIG.SYS</b>. Эта
    строка содержит все, что находится в строке файла
    после команды <b>'DEVICE='</b>, она заканчивается
    символами перевода строки и возврата каретки <b>0Ah,
    0Dh</b>. При возврате драйвер блочного устройства
    должен записать в это поле адрес массива
    указателей на блоки параметров <u><b>BIOS</b></u><font SIZE="1">BIOS</font>
    <b>(BPB)</b>, по одному указателю на каждое устройство,
    обслуживаемое драйвером. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+22) 1</b></td>
    <td WIDTH="85"><b>drive</b> </td>
    <td WIDTH="342">Номер устройства. Для версии DOS 3.0 и более
    поздних версий в это поле при загрузке драйвера
    операционная система заносит номер, назначенный
    устройству, обслуживаемому драйвером. Например,
    для устройства<b> А:</b>это 0, для <b>B:</b> - 1 и т.д. </td>
  </tr>
</table>

<ul>
  <li>1 - Проверка замены носителя </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="77"><b>(0) 13</b></td>
    <td WIDTH="87"><b>header</b> </td>
    <td WIDTH="341">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+13) 1</b></td>
    <td WIDTH="87"><b>media</b> </td>
    <td WIDTH="341">В этом поле драйверу передается
    байт-описатель среды носителя данных, с которым
    DOS работала раньше. </td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+14) 1</b></td>
    <td WIDTH="87"><b>reply</b> </td>
    <td WIDTH="341">В это поле драйвер должен поместить
    ответ о факте замены среды: <br>
    <b>1</b> - диск не заменялся; <br>
    <b>0</b> - неизвестно;<br>
    <b>-1</b> - диск был заменен. </td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+15) 4</b></td>
    <td WIDTH="87"><b>vol_id</b> </td>
    <td WIDTH="341">Указатель на предыдущую метку тома (если
    установлен бит 11 слова атрибута устройства и
    диск был заменен) </td>
  </tr>
</table>

<ul>
  <li>2 - Построить блок BPB. </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="77"><b>(0) 13</b></td>
    <td WIDTH="87"><b>header</b> </td>
    <td WIDTH="343">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+13) 1</b></td>
    <td WIDTH="87"><b>media</b> </td>
    <td WIDTH="343">В этом поле драйверу передается
    байт-описатель среды носителя данных, с которым
    DOS работала раньше. </td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+14) 4</b></td>
    <td WIDTH="87"><b>buf_adr</b> </td>
    <td WIDTH="343">Адрес буфера обмена. Содержимое этого
    буфера при вызове драйвера зависит от утановки
    бита <b>13</b> слова атрибутов устройства (IBM-формат).
    Если этот бит равен <b>0</b> (устройство формата IBM),
    буфер содержит первый сектор первой копии <b>FAT</b>.
    В противном случае указатель установлен на буфер
    свободного сектора. </td>
  </tr>
  <tr>
    <td WIDTH="77"><b>(+18) 4</b></td>
    <td WIDTH="87"><b>bpb_adr</b> </td>
    <td WIDTH="343">Указатель на новый <b>BPB</b>, записывается в
    это поле драйвером. </td>
  </tr>
</table>

<ul>
  <li>3, 4, 8, 9, 0Ch - Чтение/Запись. </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="78"><b>(0) 13</b></td>
    <td WIDTH="87"><b>header</b> </td>
    <td WIDTH="338">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+13) 1</b></td>
    <td WIDTH="87"><b>media</b> </td>
    <td WIDTH="338">В этом поле драйверу передается
    байт-описатель среды носителя данных. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+14) 4</b></td>
    <td WIDTH="87"><b>buf_adr</b> </td>
    <td WIDTH="338">Адрес буфера для передачи данных.</td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+18) 2</b></td>
    <td WIDTH="87"><b>count</b> </td>
    <td WIDTH="338">Количество передаваемых байтов для
    символьных устройств или секторов для блочных
    устройств. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+20) 2</b></td>
    <td WIDTH="87"><b>sector</b> </td>
    <td WIDTH="338">Номер начального сектора, если драйвер
    использует 16-битовую адресацию секторов или <b>-1</b>
    для 32-битовой адресации. Это поле не используется
    символьными драйверами. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+22) 4</b></td>
    <td WIDTH="87"><b>vol_id</b> </td>
    <td WIDTH="338">Указатель на метку тома в формате ASCIIZ.
    Возвращается блочным драйвером, если он
    выставляет ошибку <b>15</b> (неправильная смена
    диска). Это поле должно содержать ссылку на метку
    требуемого диска. </td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+26) 4</b></td>
    <td WIDTH="87"><b>sect32</b> </td>
    <td WIDTH="338">Номер начального сектора, если
    содержимое поля sector равно <b>-1</b>. Первым идет
    старшее слово номера сектора. Если обнаружена
    ошибка с номером <b>15</b>, в это поле записывается
    указатель на метку тома. </td>
  </tr>
</table>

<ul>
  <li>5 - Неразрушающий ввод. </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="78"><b>(0) 13</b></td>
    <td WIDTH="89"><b>header</b> </td>
    <td WIDTH="341">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="78"><b>(+13) 1</b></td>
    <td WIDTH="89"><b>byte</b></td>
    <td WIDTH="341">В это поле драйвер записывает
    извлеченный из буфера байт, который будет считан
    по следующей команде ввода. </td>
  </tr>
</table>

<ul>
  <li>6, 0Ah - Проверит состояние ввода/вывода. </li>
</ul>

<p>Для команд проверки состояния запрос состоит
только из заголовка, область переменного формата
отсутствует. 

<ul>
  <li>7 - Сброс буфера устройства ввода. </li>
  <li>11 - Сброс буфера устройства вывода. </li>
</ul>

<p>Запрос состоит только из заголовка. 

<ul>
  <li>0Dh, 0Eh - Открыть/Закрыть устройство. </li>
</ul>

<p>Запрос для этих команд состоит только из
заголовка. 

<ul>
  <li>15 - Проверка сменяемости диска. </li>
</ul>

<p>Запрос состоит только из заголовка. 

<ul>
  <li>19 - Общее управление вводом/выводом (GENERIC_IOCTL). </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="85"><b>(0) 13</b></td>
    <td WIDTH="95"><b>header</b> </td>
    <td WIDTH="318">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+13) 1</b></td>
    <td WIDTH="95"><b>funct</b> </td>
    <td WIDTH="318">Это поле содержит код функции команды
    общего <b>IOCTL</b>. </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+14) 1</b></td>
    <td WIDTH="95"><b>subfunc</b> </td>
    <td WIDTH="318">Код подфункции для функции <b>funct</b>.</td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+15) 2</b></td>
    <td WIDTH="95"><b>si_reg</b> </td>
    <td WIDTH="318">Значение регистра <b>SI</b> при вызове
    функции <b>44h</b> прерывания <b>21h</b>. Эта функция DOS
    предназначена для управления вводом/выводом. </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+17) 2</b></td>
    <td WIDTH="95"><b>di_reg</b> </td>
    <td WIDTH="318">Значение, передаваемое при вызове
    функции <b>44h</b> прерывания <b>21h</b> через регистр <b>DI</b>.
    </td>
  </tr>
  <tr>
    <td WIDTH="85"><b>(+19) 4</b></td>
    <td WIDTH="95"><b>buf</b></td>
    <td WIDTH="318">Указатель на буфер данных, содержащий
    управляющую информацию для устройства или
    предназначенный для приема информации от
    устройства. </td>
  </tr>
</table>

<ul>
  <li>23 - Получить активное логическое устройство. </li>
  <li>24 - Установить активное логическое устройство. </li>
</ul>

<table BORDER="1">
  <tr>
    <td WIDTH="87"><b>(0) 13</b></td>
    <td WIDTH="93"><b>header</b> </td>
    <td WIDTH="318">Заголовок запроса.</td>
  </tr>
  <tr>
    <td WIDTH="87"><b>(+13) 1</b></td>
    <td WIDTH="93"><b>unit</b></td>
    <td WIDTH="318">Код логического устройства, которое
    должно стать активным при использовании команды <b>24</b>,
    или код активного устройства, помещаемый
    драйвером по команде <b>23</b>. </td>
  </tr>
  <tr>
    <td WIDTH="87"><b>(+14) 1</b></td>
    <td WIDTH="93"><b>cmd</b></td>
    <td WIDTH="318">Код команды.</td>
  </tr>
  <tr>
    <td WIDTH="87"><b>(+15) 4</b></td>
    <td WIDTH="93"><b>status</b> </td>
    <td WIDTH="318">Слово состояния.</td>
  </tr>
  <tr>
    <td WIDTH="87"><b>(+19) 4</b></td>
    <td WIDTH="93"><b>reserved</b> </td>
    <td WIDTH="318">Зарезервировано.</td>
  </tr>
</table>

<h3><a NAME="a7_1_15"><font SIZE="4" COLOR="#008000">7.1.15. Команды
драйвера</font><font SIZE="4"> </font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><b>0 </b></td>
    <td WIDTH="285">Инициализация</td>
  </tr>
  <tr>
    <td WIDTH="48"><b>1 </b></td>
    <td WIDTH="285">Проверка смены носителя данных </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>2 </b></td>
    <td WIDTH="285">Построить блок BPB </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>3 </b></td>
    <td WIDTH="285">Чтение IOCTL</td>
  </tr>
  <tr>
    <td WIDTH="48"><b>4 </b></td>
    <td WIDTH="285">Чтение</td>
  </tr>
  <tr>
    <td WIDTH="48"><b>5 </b></td>
    <td WIDTH="285">Неразрушающее чтение </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>6 </b></td>
    <td WIDTH="285">Проверка состояния ввода </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>7 </b></td>
    <td WIDTH="285">Сброс буферов ввода </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>8 </b></td>
    <td WIDTH="285">Запись</td>
  </tr>
  <tr>
    <td WIDTH="48"><b>9 </b></td>
    <td WIDTH="285">Запись с проверкой </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>10 </b></td>
    <td WIDTH="285">Проверка состояния вывода </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>11 </b></td>
    <td WIDTH="285">Сброс буферов вывода </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>12 </b></td>
    <td WIDTH="285">Запись IOCTL</td>
  </tr>
  <tr>
    <td WIDTH="48"><b>13 </b></td>
    <td WIDTH="285">Открыть устройство </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>14 </b></td>
    <td WIDTH="285">Закрыть устройство </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>15 </b></td>
    <td WIDTH="285">Проверка возможности смены носителя
    данных </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>16 </b></td>
    <td WIDTH="285">Зарезервировано </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>17 </b></td>
    <td WIDTH="285">Зарезервировано </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>18 </b></td>
    <td WIDTH="285">Зарезервировано </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>19 </b></td>
    <td WIDTH="285">Общее управление вводом/выводом <b>(GENERIC
    IOCTL)</b> </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>20 </b></td>
    <td WIDTH="285">Получить текущее логическое устройство </td>
  </tr>
  <tr>
    <td WIDTH="48"><b>21 </b></td>
    <td WIDTH="285">Установить логическое устройство </td>
  </tr>
</table>

<h3><a NAME="a7_1_16"><font SIZE="4" COLOR="#008000">7.1.16. Коды
идентификации типа компьютера</font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="83">FF</td>
    <td WIDTH="406">оригинальный IBM PC</td>
  </tr>
  <tr>
    <td WIDTH="83">FE</td>
    <td WIDTH="406">XT, Portable PC</td>
  </tr>
  <tr>
    <td WIDTH="83">FD</td>
    <td WIDTH="406">PCjr</td>
  </tr>
  <tr>
    <td WIDTH="83">FC</td>
    <td WIDTH="406">AT</td>
  </tr>
  <tr>
    <td WIDTH="83">FB</td>
    <td WIDTH="406">XT с памятью 640 К на материнской плате </td>
  </tr>
  <tr>
    <td WIDTH="83">F9</td>
    <td WIDTH="406">Convertible PC</td>
  </tr>
</table>

<h3><a NAME="a7_1_17"><font SIZE="4" COLOR="#008000">7.1.17. Таблица
параметров для жестких дисков</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­
¦Тип ¦ Количество  ¦ Количество  ¦ Емкость диска  
¦    ¦ цилиндров   ¦ головок     ¦ в байтах       
+­­­­+­­­­­­­­­­­­­+­­­­­­­­­­­­­+­­­­­­­­­­­­­­­­
¦ 1  ¦ 306         ¦ 4           ¦ 10.653.696 
¦ 2  ¦ 615         ¦ 4           ¦ 21.411.840 
¦ 3  ¦ 615         ¦ 6           ¦ 32.117.760 
¦ 4  ¦ 940         ¦ 8           ¦ 65.454.080 
¦ 5  ¦ 940         ¦ 6           ¦ 49.090.560 
¦ 6  ¦ 615         ¦ 4           ¦ 21.411.840 
¦ 7  ¦ 462         ¦ 8           ¦ 32.169.984 
¦ 8  ¦ 733         ¦ 5           ¦ 31.900.160 
¦ 9  ¦ 900         ¦ 15          ¦ 117.504.000 
¦ 10 ¦ 820         ¦ 3           ¦ 21.411.840 
¦ 11 ¦ 855         ¦ 5           ¦ 37.209.600 
¦ 12 ¦ 855         ¦ 7           ¦ 52.093.440 
¦ 13 ¦ 306         ¦ 8           ¦ 21.307.392 
¦ 14 ¦ 733         ¦ 7           ¦ 44.660.224 
¦ 15 ¦ 0           ¦ 0           ¦ 0 
¦ 16 ¦ 612         ¦ 4           ¦ 21.307.392 
¦ 17 ¦ 977         ¦ 5           ¦ 42.519.040 
¦ 18 ¦ 977         ¦ 7           ¦ 59.526.656 
¦ 19 ¦ 1024        ¦ 7           ¦ 62.390.272 
¦ 20 ¦ 733         ¦ 5           ¦ 31.900.160 
¦ 21 ¦ 733         ¦ 7           ¦ 44.660.224 
¦ 22 ¦ 733         ¦ 5           ¦ 31.900.160 
¦ 23 ¦ 306         ¦ 4           ¦ 10.653.696 
¦ 24 ¦ 977         ¦ 5           ¦ 42.519.040 
¦ 25 ¦ 1024        ¦ 9           ¦ 80.216.064 
¦ 26 ¦ 1224        ¦ 7           ¦ 74.575.872 
¦ 27 ¦ 1224        ¦ 11          ¦ 117.190.656
¦ 28 ¦ 1224        ¦ 15          ¦ 159.805.440
¦ 29 ¦ 1024        ¦ 8           ¦ 71.303.168 
¦ 30 ¦ 1024        ¦ 11          ¦ 98.041.856 
¦ 31 ¦ 918         ¦ 11          ¦ 87.892.992 
¦ 32 ¦ 925         ¦ 9           ¦ 72.460.800 
¦ 33 ¦ 1024        ¦ 10          ¦ 89.128.960 
¦ 34 ¦ 1024        ¦ 12          ¦ 106.954.752
¦ 35 ¦ 1024        ¦ 13          ¦ 115.867.648
¦ 36 ¦ 1024        ¦ 14          ¦ 124.780.544
¦ 37 ¦ 1024        ¦ 2           ¦ 17.825.792 
¦ 38 ¦ 1024        ¦ 16          ¦ 142.606.336
¦ 39 ¦ 918         ¦ 15          ¦ 119.854.080
¦ 40 ¦ 820         ¦ 6           ¦ 42.823.680 
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­---- 

</font>
</pre>

<h3><a NAME="a7_1_18"><font SIZE="4" COLOR="#008000">7.1.18. Параметры
флоппи-дисков</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦Тип¦Емкость,¦Диаметр,¦Количество секторов¦Количество¦
¦   ¦Кбайтов ¦дюймы   ¦на одну дорожку    ¦цилиндров ¦
+­­­+­­­­­­­­+­­­­­­­­+­­­­­­­­­­­­­­­­­­­+­­­­­­­­­­¦
¦ 1 ¦ 360    ¦  5     ¦        9          ¦     40   ¦
¦ 2 ¦ 1200   ¦  5     ¦        15         ¦     80   ¦
¦ 3 ¦ 720    ¦  3     ¦        9          ¦     40   ¦
¦ 4 ¦ 1440   ¦  3     ¦        18         ¦     80   ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

</font>
</pre>

<h3><a NAME="a7_1_19"><font SIZE="4" COLOR="#008000">7.1.19. Таблица
параметров дискеты</font></a></h3>

<ol>
  <li><font COLOR="#000080">1 srt_hut </font></li>
</ol>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Биты 0...3 - SRT (Step Rate Time) - задержка для переключения головок, лежит в пределах 1-16 мс и задается с интервалом 1 мс (0Fh - 1mc, 0Eh - 2 mc, 0Dh - 3 mc, ...);
биты 4...7 - задержки разгрузки головки, лежит в пределах 16-240 мс и задается с интервалом 16 мс (1 - 16 mc, 2 - 32 mc, ..., 0Fh - 240 mc).

(+1)     1      dma_hlt
Бит 0 - значение этого бита, равное 1, говорит о том, что используется прямой доступ к памяти (DMA);
биты 2...7 - время загрузки головок HLT_- интервал между сигналом загрузки головок и началом операции чтение/запись, лежит в пределах 2-254 мс и задается с интервалом 2 мс (1 - 2 mc, 2 - 4 mc, ..., 0FFh - 254 mc).

(+2)     1      motor_w
Задержка перед выключением двигателя.

(+3)     1      sec_size
Код размера сектора в байтах (0 - 128 байтов, 1 - 256, 2 - 512, 3 - 1024).

(+4)     1      eot
Номер последнего сектора на дорожке

(+5)     1      gap_rw
Длина межсекторного промежутка для чтения/записи.

(+6)     1      dtl
Максимальная длина передаваемых данных, используется когда не задана длина сектора.

(+7)     1      gap_f
Длина межсекторного промежутка для опрации форматирования.

(+8)     1      fill_char
Байт-заполнитель для форматирования (обычно используется F6h).

(+9)     1      hst
Время установки головки в миллисекундах.

(+10) 1 mot_start
Время запуска двигателя в 1/8 долях секунды.

</font>
</pre>

<h3><a NAME="a7_1_20"><font SIZE="4" COLOR="#008000">7.1.20. Таблица
параметров жесткого диска</font></a></h3>

<ol>
  <li><font COLOR="#000080">2 max_cyl</font> </li>
</ol>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Максимальное количество цилиндров на диске.

(+2)     1      max_head        
Максимальное количество магнитных головок.

(+3)     2      srwcc   
Начальный цилиндр для предварительной записи (Starting reduced-write current cylinder).

(+5)     2      swpc            
Начальный цилиндр для предварительной компенсации при записи (Starting write precompensation cylinder).

(+7)     1      max_ecc 
Максимальная длина блока коррекции ошибок ECC (Maximum ECC data burst length).

(+8)     1      dstopt  
Опции устройства:
бит 7 - запрет восстановления;
бит 6 - запрет восстановления по блоку коррекции ошибок ECC (Error Correction Code);
биты 2-0 - опции устройства.

(+9)     1      st_del  
Стандартная величина задержки.

(+10) 1 fm_del  
Величина задержки для форматирования диска.

(+11) 1 chk_del 
Величина задержки для проверки диска.

(+12) 4 reserve 
Зарезервировано.

</font>
</pre>

<h3><a NAME="a7_1_21"><font SIZE="4" COLOR="#008000">7.1.21. Команды
контроллера НГМД</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Команда Байты команды

Чтение  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
данных  ¦MT ¦MFM¦SK ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦
        +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
        ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
        +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение удаленных    +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
данных              ¦MT ¦MFM¦SK ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦ 0 ¦
                    +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                    ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                    +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Запись  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
данных  ¦MT ¦MFM¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦
        +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
        ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
        +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Запись удаленных  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
данных            ¦MT ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦ 1 ¦
                  +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                  ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение данных     +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
с дорожки         ¦MT ¦MFM¦SK ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦
                  +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                  ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
&quot;равно&quot;          ¦MT ¦MFM¦SK ¦ 1 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦
                 +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
&quot;меньше&quot; или     ¦MT ¦MFM¦SK ¦ 1 ¦ 1 ¦ 0 ¦ 0 ¦ 1 ¦
&quot;равно&quot;          +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до  +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
&quot;больше&quot; или     ¦MT ¦MFM¦SK ¦ 1 ¦ 1 ¦ 1 ¦ 0 ¦ 1 ¦
&quot;равно&quot;          +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Форматирование   +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
дорожки          ¦ 0 ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦ 1 ¦
                 +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Считывание       +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
индексных        ¦ 0 ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 1 ¦ 1 ¦
данных           +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Инициализация    +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 1 ¦
                 +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение состояния +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
прерывания       ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦ 0 ¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Определить       +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
параметры        ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение           +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
состояния        ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦
накопителя       +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Поиск            +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 1 ¦ 1 ¦
                 +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                 +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+


</font>
</pre>

<p>Байты параметров, которые должны следовать за
командами и байты результата, которые процессор
должен считать после выполнения команды: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Команда               Байты                Байты
                      параметров           результата
Чтение данных         C, H, R, N, EOT,     ST0, ST1, ST2,
                      EOT, GPL, DTL        C, H, R, N
Чтение удаленных
данных

Запись данных

Запись удаленных
данных

Чтение данных
с дорожки

Сканирование до
&quot;равно&quot;

Сканирование до
&quot;меньше&quot; или
&quot;равно&quot;

Сканирование до
&quot;больше&quot; или
&quot;равно&quot;
­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­

Форматирование        N, SC, GPL, D        ST0, ST1, ST2,
дорожки               C, H, R, N


Чтение индексных      отсутствуют          ST0, ST1, ST2,
данных                C, H, R, N


Инициализация         отсутствуют          отсутствуют


Чтение состояния      отсутствуют          ST0, PCN
прерывания


Определить            1 байт:              отсутствуют
параметры              мл. тетрада - HUT
                       ст. тетрада - SRT
                      2 байт:
                       бит 0       - ND
                       биты 1-7    - HLT


Чтение состояния      отсутствуют          ST3
накопителя


Поиск                 C                    отсутствуют

</font>
</pre>

<h3><a NAME="a7_1_22"><font SIZE="4" COLOR="#008000">7.1.22. Регистры
состояния контроллера</font></a></h3>

<p>Формат регистра ST0: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Биты    Название        Назначение
1, 0    US1, US2        Эти биты содержат код накопителя при
                        прерывании.

2       HD              Номер головки.

3       NC              Накопитель не готов, устанавливается,
                        если накопитель не готов выполнить
                        команду чтения или записи.

4       EC              Сбой оборудования

5       SE              Завершена команда &quot;Поиск&quot;

7, 6    I, C            Код прерывания:
                          00 - нормальное завершение;
                          01 - аварийное завершение;
                          10 - некорректная команда
                          11 - нет готовности дисковода.
</font>
</pre>

<p>Формат регистра ST1:<br>
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Биты    Название        Назначение
0       MA              Пропуск адресной метки. Этот бит
                        устанавливается в 1, если контроллер
                        не может найти адресную метку

1       NN              Защита записи, устанавливается , если
                        при выполнении операции контроллер
                        получает от дисковода сигнал защиты
                        записи.

2       ND              Не найден сектор.
 
3       -               Зарезервирован

4       OR              Переполнение, процессор не успевает
                        выполнять обмен данными с контроллером

5       DE              Ошибка в данных при проверке
                        контрольной суммы

6       -               Зарезервирован.

7       EN              Несуществующий сектор, устанавливается,
                        когда контроллер пытается прочесть
                        сектор с адресом, большим
                        существующего.
</font>
</pre>

<p>Формат регистра ST2:<br>
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Биты    Название        Назначение
0       MD              Пропущен адресный маркер в поле данных.

1       BC              Нечитающаяся дорожка.

2       SN              Ошибка сканирования. Устанавливается,
                        если при выполнении команды
                        сканирования контроллер не может
                        найти требуемую дорожку.

3       SH              Сканирование выполнено, дорожка
                        найдена.

4       WC              Ошибка адреса дорожки.

5       DD              Ошибка в поле данных.

6       CM              Во время операции чтения или 
                        сканирования не обнаружен сектор с
                        с маркером удаленных данных.

7       -               Зарезервирован.

</font>
</pre>

<p>Формат регистра ST3: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Биты    Название        Назначение
1, 0    US1, US2        Код выбранного дисковода.

2       HD              Номер выбранной головки.

3       TS              Используется режим двухсторонней
                        записи.

4       T0              Головка установлена на дорожку 0.

5       RDY             Дисковод готов к работе.

6       WP              Защита записи на диске.

7       FT              Неисправность дисковода.

</font>
</pre>

<p>В форматах команд и таблицах используются
следующие обозначения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="140">MT </td>
    <td WIDTH="451">двухсторонняя операция </td>
  </tr>
  <tr>
    <td WIDTH="140">MFM </td>
    <td WIDTH="451">двойная/одинарная плотность записи </td>
  </tr>
  <tr>
    <td WIDTH="140">SK </td>
    <td WIDTH="451">пропуск удаленных данных </td>
  </tr>
  <tr>
    <td WIDTH="140">HDS </td>
    <td WIDTH="451">номер головки для двухстороннего
    накопителя </td>
  </tr>
  <tr>
    <td WIDTH="140">DS1, DS0 </td>
    <td WIDTH="451">номер выбираемого накопителя </td>
  </tr>
  <tr>
    <td WIDTH="140">C </td>
    <td WIDTH="451">номер цилиндра</td>
  </tr>
  <tr>
    <td WIDTH="140">H </td>
    <td WIDTH="451">номер головки для двухстороннего
    накопителя </td>
  </tr>
  <tr>
    <td WIDTH="140">R </td>
    <td WIDTH="451">номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="140">N </td>
    <td WIDTH="451">число байтов в секторе </td>
  </tr>
  <tr>
    <td WIDTH="140">EOT </td>
    <td WIDTH="451">номер последнего сектора на дорожке </td>
  </tr>
  <tr>
    <td WIDTH="140">GPL </td>
    <td WIDTH="451">размер промежутка</td>
  </tr>
  <tr>
    <td WIDTH="140">DTL </td>
    <td WIDTH="451">число считываемых/записываемых байтов </td>
  </tr>
  <tr>
    <td WIDTH="140">SC </td>
    <td WIDTH="451">число секторов в цилиндре </td>
  </tr>
  <tr>
    <td WIDTH="140">D </td>
    <td WIDTH="451">данные</td>
  </tr>
  <tr>
    <td WIDTH="140">PCN </td>
    <td WIDTH="451">номер цилиндра после выполнения команды
    </td>
  </tr>
  <tr>
    <td WIDTH="140">чтения состояния прерывания</td>
    <td WIDTH="451">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="140">SRT </td>
    <td WIDTH="451">время шага, мс</td>
  </tr>
  <tr>
    <td WIDTH="140">HUT </td>
    <td WIDTH="451">время разгрузки головки </td>
  </tr>
  <tr>
    <td WIDTH="140">HLT </td>
    <td WIDTH="451">время загрузки головки </td>
  </tr>
  <tr>
    <td WIDTH="140">ND </td>
    <td WIDTH="451">режим прерывания</td>
  </tr>
  <tr>
    <td WIDTH="140">NCN </td>
    <td WIDTH="451">номер цилиндра после поиска </td>
  </tr>
</table>

<h3><a NAME="a7_1_23"><font SIZE="4" COLOR="#008000">7.1.23. Код ошибки при
работе с диском на уровне BIOS</font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="140">00h</td>
    <td WIDTH="451">Успешное завершение операции </td>
  </tr>
  <tr>
    <td WIDTH="140">01h</td>
    <td WIDTH="451">Неправильная команда</td>
  </tr>
  <tr>
    <td WIDTH="140">02h</td>
    <td WIDTH="451">Не найдена адресная метка </td>
  </tr>
  <tr>
    <td WIDTH="140">03h </td>
    <td WIDTH="451">Попытка записи на диск, защищенный от
    записи </td>
  </tr>
  <tr>
    <td WIDTH="140">04h </td>
    <td WIDTH="451">Сектор не найден</td>
  </tr>
  <tr>
    <td WIDTH="140">05h </td>
    <td WIDTH="451">Ошибка при сбросе (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">06h </td>
    <td WIDTH="451">Произошла замена дискеты </td>
  </tr>
  <tr>
    <td WIDTH="140">07h </td>
    <td WIDTH="451">Неправильные параметры дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">08h </td>
    <td WIDTH="451">Переполнение канала ПДП (НГМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">09h </td>
    <td WIDTH="451">Переход за границу 64К при работе с ПДП </td>
  </tr>
  <tr>
    <td WIDTH="140">0Ah</td>
    <td WIDTH="451">Обнаружен плохой сектор (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">0Bh </td>
    <td WIDTH="451">Обнаружена плохая дорожка (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">0Ch </td>
    <td WIDTH="451">Неправильный номер дорожки </td>
  </tr>
  <tr>
    <td WIDTH="140">0Dh </td>
    <td WIDTH="451">Неправильный номер сектора при
    форматировании (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">0Eh </td>
    <td WIDTH="451">Обнаружена адресная метка управляющих
    данных (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">0Fh </td>
    <td WIDTH="451">Ошибка ПДП (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="140">10h </td>
    <td WIDTH="451">Обнаружена ошибка в CRC/ECC </td>
  </tr>
  <tr>
    <td WIDTH="140">11h </td>
    <td WIDTH="451">Данные скорректированы с
    использованием ECC (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">20h </td>
    <td WIDTH="451">Сбой контроллера</td>
  </tr>
  <tr>
    <td WIDTH="140">40h </td>
    <td WIDTH="451">Сбой при поиске дорожки </td>
  </tr>
  <tr>
    <td WIDTH="140">80h </td>
    <td WIDTH="451">Таймаут - программа не успевает
    обрабатывать данные </td>
  </tr>
  <tr>
    <td WIDTH="140">AAh </td>
    <td WIDTH="451">Дисковод не готов (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">BBh </td>
    <td WIDTH="451">Неизвестная ошибка (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">CCh </td>
    <td WIDTH="451">Сбой при записи (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">E0h </td>
    <td WIDTH="451">Ошибка регистра состояния (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="140">FFh </td>
    <td WIDTH="451">Ошибка операции считывания (НМД) </td>
  </tr>
</table>

<h3><a NAME="a7_1_24"><font SIZE="4" COLOR="#008000">7.1.24. Формат первого
сектора жесткого диска</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Смещение        Размер  Содержимое
(+0)            1BEh    Загрузочная запись - программа,
                        которая загружается и выполняется
                        во время начальной загрузки
                        операционной системы
(+1BEh) 10H             Элемент таблицы разделов диска
(+1CEh) 10H             Элемент таблицы разделов диска
(+1DEh) 10H             Элемент таблицы разделов диска
(+1EEh) 10H             Элемент таблицы разделов диска
(+1FEh) 2               Признак таблицы разделов - 55AAh

</font>
</pre>

<h3><a NAME="a7_1_25"><font SIZE="4" COLOR="#008000">7.1.25. Элементы
таблицы разделов диска</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Смещение        Размер  Содержимое
(+0)            1       Признак активного раздела:
                           0 - раздел не активный;
                           80h - раздел активный.
(+1)            1       Номер головки для начального сектора
                        раздела.
(+2)            2       Номер сектора и цилиндра для начального
                        сектора раздела в формате функции чтения
                        сектора INT_13h.
(+4)            1       Код системы:
                          0 - неизвестная система;
                          1, 4 - DOS;
                          5 - расширенный раздел DOS.
(+5)            1       Номер головки для последнего сектора
                        раздела.
(+6)            2       Номер сектора и цилиндра для последнего
                        сектора раздела в формате функции чтения
                        сектора INT_13h.
(+8)            4       Относительный номер сектора начала
                        раздела.
(+12)           4       Размер раздела в секторах.

</font>
</pre>

<h3><a NAME="a7_1_26"><font SIZE="4" COLOR="#008000">7.1.26. Формат записи
BOOT для DOS версий до 4.0</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Смещение        Размер  Содержимое
(+0)            3       Команда JMP xxxx - переход типа NEAR на
                        программу начальной загрузки
(+3)            8       Название фирмы-производителя
                        операционной системы и версия,
                        например: &quot;IBM  4.0&quot;
(+11)   13              BPB - блок параметров BIOS
(+24)   2               Количество секторов на дорожке
(+26)   2               Количество головок (поверхностей диска)
(+28)   2               Количество скрытых секторов, эти сектора
                        могут использоваться для схемы 
                        разбиения физического диска на разделы
</font>
</pre>

<h3><a NAME="a7_1_27"><font SIZE="4" COLOR="#008000">7.1.27. Формат BPB Для DOS
версий до 4.0</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">(0)      2      sect_siz        Количество байтов в одном секторе диска.
(+2)     1      clustsiz        Количество секторов в одном кластере.
(+3)     2      res_sect        Количество зарезервированных секторов.
(+5)     1      fat_cnt         Количество таблиц FAT.
(+6)     2      root_siz        Максимальное количество дескрипторов файлов, 
                                содержащихся в корневом каталоге диска.
(+8)     2      tot_sect        Общее количество секторов на носителе данных 
                               (в разделе DOS).
(+10) 1 media                   Байт-описатель среды носителя данных.
(+11) 2 fat_size                Количество секторов, занимаемых одной 
                                копией FAT.
</font>
</pre>

<h3><a NAME="a7_1_28"><font SIZE="4" COLOR="#008000">7.1.28. Формат
BOOT-сектора для MS-DOS версии 4.0</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Смещение        Размер  Содержимое
(+0)            3       Команда JMP xxxx - переход типа NEAR на
                        программу начальной загрузки
(+3)            8       Название фирмы-производителя
                        операционной системы и версия,
                        например: &quot;IBM  4.0&quot;
(+11)   25              Extended BPB - расширенный блок
                        параметров BIOS
(+36)   1               Физический номер дисковода (0 -флоппи,
                        80h - жесткий диск)
(+37)   1               Зарезервировано
(+38)   1               Символ ')' - признак расширенной
                        загрузочной записи DOS 4.0
(+39)   4               Серийный номер диска (Volume Serial
                        Number), создается во время
                        форматирования диска
(+43)   11              Метка диска (Volume Label)
(+54)   8               Зарезервировано, обычно содержит
                        запись типа 'FAT12   ', которая
                        идентифицирует формат таблицы размещения
                        файлов FAT
</font>
</pre>

<h3><a NAME="a7_1_29"><font SIZE="4" COLOR="#008000">7.1.29. Расширенный
блок параметров BIOS</font></a></h3>

<ol>
  <li><font COLOR="#000080">2 sect_siz </font></li>
</ol>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Количество байтов в одном секторе диска.

(+2)     1      clustsiz        
Количество секторов в одном кластере.

(+3)     2      res_sect        
Количество зарезервированных секторов.

(+5)     1      fat_cnt 
Количество таблиц FAT.

(+6)     2      root_siz        
Максимальное количество дескрипторов файлов, содержащихся в корневом каталоге диска.

(+8)     2      tot_sect        
Общее количество секторов на носителе данных (в разделе DOS).

(+10) 1 media   
Байт-описатель среды носителя данных.

(+11) 2 fat_size        
Количество секторов, занимаемых одной копией FAT.

--------------- Расширение стандартного BPB --------------

(+13) 2 sectors 
Количество секторов на дорожке

(+15) 2 heads   
Количество магнитных головок

(+17) 2 hidden_l        
Количество скрытых секторов для раздела, который по размеру меньше 32 мегабайтов.

(+19) 2 hidden_h        
Количество скрытых секторов для раздела, превышающего по размеру 32 мегабайта. (Только для DOS 4.0).

(+21) 4 tot_secs        
Общее количество секторов на логическом диске для раздела, превышающего по размеру 32 мегабайта.
</font>
</pre>

<h3><a NAME="a7_1_30"><font SIZE="4" COLOR="#008000">7.1.30. Байт-описатель
среды media</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FFh - 2 стороны, 8 секторов на дорожке;
FEh - 1 сторона, 8 секторов на дорожке;
FDh - 2 стороны, 9 секторов на дорожке;
FCh - 1 сторона, 9 секторов на дорожке;
F9h - 2 стороны, 15 секторов на дорожке;
F8h - жесткий диск.

</font>
</pre>

<h3><a NAME="a7_1_31"><font SIZE="4" COLOR="#008000">7.1.31. Обозначение
кластеров в FAT</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FAT12           FAT16           Что означает
000h            0000h           Свободный кластер
ff0h - ff6h     fff0h - fff6h   Зарезервированный кластер
ff7h            fff7h           Плохой кластер
ff8h - fffh     fff8h - ffffh   Последний кластер в списке
002h - fefh     0002h - ffefh   Номер следующего кластера
                                в списке
</font>
</pre>

<h3><a NAME="a7_1_32"><font SIZE="4" COLOR="#008000">7.1.32. Формат
дескриптора файла</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Смещение        Размер  Содержимое
(+0)            8       Имя файла или каталога, выравненное
                        на левую границу и дополненное пробелами.
(+8)            3       Расширение имени файла, выравненное 
                        на левую границу и дополненное пробелами.
(+11)   1               Атрибуты файла.
(+12)   10              Зарезервировано.
(+22)   2               Время создания файла или время 
                        его последней модификации.
(+24)   2               Дата создания файла или дата 
                        его последней модификации.
(+26)   2               Номер первого кластера, распределенного файлу.
(+28)   4               Размер файла в байтах.
</font>
</pre>

<h3><a NAME="a7_1_33"><font SIZE="4" COLOR="#008000">7.1.33. Байт атрибутов
файла</font></a></h3>

<table BORDER="1">
  <tr>
    <td WIDTH="64">0</td>
    <td WIDTH="526">Файл предназначен только для чтения, в
    этот файл нельзя писать и его нельзя стирать. </td>
  </tr>
  <tr>
    <td WIDTH="64">1 </td>
    <td WIDTH="526">Скрытый файл, этот файл не будет
    появляться в списке файлов, создаваемом командой
    операционной системы DIR. </td>
  </tr>
  <tr>
    <td WIDTH="64">2 </td>
    <td WIDTH="526">Системный файл. Этот бит обычно
    установлен в файлах, являющихся составной частью
    операционной системы. </td>
  </tr>
  <tr>
    <td WIDTH="64">3 </td>
    <td WIDTH="526">Данный дескриптор описывает метку
    диска. Для этого дескриптора поля имени файла и
    расширения имени файла должны рассматриваться
    как одно поле длиной 11 байт. Это поле содержит
    метку диска. </td>
  </tr>
  <tr>
    <td WIDTH="64">4 </td>
    <td WIDTH="526">Дескриптор описывает файл, являющийся
    подкаталогом данного каталога. </td>
  </tr>
  <tr>
    <td WIDTH="64">5 </td>
    <td WIDTH="526">Флаг архивации. Если этот бит установлен
    в 1, это означает, что данный файл не был выгружен
    утилитой архивации (например, программой BACKUP). </td>
  </tr>
  <tr>
    <td WIDTH="64">6-7 </td>
    <td WIDTH="526">Зарезервированы.</td>
  </tr>
  <tr>
    <td WIDTH="64">&nbsp;</td>
    <td WIDTH="526">&nbsp;</td>
  </tr>
</table>

<h3><a NAME="a7_1_34"><font SIZE="4" COLOR="#008000">7.1.34. Формат поля
времени</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">15            11 10               5 4                   0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Часы (0...23) ¦  Минуты (0...59) ¦  Секунды/2 (0...29) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

</font>
</pre>

<h3><a NAME="a7_1_35"><font SIZE="4" COLOR="#008000">7.1.35. Формат даты
обновления файла</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">15             9 8               5 4              0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Год (0...119) ¦  Месяц (1...12) ¦  День (1...31) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

</font>
</pre>

<h3><a NAME="a7_1_36"><font SIZE="4" COLOR="#008000">7.1.36. Формат блока DDCB
для версий 2.х и 3.х </font></a></h3>

<ol>
  <li><font COLOR="#000080">1 drv_num </font></li>
</ol>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">номер устройства (0 соответствует устройству А, 1 - В и т.д.)

(+1)     1      drv_numd        
дополнительный номер устройства внутри драйвера

(+2)     2      sec_size        
размер сектора в байтах

(+4)     1      clu_size        
число, на единицу меньшее количества секторов в кластере

(+5)     1      clu_base        
если содержимое этого поля не равно нулю, то для получения общего числа секторов в кластере надо возвести 2 в степень clu_base и получившееся число прибавить к clu_size

(+6)     2      boot_siz        
количество зарезервированных секторов (boot-сектора, начало корневого каталога)

(+8)     1      fat_num 
количество копий FAT

(+9)     2      max_dir 
максимальное число дескрипторов файлов в корневом каталоге (т.е. максимальное число файлов, которое может содержать корневой каталог на этом устройстве)

(+11) 2 data_sec        
номер первого сектора данных на диске (номер сектора, соответствующего кластеру номер 2)

(+13) 2 hi_clust        
максимальное количество кластеров (равно увеличенному на 1 количеству кластеров данных)

(+15) 1 fat_size        
количество секторов, занимаемых одной копией FAT

(+16) 2 root_sec        
номер первого сектора корневого каталога

(+18) 4 drv_addr        
FAR-адрес заголовка драйвера, обслуживающего данное устройство

(+22) 1 media   
байт описания среды носителя данных

(+23) 1 acc_flag        
флаг доступа, 0 означает, что к устройству был доступ

(+24) 4 next            
адрес следующего блока DDCB, для последнего блока в поле смещения находится число FFFF

--------------- только для DOS 2.x -----------------

(+28) 2 dir_clu 
номер начального кластера текущего каталога (0 для корневого каталога)

(+30) 64        dir_path        
строка в формате ASCIIZ, содержащая путь к текущему каталогу

--------------- DOS 3.х ----------------------------

(+28) 2 reserv1 
зарезервироано, обычно равно 0

(+30) 2 built   
число FFFF в этом поле означает, что блок DDCB был построен

</font>
</pre>

<h3><a NAME="a7_1_37"><font SIZE="4" COLOR="#008000">7.1.37. Формат блока DDCB
для DOS версии 4.х </font></a></h3>

<ol>
  <li><font COLOR="#000080">1 drv_num </font></li>
</ol>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">номер устройства (0 соответствует устройству А, 1 - В и т.д.)

(+1)     1      drv_numd        
дополнительный номер устройства внутри драйвера

(+2)     2      sec_size        
размер сектора в байтах

(+4)     1      clu_size        
число, на единицу меньшее количества секторов в кластере

(+5)     1      clu_base        
если содержимое этого поля не равно нулю, то для получения общего числа секторов в кластере надо возвести 2 в степень clu_base и получившееся число прибавить к clu_size

(+6)     2      boot_siz        
количество зарезервированных секторов (boot-сектора, начало корневого каталога)

(+8)     1      fat_num 
количество копий FAT

(+9)     2      max_dir 
максимальное число дескрипторов файлов в корневом каталоге (т.е. максимальное число файлов, которое может содержать корневой каталог на этом устройстве)

(+11) 2 data_sec        
номер первого сектора данных на диске (номер сектора, соответствующего кластеру номер 2)

(+13) 2 hi_clust        
максимальное количество кластеров (равно увеличенному на 1 количеству кластеров данных)

(+15) 1 fat_size        
количество секторов, занимаемых одной копией FAT

(+16) 1 reserv1 
зарезервировано

(+17) 2 root_sec        
номер первого сектора корневого каталога

(+19) 4 drv_addr        
FAR-адрес заголовка драйвера, обслуживающего данное устройство

(+23) 1 media   
байт описания среды носителя данных

(+24) 1 acc_flag        
флаг доступа, 0 означает, что к устройству был доступ

(+25) 4 next            
адрес следующего блока DDCB, для последнего блока в поле смещения находится число FFFF

(+29) 2 reserv2 
зарезервироано

(+31) 2 built   
число FFFF в этом поле означает, что блок DDCB был построен

</font>
</pre>

<h3><a NAME="a7_1_38"><font SIZE="4" COLOR="#008000">7.1.38. Идентификатор
BIOS</font></a></h3>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">F000:FFF5 (8)   - дата изготовления BIOS;
F000:FFFC (2)   - не используется;
F000:FFFE (1)   - код типа компьютера.

</font>
</pre>

<h2><a NAME="a7_2"><font SIZE="5" COLOR="#FF0000">7.2 Контроллер
прерываний 8259</font></a></h2>

<p>Программируемый контроллер прерываний 8259
(отечественный аналог - КР1810ВН59А) предназначен
для обработки до восьми приоритетных уровней
прерываний. Возможно каскадирование микросхем,
при этом общее число уровней прерываний будет
достигать 64. </p>

<p>Контроллер 8259 имеет несколько режимов работы,
которые устанавливаются программным путем. В
персональных компьютерах XT и AT за первоначальную
установку режимов работы микросхем 8259 отвечает <u>BIOS</u><font
SIZE="1">BIOS</font>. У программиста скорее всего не
возникнет потребность перепрограммировать
контроллер - это небезопасно, так как
неправильное программирование контроллера
приведет к нарушению логики работы всей системы. </p>

<p>Однако часто возникает необходимость
изменения текущего режима работы (запрет или
разрешение прерываний определенного или всех
уровней, обработка конца прерывания) или опроса
состояния внутренних регистров контроллера. Для
этого необходимо ознакомиться со справочными
данными на микросхему 8259, где детально описано
как первоначальное прогрммирование контроллера,
так и управление им во время работы. </p>

<p>Каждому приоритетному уровню прерывания
микросхема ставит в соответствие определенный,
задаваемый программно номер прерывания. В
разделе книги, посвященном особенностям
обработки аппаратных прерываний, приводится
такое соответствие для машин типа XT и AT. </p>

<p>Если контроллеры 8259 каскадированы, то ведомой
микросхеме присваивается код (выдачей в
микросхему соответствующего командного слова).
Этот код равен номеру входа <b>IRQ</b> ведущей
микросхемы, с которым соединен выход запроса
прерывания <b>INT</b> ведомой микросхемы. Внутри
микросхемы приоритет зависит от номера <b>IRQ</b> и
задается программно. Для компьютеров XT и AT самым
высоким приоритетом внутри группы,
обслуживаемой каждым контроллером, является
вход <b>IRQ0</b>. Однако возможно программное
изменение приоритетов в рамках так называемого
приоритетного кольца. При этом дно приоритетного
кольца имеет самый низкий приоритет. </p>

<p>Приведем возможные варианты задания
приоритетов: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="91"><b>Вход</b></td>
    <td WIDTH="204"><b>Уровни приоритета</b> </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ0</b></td>
    <td WIDTH="204">7 6 5 4 3 2 1 0 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ1</b></td>
    <td WIDTH="204">0 7 6 5 4 3 2 1 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ2</b></td>
    <td WIDTH="204">1 0 7 6 5 4 3 2 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ3</b></td>
    <td WIDTH="204">2 1 0 7 6 5 4 3 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ4</b></td>
    <td WIDTH="204">3 2 1 0 7 6 5 4 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ5</b></td>
    <td WIDTH="204">4 3 2 1 0 7 6 5 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ6</b></td>
    <td WIDTH="204">5 4 3 2 1 0 7 6 </td>
  </tr>
  <tr>
    <td WIDTH="91"><b>IRQ7</b></td>
    <td WIDTH="204">6 5 4 3 2 1 0 7 </td>
  </tr>
</table>

<p>Наиболее высокий приоритет у входа <b>IRQ</b> с
обозначением <b>0</b> приоритетного кольца,
наиболее низкий - с обозначением <b>7</b>. </p>

<p>Для обработки прерываний контроллер имеет
несколько внутренних регистров. Это регистр
запросов прерываний <b>IRR</b>, регистр обслуживания
прерываний <b>ISR</b>, регистр маски прерываний <b>IMR</b>.
В регистре <b>IRR</b> хранятся запросы на
обслуживание прерываний от аппаратуры. После
выработки сигнала прерывания центральному
процессору соответствующий разряд регистра <b>ISR</b>
устанавливается в единичное состояние, что
блокирует обслуживание всех запросов с равным
или более низким приоритетом. Устранить эту
блокировку можно либо сбросом соответствующего
бита в <b>ISR</b>, либо командой специального
маскирования. </p>

<p>Имеется два типа команд, посылемых программой в
контроллер 8259 - команды инициализации и команды
операции. Возможны следующие операции: 

<ul>
  <li>индивидуальное маскирование запросов
    прерывания; </li>
  <li>специальное маскирование обслуженных запросов;
  </li>
  <li>установка статуса уровней приоритета (по
    установке исходного состояния, по обслуженному
    запросу, по указанию); </li>
  <li>операции конца прерывания (обычный конец
    прерывания, специальный конец прерывания,
    автоматический конец прерывания); </li>
  <li>чтение регистров <b>IRR, ISR, IMR.</b> </li>
</ul>

<p>Мы не будем подробно описывать команды
инициализации контроллера 8259, так как
программистам они скорее всего не понадобятся.
Желающих разобраться во всех тонкостях задания
начального режима работы контроллера прерываний
мы отсылаем к справочной литературе по
микросхеме 8259 или ее отечественному аналогу. </p>

<p>Рассмотрим команды операций. Существуют три
типа команд операций: 

<ol>
  <li>Маскирование запросов прерывания. </li>
  <li>Команды обработки конца прерывания. </li>
  <li>Опрос регистров и специальное маскирование. </li>
</ol>

<p>Байты команды маскирования запросов
прерывания выводятся соответственно в порты <b>21h</b>
и <b>A1h</b> для первого и второго контроллера 8259
компьютера AT. Команды операций второго и
третьего типа используют порты с адресами <b>20h</b>
и <b>A0h</b>. </p>

<p>Маскирование запросов прерываний мы уже
описывали в главе, посвященной прерываниям. Для
маскирования какого-либо уровня прерывания надо
записать в регистр маски <b>IMR</b> по адресу <b>21h</b>
или <b>A1h</b> единицу в соответствующий разряд
регистра. </p>

<p>Команды обработки конца прерывания приведем в
виде таблицы: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="263"><b><i>Биты байта команды <br>
    </i>D7 D6 D5 D4 D3 D2 D1 D0</b> </td>
    <td WIDTH="333"><i><b>Описание</b></i></td>
  </tr>
  <tr>
    <td WIDTH="263">0 0 1 0 0 0 0 0</td>
    <td WIDTH="333">Обычный конец прерывания. </td>
  </tr>
  <tr>
    <td WIDTH="263">0 1 1 0 0 B2 B1 B0</td>
    <td WIDTH="333">Специальный конец прерывания, <b>B0...B2 </b>-
    двоично-десятичный код сбрасываемого разряда в
    регистре обслуживания прерывания <b>ISR</b>. </td>
  </tr>
  <tr>
    <td WIDTH="263">1 0 1 0 0 X X X</td>
    <td WIDTH="333">Циклический сдвиг уровней приоритета с
    обычным концом прерывания. Дно приоритетного
    кольца устанавливается по обслуженному запросу. </td>
  </tr>
  <tr>
    <td WIDTH="263">1 1 1 0 0 B2 B1 B0</td>
    <td WIDTH="333">Циклический сдвиг уровней приоритета со
    специальным концом прерывания, <b>B0...B2</b> -
    двоично-десятичный код дна приоритетного кольца.
    </td>
  </tr>
  <tr>
    <td WIDTH="263">1 0 0 0 0 X X X</td>
    <td WIDTH="333">Разрешение вращения уровней приоритета.
    </td>
  </tr>
  <tr>
    <td WIDTH="263">0 0 0 0 0 X X X</td>
    <td WIDTH="333">Сброс разрешения вращения уровней
    приоритета. </td>
  </tr>
  <tr>
    <td WIDTH="263">1 1 0 0 0 B2 B1 B0</td>
    <td WIDTH="333">Циклический сдвиг уровней приоритета
    без завершения прерывания, <b>B0...B2</b> -
    двоично-десятичный код дна приоритетного клоьца.
    </td>
  </tr>
</table>

<p>Команды третьего типа выдаются также в порты с
адресами <b>20h</b> и <b>A0h</b>. Они имеют следующий
формат: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="264"><b>Биты байта команды<br>
    D7 D6 D5 D4 D3 D2 D1 D0</b> </td>
    <td WIDTH="334"><b>Описание</b></td>
  </tr>
  <tr>
    <td WIDTH="264">0 0 0 0 1 1 X X</td>
    <td WIDTH="334">Установка режима опроса. </td>
  </tr>
  <tr>
    <td WIDTH="264">0 0 0 0 1 0 1 1</td>
    <td WIDTH="334">Разрешение чтения регистра <b>ISR</b>. </td>
  </tr>
  <tr>
    <td WIDTH="264">0 0 0 0 1 0 1 0</td>
    <td WIDTH="334">Разрешение чтения регистра <b>IRR</b>. </td>
  </tr>
  <tr>
    <td WIDTH="264">0 1 1 0 1 0 0 0</td>
    <td WIDTH="334">Разрешение триггера специального
    маскирования. </td>
  </tr>
  <tr>
    <td WIDTH="264">0 1 0 0 1 0 0 0</td>
    <td WIDTH="334">Сброс триггера специального
    маскирования. </td>
  </tr>
</table>

<p>По команде обычного конца прерывания
устанавливается в нулевое состояние разряд <b>ISR</b>,
соответствующий последнему обслуженному
запросу. </p>

<p>Команда специального конца прерывания
устанавливает в нулевое состояние тот разряд <b>ISR</b>,
номер которого указан в разрядах<b> B0...B2</b>
команды. </p>

<p>Команда циклического сдвига уровней
приоритета с обычным концом прерывания
устаналивает в ноль разряд <b>ISR</b>,
соответствующий последнему обслуженному
запросу, и этому же номеру запроса присваивается
низший уровень приоритета. </p>

<p>Аналогично работает команда циклического
сдвига уровней приоритета со специальным концом
прерывания, только низший уровень приоритета
присваивается тому входу <b>IRQ</b>, номер которого
указан в разрядах <b>B0...B2 </b>команды. </p>

<p>Команда циклического сдвига уровней
приоритета устанавливает статус уровней
приоритета без выполнения операции конца
прерывания. Разряды <b>B0...B2</b> указывают дно
приоритетного кольца. </p>

<p>После выполнения команд разрешения чтения
регистров <b>ISR</b> или <b>IRR</b> при выполнении команды
ввода из порта <b>20h</b> и <b>A0h</b> считывается
соответственно содержимое регистров <b>ISR</b> и <b>IRR</b>.
Для получения содержимого регистра <b>IMR</b>
необходимо выполнить чтение портов с адресами
соответственно <b>21h</b> и <b>A1h</b>. </p>

<p>Команда разрешения триггера специального
маскирования блокирует действие тех разрядов <b>ISR</b>,
которые замаскированы командой типа 1
(маскирования индивидуальных приоритетных
уровней запроса прерывания). Специальное
маскирование используется для обслуживания
такого запроса, который блокируется старшим или
равным по уровню приоритета обслуженным
запросом, хранящимся в <b>ISR</b>, не сбрасывая
последний. </p>

<p>Чтение регистров <b>ISR</b> и <b>IRR</b> может
испльзоваться резидентными программами при
проверке возможности своей активизации - можно
проверить, не выполняется ли в настоящий момент
обработка какого-нибудь прерывания, которая
может конфликтовать с действиями резидентной
программы. </p>

<h2><a NAME="a7_3"><font SIZE="5" COLOR="#FF0000">7.3. Сегментная
адресация памяти</font></a></h2>

<p>Особенностью архитектуры процессоров INTEL 8086,
80286, 80386, 80486 является использование механизма
сегментации адресного пространства. Сегментация
вызывает трудности у тех программистов, которые
раньше работали на ЭВМ типов PDP, СМ ЭВМ, ЕС ЭВМ. В
этих машинах программа имеет дело с логическими
адресами, которые тем или иным способом
отображаются на физические адреса. Программа
может не знать подробностей отображения
логических адресов на физические, она работает
только с логическим адресом. </p>

<p>Прообраз процессора 8086 - оригинальный
микропроцессор INTEL 8080 - имел линейное адресное
пространство размером 64 килобайта. В этом
микропроцессоре логический и физический адреса
совпадали - все 16 адресных линий (адресных шин)
использовались непосредственно для адресации
памяти, а программы оперировали абсолютными
шестнадцатиразрядными адресами. </p>

<p>Однако быстро растущие потребности программ в
оперативной памяти привели к необходимости
расширения адресного пространства. Следующий
микропроцессор 8086 имел уже 20 адресных линий, что
позволило непосредственно адресовать до
мегабайта оперативной памяти. Архитектурное
решение этого микропроцессора позволило легко
адаптировать накопленное в большом количестве
программное обеспечение для микропроцессора 8080. </p>

<p>Микропроцессор 8086 является
шестнадцатиразрядным, поэтому использование
двадцатиразрядного адреса в 16-разрядных
командах неэффективно. Вместо указания в
командах полного 20-разрядного адреса
используется двухкомпонентная адресация, причем
каждая компонента использует только 16 разрядов. </p>

<p>Эти компоненты называются сегментной
компонентой адреса и компонентой смещения.
Логический 20-разрядный адрес получается
сложением двух компонент, причем сегментный
адрес перед сложением умножается на 16
(сдвигается влево на 4 разряда). Сложение и сдвиг
выполняется аппаратно, поэтому на формирование
20-разрядного адреса дополнительно время не
затрачивается. </p>

<p>На рисунке показано, как в процессоре 8086
происходит формирование 20-разрядного адреса из
адреса сегмента и смещения: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">19                      4 3        0
+----------------------------------+
¦ Сегментный адрес       ¦ 0 0 0 0 ¦
+----------------------------------+ 

  +
19      16 15                      0
+----------------------------------+
¦ 0 0 0 0 ¦               Смещение ¦
+----------------------------------+ 

=
19                                0
+----------------------------------+
¦ Полный 20-разрядный адрес        ¦
+----------------------------------+ 

</font>
</pre>

<p>Адрес сегмента сдвигается влево на 4 бита с
заполнением младших битов нулями, смещение
расширяется до 20 битов и складывается со
сдвинутым адресом сегмента. Например, если адрес
сегмента равен 1234h, а смещение равно 1116h, то полный
20-разрядный адрес будет 12340h + 01116h = 13456h. </p>

<p>Таким образом, оперируя 16-разрядными адресами
сегмента и смещением, процессор может адресовать
мегабайт памяти. Для хранения сегментных адресов
и смещений процессор имеет специальные регистры.
</p>

<p>Каждая выполняющаяся программа в любой момент
времени может адресоваться сразу к четырем
сегментам памяти. Это сегмент кода, сегмент
данных, дополнительный сегмент данных, сегмент
стека. Сегмент кода содержит выполняющиеся
машинные команды, сегменты данных и
дополнительных данных используются для
размещения используемых программой переменных,
массивов и других структур данных, сегмент стека
используется при вызове подпрограмм. </p>

<p>Сегменты могут перекрываться или не
перекрываться. </p>

<p>Для хранения сегментных адресов процессор
имеет 4 сегментных регистра: <b>CS, DS, ES, SS.</b> Эти
регистры содержат соответственно адреса
сегментов кода, данных, дополнительных данных и
стека. </p>

<p>При адресации выполняющегося кода вместе с
регистром <b>CS</b> используется регистр смещения <b>IP</b>.
Пара регистров<b> CS:IP</b> всегда указывает на
текущую выполняющуюся команду. </p>

<p>Адресация данных возможна относительно любого
сегментного регистра. При этом смещение может
указываться как непосредственно в команде, так и
с помощью регистров. Программа должна сама
следить за правильной загрузкой и
использованием сегментных регистров. </p>

<p>Мы приведем несколько примеров программ,
составленных на языке ассемблера. Эти программы
используют различное количество сегментов и
могут служить шаблоном для составления ваших
собственных программ. </p>

<p>Первая программа использует всего один
сегмент. В этом сегменте расположены
выполняющиеся машинные команды и данные,
используемые программой. Заметьте, что размер
программы, состоящей из одного сегмента, не может
превышать 64 килобайта. </p>

<p>Текст программы: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">; В этом месте расположен сегмент кода. Он содержит
; выполняющуюся программу.

code    segment

; Директива assume сообщает ассемблеру, как будут
; использоваться сегментные регистры. Эта директива
; не выполняет загрузку сегментных регистров, она
; нужна ассемблеру только для правильного вычисления
; смещений.

        assume cs:code, ds:code

; Эта строка нужна для создания com-программы.

        org 100h

; При запуске программы управление будет передано
; на оператор с меткой start.
; Первое, что должна сделать программа - правильно
; загрузить сегментные регистры.
; Регистр CS загружается операционной системой
; при запуске программы, поэтому его загружать не надо.
; Регистры DS и ES должны указывать на начало
; сегмента кода, так как программа состоит из одного
; сегмента.

start: 
        mov     ax, cs
        mov     ds, ax

; Выводим сообщение msg из сегмента данных

        mov     ah, 9h
        mov     dx, OFFSET msg
        int     21h

; Завершаем работу программы

        mov     ax, 4C00h
        int     21h

; Строка, которую программа выведет на экран.

msg     db      &quot;Hello, world.&quot;, 13, 10, &quot;$&quot;

code    ends

        end     start

</font>
</pre>

<p>Если для размещения данных и буферов
недостаточно одного сегмента, необходимо
организовать отдельные сегменты для кода и
данных, как это сделано в следующем примере: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">; Создаем сегмент стека. Размер стека - 256 байт,
; стек выравнен на границу параграфа (para).

stack   segment para stack

; Резервируем 256 байт для стека.

        db      100h dup (?)

stack   ends

; Создаем сегмент данных. Этот сегмент выравнен на
; границу двухбайтового слова (word).

data    segment word

; Строка, которую программа выведет на экран.

msg     db      &quot;Hello, world.&quot;, 13, 10, &quot;$&quot;

data    ends

; В этом месте расположен сегмент кода. Он содержит
; выполняющуюся программу.

code    segment

; Директива assume сообщает ассемблеру, как будут
; использоваться сегментные регистры. Эта директива
; не выполняет загрузку сегментных регистров, она
; нужна ассемблеру только для правильного вычисления
; смещений.

        assume  cs:code, ds:data, ss:stack

; При запуске программы управление будет передано
; на оператор с меткой start.
; Первое, что должна сделать программа - правильно
; загрузить сегментные регистры.
;
; Следующие два оператора инициализируют сегментный
; регистр данных DS.

start:  
        mov     ax, data
        mov     ds, ax

; Инициализируем сегментный регистр стека и
; указатель стека (регистры SS и SP).
; Эта операция должна выполняться в состоянии
; процессора с запрещенными прерываниями, иначе
; если регистр SS будет содержать уже новое значение,
; а SP - старое и если в этот момент произойдет
; прерывание, адрес возврата и значение регистра флагов
; будут записаны в не предназначенную для этого область.

        cli
        mov     ss, ax
        mov     sp, OFFSET stack
        sti

; Выводим сообщение msg из сегмента данных

        mov     ah, 9h
        mov     dx, OFFSET msg
        int     21h

; Завершаем работу программы

        mov     ax, 4C00h
        int     21h

code    ends

        end     start

</font>
</pre>

<p>Макроассемблер MASM версии 5.0 и более поздних
версий, а также Quick Assembler содержит директивы,
упрощающие описание сегментов. Это такие
директивы, как <b>.CODE, .DATA, .MODEL</b> и другие. Вы
найдете подробное описание этих директив в
соответствующей документации по ассемблеру.
Остановимся подробнее на директиве<b> .MODEL.</b> </p>

<p>Эта директива задает так называемую модель
памяти, используемую программой. Что это такое? </p>

<p>Мы уже говорили о том, что программа должна
состоять из одного или нескольких сегментов, в
зависимости от размера кода и данных, которыми
она оперирует. Существует несколько стандартных
вариантов использования сегментов, которые
называются моделями памяти. Всего используются
шесть моделей памяти:<br>

<ul>
  <li><b>Tiny;</b> </li>
  <li><b>Small;</b> </li>
  <li><b>Medium;</b> </li>
  <li><b>Compact;</b> </li>
  <li><b>Large;</b> </li>
  <li><b>Huge.</b> </li>
</ul>

<p>Модель памяти <b>Tiny</b> используется небольшими
программами, состоящими из одного сегмента и
имеющими формат <b>COM</b>. Использование этой модели
памяти - единственный способ получения
загрузочного модуля в формате <b>COM</b>. </p>

<p>В модели <b>Small</b> один сегмент используется для
кода, один для хранения данных и размещения стека
программы. Общий размер программы в этом случае
ограничен величиной 128 килобайтов. Большинство
небольших программ используют именно эту модель
памяти. </p>

<p>Если ваша программа оперирует небольшим
объемом данных, но размер кода превышает 64
килобайта, вам подходит модель <b>Medium</b>. В этой
модели используется несколько сегментов для
хранения кода и только один - для данных. </p>

<p>Модель <b>Compact</b>, в отличие от <b>Medium</b>, использует
один сегмент для кода и несколько - для данных.
Эта модель больше всего подходит для небольших
программ, обрабатывающих большие массивы данных.
</p>

<p>Модель памяти <b>Large</b> предоставляет
возможность использовать несколько сегментов
для кода и несколько сегментов для данных. Эта
модель обычно используется большими
программами, которые обрабатывают большие
объемы данных. </p>

<p>И, наконец, модель памяти <b>Huge</b>. Эта модель
аналогична <b>Large</b>, но для программ, составленных
на языке Си, она позволяет использовать массивы
данных, имеющие размер более одного сегмента. </p>

<p>Приведем два примера использования моделей
памяти в программах, составленных на языке
ассемблера. Эти примеры аналогичны тем, которые
мы только что рассмотрели. Первая программа
использует модель памяти <b>Tiny</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">; Определяем используемую модель памяти

        .model  tiny

; Определяем сегмент данных.

        .data
msg     db      &quot;Hello, world.&quot;, 13, 10, &quot;$&quot;

; Определяем сегмент кода.

        .code

; Макрокоманда startup выполняет все необходимые
; инициализирующие действия, которые зависят от
; модели памяти.

        .startup

; Выводим сообщение на экран

        mov     ah, 9h
        mov     dx, OFFSET msg
        int     21h

; Завершаем выполнение программы

        .exit

        END
</font>
</pre>

<p>Вторая программа использует модель памяти <b>Small</b>,
в ней мы дополнительно определили свой стек: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">; Определяем используемую модель памяти

        .model  small

; Определяем сегмент данных.

        .data
msg     db      &quot;Hello, world.&quot;, 13, 10, &quot;$&quot;

; Определяем свой стек, его размер - 256 байтов

        .stack  100h

; Определяем сегмент кода.

        .code

        .startup

; Выводим сообщение на экран

        mov     ah, 9h
        mov     dx, OFFSET msg
        int     21h

; Завершаем выполнение программы

        .exit

        END

</font>
</pre>

<p>Для программ, составленных на языке Си, модель
памяти указывается при трансляции. Если
используется пакетный транслятор, модель
указывается при помощи опций в командной строке.
Если вы работаете в интегрированной среде, такой
как Quick C, модель задается при помощи
соответствующего меню, а сама программа не
содержит каких-либо директив, определяющих
используемую модель памяти. </p>

<p>Как правильно выбрать модель памяти? </p>

<p>Если ваша программа небольшая по размеру, то
вам подойдут модели <b>TINY</b> или <b>SMALL</b>. При
использовании остальных моделей памяти возможно
увеличение размера загрузочного модуля и
времени выполнения программы из-за того, что в
операциях с данными и при вызове подпрограмм
используются полные адреса, состоящие из
сегмента и смещения. Это означает, в частности,
что если при трансляции программы была
использована модель <b>LARGE</b>, то при обращении к
каждой переменной и при вызове каждой
подпрограммы (функции) будет использоваться
полный адрес. </p>

<p>Для сокращения накладных расходов отдельные
переменные и функции можно разместить в
отдельном сегменте. Для этого их надо описать
специальным образом - используя ключевое слово
near (для С 6.0 и QC 2.5 можно использовать <b>_near</b>). </p>

<p>Ключевое слово <b>near</b> <b>(_near) </b>сообщает
транслятору, что данные должны быть размещены в
некотором общем сегменте данных и доступ к ним
должен осуществляться с использованием
16-битового адреса (только компонента смещения).
Если с этим ключевым словом описана функция, то
транслятор поместит ее в текущий сегмент кода,
для вызова функции будет также использован
16-битовый адрес. </p>

<p>В противоположность к только что описанному
ключевое слово <b>far</b> (<b>_far</b> для С 6.0 и QC 2.5)
говорит о том, что данные или функция могут
располагаться в любом месте памяти, не
обязательно в текущем сегменте, и для адресации
необходимо использовать полный 32-битовый адрес. </p>

<p>Ключевое слово <b>huge</b> <b>(_huge)</b> необходимо
использовать при описании массвов, которые по
своим размерам могут превышать 64К. Для адресации
при этом будет использоваться полный 32-битовый
адрес. Для функций это ключевое слово не
применяется. </p>

<p>Приведем несколько примеров описания данных и
функций с использованием ключевых слов <b>near, far,
huge.</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">// Используемая модель памяти - SMALL

char dim1[250];
char _far dim2[45000];
char _huge dim3[80000];
char _far *far_ptr;
char _far * _far * far_ptr1;

int _far function1(void);
// Используемая модель памяти - LARGE

char _near dim4[2000];

char _far * _near function2(void);

</font>
</pre>

<p>Исчерпывающие сведения об использовании
моделей памяти можно почерпнуть из документации
на используемый транслятор. </p>

<h2><a NAME="a7_4"><font SIZE="5" COLOR="#FF0000">7.4. Содержимое файла
sysp.h</font></a></h2>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/* SYSP.H - include-файл для примеров, приведенных в книге */



/**
*.Name      FP_MAKE
*
*.Title     Макро для составления FAR-указателя
*
*.Descr     Макро составляет FAR-указатель, пользуясь
*           значениями сегмента и смещения
*
*.Params    FP_MAKE(seg,off)
*              seg - сегмент;
*              off - смещение
*
*.Return    FAR-указатель seg:off
**/


#define FP_MAKE(seg,off) ((void far *)                         \
                                        ((((unsigned long) (unsigned)(seg)) &lt;&lt; 16L) | \
                                        ((unsigned long) (unsigned) (off))))


/* Структура векторной таблицы связи DOS */

#pragma pack(1)

typedef struct _CVT_ {
        unsigned mcb_seg;
        void far *dev_cb;
        void far *file_tab;
        void far *clock_dr;
        void far *con_dr;
        unsigned max_btbl;
        void far *disk_buf;
        void far *drv_info;
        void far *fcb_tabl;
        unsigned fcb_size;
        unsigned char num_bdev;
        unsigned char lastdriv;
} CVT;


/* Блок управления памятью MCB */

typedef struct _MCB_ {
        unsigned char type;
        unsigned owner;
        unsigned size;
        char reserve[11];
} MCB;

/* Префикс программного сегмента PSP */

typedef struct _PSP_ {
        unsigned char int20h[2];
        unsigned mem_top;
        unsigned char reserv1;
        unsigned char call_dsp[5];
        void far *term_adr;
        void far *cbrk_adr;
        void far *crit_err;
        unsigned parn_psp;
        unsigned char file_tab[20];
        unsigned env_seg;
        void far *ss_sp;
        unsigned max_open;
        void far *file_tba;
        unsigned char reserv2[24];
        unsigned char disp[3];
        unsigned char reserv3[9];
        unsigned char fcb1[16];
        unsigned char fcb2[20];
        unsigned char p_size;
        unsigned char parm[127];
} PSP;


/* Блок управления устройством DOS */

typedef struct _DDCB_ {
        unsigned char drv_num;
        unsigned char drv_numd;
        unsigned sec_size;
        unsigned char clu_size;
        unsigned char clu_base;
        unsigned boot_siz;
        unsigned char fat_num;
        unsigned max_dir;
        unsigned data_sec;
        unsigned hi_clust;
        unsigned char fat_size;
        char reserv1;
        unsigned root_sec;
        void far *drv_addr;
        unsigned char media;
        unsigned char acc_flag;
        struct _DDCB_ far *next;
        unsigned reserv2;
        unsigned built;
} DDCB;

/* Управляющий блок DOS для файлов */

typedef struct _DFCB_ {
        unsigned handl_num;
        unsigned char access_mode;
        unsigned reserv1;
        unsigned dev_info;
        void far *driver;
        unsigned first_clu;
        unsigned time;
        unsigned date;
        unsigned long fl_size;
        unsigned long offset;
        unsigned reserv2;
        unsigned reserv7;
        unsigned reserv3;
        char reserv4;
        char filename[11];
        char reserv5[6];
        unsigned ownr_psp;
        unsigned reserv6;
        unsigned last_clu;
        char reserv8[4];
} DFCB;

/* Таблица файлов DOS */

typedef struct _DFT_ {
        struct _DFT_ far *next;
        unsigned file_count;
        DFCB dfcb;
} DFT;


/* Управляющий блок дискового буфера BCB */

typedef struct _BCB_ {
        struct _BCB_ far *next;
        unsigned char drive;
        unsigned char flag;
        unsigned sect_num;
        unsigned reserv1;
        DDCB far *ddcb;
        unsigned reserv2;
} BCB;

/* Информация о диске */

typedef struct _DINFO_ {
        char path[64];
        unsigned reserv1;
        unsigned reserv2;
        unsigned char reserv3;
        DDCB far *ddcb;
        unsigned cdir_clu;
        unsigned reserv4;
        unsigned reserv5;
        unsigned reserv6;
        unsigned char reserv7[7];
} DINFO;


/* Заголовок EXE-программы */

typedef struct _EXE_HDR_ {
        unsigned signature;
        unsigned part_pag;
        unsigned file_size;
        unsigned rel_item;
        unsigned hdr_size;
        unsigned min_mem;
        unsigned max_mem;
        unsigned ss_reg;
        unsigned sp_reg;
        unsigned chk_summ;
        unsigned ip_reg;
        unsigned cs_reg;
        unsigned relt_off;
        unsigned overlay;
} EXE_HDR;


/* таблица расположения сегментов EXE-программы */

typedef struct _RELOC_TAB_ {
        unsigned offset;
        unsigned segment;
} RELOC_TAB;


/* конфигурация дисковой подсистемы */

typedef struct _DISK_CONFIG_ {
        int  n_floppy;
        int  n_hard;
        int  t_floppy1;
        int  t_floppy2;
        int  t_hard1;
        int  t_hard2;
} DISK_CONFIG;


/* таблица параметров дискеты */

typedef struct _DPT_ {
        unsigned char srt_hut;
        unsigned char dma_hlt;
        unsigned char motor_w;
        unsigned char sec_size;
        unsigned char eot;
        unsigned char gap_rw;
        unsigned char dtl;
        unsigned char gap_f;
        unsigned char fill_char;
        unsigned char hst;
        unsigned char mot_start;
} DPT;

/* таблица параметров диска */

typedef struct _HDPT_ {
        unsigned max_cyl;
        unsigned char max_head;
        unsigned srwcc;
        unsigned swpc;
        unsigned char max_ecc;
        unsigned char dstopt;
        unsigned char st_del;
        unsigned char fm_del;
        unsigned char chk_del;
        unsigned char reserve[4];
} HDPT;

/* Элемент таблицы разделов */

typedef struct _PART_ENTRY_ {
        unsigned char flag;
        unsigned char beg_head;
        unsigned beg_sec_cyl;
        unsigned char sys;
        unsigned char end_head;
        unsigned end_sec_cyl;
        unsigned long rel_sec;
        unsigned long size;
} PART_ENTRY;

/* Главная загрузочная запись */

typedef struct _MBOOT_ {
        char boot_prg[0x1be];
        PART_ENTRY part_table[4];
        unsigned char signature[2];
} MBOOT;

/* Расширенный блок параметров BIOS */

typedef struct _EBPB_ {
        unsigned sectsize;
        char clustsize;
        unsigned ressecs;
        char fatcnt;
        unsigned rootsize;
        unsigned totsecs;
        char media;
        unsigned fatsize;
        unsigned seccnt;
        unsigned headcnt;
        unsigned hiddensec_low;
        unsigned hiddensec_hi;
        unsigned long drvsecs;
} EBPB;

/* Загрузочная запись для MS-DOS 4.01 */

typedef struct _BOOT_ {
        char jmp[3];
        char oem[8];
        EBPB bpb;
        char drive;
        char reserved;
        char signature;
        unsigned volser_lo;
        unsigned volser_hi;
        char label[11];
        char fat_format[8];
        char boot_code[450];

} BOOT;

/* Время последнего обновления файла */

typedef struct _FTIME_ {
        unsigned sec : 5, min : 6, hour : 5;
} FTIME;

/* Дата последнего обновления файла */

typedef struct _FDATE_ {
        unsigned day : 5, month : 4, year : 7;
} FDATE;

/* Дескриптор файла в каталоге */

typedef struct _FITEM_ {
        char name[8];
        char ext[3];
        char attr;
        char reserved[10];
        FTIME time;
        FDATE date;
        unsigned cluster_nu;
        unsigned long size;
} FITEM;

/* Формат дорожки для GENERIC IOCTL */

typedef struct _TRK_LY_ {
        unsigned no;
        unsigned size;
} TRK_LY;

/* Параметры устройства для GENERIC IOCTL */

typedef struct _DPB_ {

        char spec;
        char devtype;
        unsigned devattr;
        unsigned numofcyl;
        char media_type;

        EBPB bpb;
        char reserved[6];

        unsigned trkcnt;
        TRK_LY trk[100];

} DPB;

/* Параметры для форматирования функцией GENERIC IOCTL */

typedef struct _DPB_FORMAT_ {

        char spec;
        unsigned head;
        unsigned track;

} DPB_FORMAT;


/* Параметры для чтения/записи функцией GENERIC IOCTL */

typedef struct _DPB_WR_ {

        char spec;
        unsigned head;
        unsigned track;
        unsigned sector;
        unsigned sectcnt;
        void _far *buffer;

} DPB_WR;

/* Идентификатор BIOS */

typedef struct _BIOS_ID_ {

        char date[8];
        unsigned reserve;
        char pc_type;

} BIOS_ID;



#pragma pack()



void far *get_cvt(void); /* получить адрес векторной таблицы связи */
CVT  far *get_mcvt(void); /* получить адрес векторной таблицы связи */

MCB  far *get_fmcb(CVT far *); /* получить адрес первого MCB */
MCB  far *get_nmcb(MCB far *); /* получить адрес следующего MCB */

DDCB  far *get_fddcb(CVT far *); /* получить адрес первого DDCB */
DDCB  far *get_nddcb(DDCB far *); /* получить адрес следующего DDCB */
DDCB  far *get_ddcb(unsigned char); /* получить адрес DDCB для диска */

DFT  far *get_fdft(CVT far *); /* получить адрес первой DFT */
DFT  far *get_ndft(DFT far *); /* получить адрес следующей DFT */

BCB  far *get_fbcb(CVT far *); /* получить адрес первого BCB */
BCB  far *get_nbcb(BCB far *); /* получить адрес следующего BCB */

int get_exeh(EXE_HDR *,RELOC_TAB **, FILE *); /* прочитать заголовок EXE */

char unsigned pc_model(void); /* получить модель компьютера */
void disk_cfg(DISK_CONFIG*);  /* определить конфигурацию
                                                        дисковой подсистемы */
DPT _far *get_dpt(void);      /* получить адрес DPT  */
HDPT _far *get_hdp1(void);      /* получить адрес первой HDPT  */
HDPT _far *get_hdp2(void);      /* получить адрес второй HDPT  */


BIOS_ID _far *getbiosi(void);   /* получить адрес идентификатора BIOS */

</font>
</pre>

<h2><a NAME="a7_5"><font SIZE="5" COLOR="#FF0000">7.5. Содержимое файла
sysp.inc</font></a></h2>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">;
; Это макроопределение печатает символы на экране
;
@@out_ch     MACRO c1,c2,c3,c4,c5,c6,c7,c8,c9,c10
                mov   ah,02h
                IRP   chr,&lt;c1,c2,c3,c4,c5,c6,c7,c8,c9,c10&gt;
                IFB   &lt;chr&gt;
                EXITM
                ENDIF
                mov   dl,chr
                int   21h
                ENDM
                ENDM

@@out_str MACRO
                mov   ah,9
                int   21h
                ENDM

</font>
</pre>

<h1><a NAME="a7_6"><font SIZE="5" COLOR="#800000">7.6. MS-DOS версии 5.0</font></a></h1>

<p>7.6.1. <a HREF="appendix.htm#a7_6_1">Новое в MS-DOS версии 5.0</a> </p>

<p>7.6.2. <a HREF="appendix.htm#a7_6_2">Изменения в векторной
таблице связи</a> </p>

<p>7.6.3. <a HREF="appendix.htm#a7_6_3">Управление памятью</a> </p>

<p>7.6.4. <a HREF="appendix.htm#a7_6_4">Управление программами</a> </p>

<p>7.6.5. <a HREF="appendix.htm#a7_6_5">Резидентные программы</a> </p>

<p>7.6.6. <a HREF="appendix.htm#a7_6_6">Драйверы</a> </p>

<p>7.6.7. <a HREF="appendix.htm#a7_6_7">Переключатель задач</a> </p>

<h2><a NAME="a7_6_1"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.1. Новое в MS-DOS версии 5.0</font></a></h2>

<p>Версия 5.0 операционной системы MS-DOS не
разочаровала пользователей компьютеров и
программистов. Преимущества столь значительны и
заметны, что уже не может быть оправдания для
приверженцев версии 3.30 или даже 4.01. Перечислим
только основные нововведения. 

<ul>
  <li>Возможность загрузки ядра DOS в так называемую
    верхнюю память. Эта память расположена за
    пределами первого мегабайта оперативной памяти,
    что позволяет выделить для программ
    пользователя до 630 (!) килобайт свободного
    пространства. </li>
  <li>При работе MS-DOS версии 5.0 на компьютере,
    оснащенном процессором <b>80386</b> или <b>80486</b>
    возможна выгрузка драйверов и резидентных
    программ в расширенную память. Для этого можно
    использовать драйвер <b>EMM386</b>. </li>
  <li>Новая диалоговая оболочка <b>DOSSHELL</b>
    обеспечивает переключение задач. Это еще не
    мультизадачность, так как все запущенные
    программы, кроме одной, приостанавливают свою
    работу и выгружаются на диск. В любой момент
    времени работает только одна программа,
    остальные ждут своей очереди на диске.
    Возможности переключателя задач будут
    рассмотрены в разделе &quot;Переключатель
    задач&quot;. </li>
  <li>Многие функции и прерывания MS-DOS, которые были
    недокументированы в предыдущих версиях,
    получили &quot;признание&quot;, отныне программисты
    могут использовать их на законных основаниях.
    Особенно это относится к функциям,
    обеспечивающим работу резидентных программ. </li>
  <li>Появились новые функции и новые возможности для
    программистов. Мы кратко рассмотрим наиболее
    полезные, на наш взгляд, новые функции MS-DOS в
    следующих разделах этой главы. </li>
</ul>

<p>Сразу отметим, что функция <b>30h</b> прерывания <b>INT&nbsp;21h</b>,
возвращающая версию MS-DOS, <b><i>может ввести вас в
заблуждение</i>.</b> Возможно, вы будете сильно
удивлены, когда в среде MS-DOS версии 5.0 эта функция
сообщит о том, что у вас MS-DOS версии 3.30 или даже 1.0.
Как это может быть? </p>

<p>В состав MS-DOS версии 5.0 входит драйвер <b>SETVER.EXE.</b>
Этот драйвер поддерживает список имен программ,
в котором каждому имени поставлен в соответствие
номер версии MS-DOS, возвращаемый функцией <b>30h</b>. </p>

<p>При запуске программы драйвер <b>SETVER.EXE </b>сверяет
ее имя со списком (который, кстати, вы можете
редактировать) и модифицирует соответствующим
образом обработчик функции <b>30h</b>. </p>

<p>Для чего потребовалось вводить программы в
заблуждение относительно используемой версии
MS-DOS? </p>

<p>Дело в том, что некоторые программы (а также
драйверы) рассчитаны на работу только в среде
конкретной версии MS-DOS, например, 4.00 или 4.01. На
самом деле эти программы будут правильно
работать и в MS-DOS версии 5.0. Но проверив версию,
такие программы часто завершают свое выполнение
с сообщением об ошибке в номере версии. </p>

<p>Вы можете получить список таких программ,
просто запустив<b> SETVER.EXE</b> как обычную программу. </p>

<p>Как же получить &quot;правильный&quot; номер версии
MS-DOS? </p>

<p>Для этого необходимо использовать функцию <b>3306h</b>
прерывания <b>INT&nbsp;21h.</b> </p>

<p>Приведем формат этой функции. </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288">3306h</td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="129"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>BH</b></td>
    <td WIDTH="288">Верхний (major) номер версии. </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>BL</b></td>
    <td WIDTH="288">Нижний (minor) номер версии. </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>DL</b></td>
    <td WIDTH="288">Биты 0..2 содержат номер изменения (revision),
    остальные биты равны 0. </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>DH</b></td>
    <td WIDTH="288">Флаги: <br>
    Бит 3 - DOS находится в ПЗУ;<br>
    Бит 4 - DOS загружен в старшие<br>
    адреса памяти (область HMA) </td>
  </tr>
</table>

<p>Функция <b>30h</b> в версии MS-DOS также претерпела
некоторые изменения. Если при вызове этой
функции в регистр <b>AL</b> записать значение <b>00h</b>,
все будет аналогично версиям 2.0-4.0. Если в <b>AL</b>
записать <b>01h</b>, после возврата регистр <b>BH</b>
будет содержать флаги, по которым можно судить о
расположении MS-DOS в ПЗУ или в старших адресах
памяти. </p>

<p>Приведем полный формат вызова функции <b>30h</b>
прерывания <b>INT&nbsp;21h</b>. </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AH</b></td>
    <td WIDTH="288">30h</td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AL</b></td>
    <td WIDTH="288"><b>00h</b> - получить код ОЕМ (код
    фирмы-изготовителя DOS) и версию DOS; <p><b>01h</b> -
    получить флаги расположения DOS. </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="129"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>AL</b></td>
    <td WIDTH="288">Верхний (major) номер версии. </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>AH</b></td>
    <td WIDTH="288">Нижний (minor) номер версии. </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>BX:CL</b></td>
    <td WIDTH="288">24-битовый серийный номер конкретного
    экземпляра MS-DOS </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>BH</b></td>
    <td WIDTH="288">Если при вызове функции AL был равен 0: <p>Код
    фирмы-изготовителя:</p>
    <p>00h - IBM;<br>
    05h - Zenith;<br>
    16h - DEC; <br>
    23h - Olivetti;<br>
    29h - Toshiba;<br>
    4Dh - Hewlett Packard;<br>
    99h - архитектура STARLITE;<br>
    FFh - Microsoft, Phoenix.</p>
    <p>Если при вызове функции AL был равен 1:</p>
    <p>08h - DOS расположен в ПЗУ; </p>
    <p>10h - DOS загружен в старшие адреса памяти (область
    HMA). </td>
  </tr>
</table>

<h2><a NAME="a7_6_2"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.2. Изменения в векторной таблице связи</font></a></h2>

<p>Формат векторной таблицы связи для MS-DOS версии
5.0 практически идентичен используемому версией
4.0. В этой таблице добавился указатель на список
программ, для которых драйвер <b>SETVER.EXE</b>
выполняет подстановку значения версии MS-DOS. </p>

<p>Приведем формат векторной таблицы связи для
MS-DOS версии 5.0: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="98"><b>(-02h) 2</b></td>
    <td WIDTH="127"><b>mcb_seg</b> </td>
    <td WIDTH="377">сегмент первого управляющего блока
    памяти (<b>MCB</b>) </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(00h) 4 </b></td>
    <td WIDTH="127"><b>dev_cb</b> </td>
    <td WIDTH="377">указатель на первый блок управления
    устройствами DOS (<b>DOS Device Control Block</b>) </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+04h) 4 </b></td>
    <td WIDTH="127"><b>file_tab</b> </td>
    <td WIDTH="377">указатель на таблицу файлов DOS</td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+08h) 4</b></td>
    <td WIDTH="127"><b>clock_dr</b> </td>
    <td WIDTH="377">указатель на драйвер <b>CLOCK$</b>,
    установленный или резидентный </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+0Ch) 4</b></td>
    <td WIDTH="127"><b>con_dr</b> </td>
    <td WIDTH="377">указатель на актуальный драйвер <b>CON</b>,
    установленный или резидентный </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+10h) 2 </b></td>
    <td WIDTH="127"><b>max_btbl</b> </td>
    <td WIDTH="377">максимальное число байт в блоке
    блочного устройства </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+12h) 4</b></td>
    <td WIDTH="127"><b>disk_buf</b> </td>
    <td WIDTH="377">указатель на структуру, описывающую
    дисковые буфера </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+16h) 4</b></td>
    <td WIDTH="127"><b>drv_info</b> </td>
    <td WIDTH="377">укзатель на массив информации об
    устройствах </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+1Ah) 4</b></td>
    <td WIDTH="127"><b>fcb_tabl</b> </td>
    <td WIDTH="377">указатель на таблицу <b>FCB</b></td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+1Eh) 2</b></td>
    <td WIDTH="127"><b>fcb_size</b> </td>
    <td WIDTH="377">размер таблицы <b>FCB, </b>для версии MS-DOS 5.0 в
    этом поле находится значение <b>00h</b> </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+20h) 1</b></td>
    <td WIDTH="127"><b>num_bdev</b> </td>
    <td WIDTH="377">число блочных устройств</td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+21h) 1</b></td>
    <td WIDTH="127"><b>lastdriv</b> </td>
    <td WIDTH="377">значение <b>LASTDRIVE</b> в файле <b>CONFIG.SYS </b>(по
    умолчанию равно 5) </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+22h) 18</b></td>
    <td WIDTH="127"><b>null_dr</b> </td>
    <td WIDTH="377">заголовок драйвера <b>NUL</b> - первого
    драйвера в списке драйверов DOS </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+34h) 1</b></td>
    <td WIDTH="127"><b>joined</b> </td>
    <td WIDTH="377">количество устройств, подсоединенных
    при помощи команды <b>JOIN</b> </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+35h) 2</b></td>
    <td WIDTH="127"><b>special_prg</b> </td>
    <td WIDTH="377">смещение внутри сегмента кода IBMDOS
    списка специальных программ, для MS-DOS 5.0 в этом
    поле находится <b>0000h</b> </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+ 37h) 4</b></td>
    <td WIDTH="127"><b>setver_list</b> </td>
    <td WIDTH="377">указатель на список программ, для
    которых драйвер <b>SETVER.EXE</b> выполняет подстановку
    значения версии MS-DOS </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+3Bh) 4</b></td>
    <td WIDTH="127"><b>internal_1</b> </td>
    <td WIDTH="377">используется MS-DOS</td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+3Fh) 2</b></td>
    <td WIDTH="127"><b>buffers_x</b> </td>
    <td WIDTH="377">значение x в команде <b>BUFFERS x,y</b></td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+41h) 2</b></td>
    <td WIDTH="127"><b>buffers_y</b> </td>
    <td WIDTH="377">значение y в команде <b>BUFFERS x,y</b></td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+43h) 1</b></td>
    <td WIDTH="127"><b>boot_drive</b> </td>
    <td WIDTH="377">номер дискового устройства,
    использованного для загрузки MS-DOS (<b>1</b> - <b>A:</b>) </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+44h) 1</b></td>
    <td WIDTH="127"><b>cpu_type</b> </td>
    <td WIDTH="377"><b>01h</b>, если используется процессор 80386
    или 80486, <b>00h</b> для 8086 - 80286. </td>
  </tr>
  <tr>
    <td WIDTH="98"><b>(+45h) 2</b></td>
    <td WIDTH="127"><b>extended_mem</b> </td>
    <td WIDTH="377">размер установленной расширенной
    памяти в килобайтах </td>
  </tr>
</table>

<h2><a NAME="a7_6_3"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.3. Управление памятью</font></a></h2>

<p>В MS-DOS версии 5.0 стал документирован блок
управления памятью <b>MCB</b>. Приведем формат этого
блока. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="80"><b>(00h) 1</b></td>
    <td WIDTH="455">Тип блока: <b>4Dh</b> для всех блоков, кроме
    последнего. Для последнего блока используется
    значение <b>5Ah</b>. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(01h) 2</b></td>
    <td WIDTH="455">Сегментный адрес блока <b>PSP</b>
    программы-владельца данного <b>MCB</b> или значение <b>0008h</b>
    для <b>MCB</b>, принадлежащего MS-DOS. Для свободного
    блока <b>MCB</b> в этом поле находится значение <b>0000h</b>.
    </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(03h) 2</b></td>
    <td WIDTH="455">Размер блока <b>MCB</b> в параграфах. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(05h) 3</b></td>
    <td WIDTH="455">Не используются. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(08h) 8</b></td>
    <td WIDTH="455">ASCII-имя программы-владельца блока <b>MCB</b>,
    если это блок <b>PSP</b>. </td>
  </tr>
</table>

<p>Самый первый блок <b>MCB</b> является сегментом
данных MS-DOS. Он делится на подсегменты, в которых
расположены драйверы, системные данные, буфера и
т.д. </p>

<p>Приведем формат управляющего блока
подсегмента для первого блока <b>MCB</b>. Этот
управляющий блок расположен непосредственно
перед соотвестсвующим ему подсегментом. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="80"><b>(00h) 1</b></td>
    <td WIDTH="477">Тип подсегмента: <p><b>&quot;D&quot;</b> - драйвер
    устройства;<br>
    <b>&quot;E&quot;</b> - расширение драйвера устройства;<br>
    <b>&quot;I&quot; </b>- драйвер инсталлируемой файловой
    системы <b>IFS</b>;<br>
    <b>&quot;F&quot;</b> - область памяти для управляющего
    блока оператора <b>&quot;FILES=&quot;</b>;<br>
    <b>&quot;X&quot;</b> - область памяти для управляющего
    блока оператора <b>&quot;FCBS=&quot;</b>;<br>
    <b>&quot;C&quot;</b> - рабочая область для буферов <b>EMS</b>,
    если используется оператор <b>&quot;BUFFERS /X&quot;</b>;<br>
    <b>&quot;B&quot; </b>- рабочая область для буферов, если
    используется оператор <b>&quot;BUFFERS&quot;</b>;<br>
    <b>&quot;L&quot;</b> - область памяти для массива структур
    текущих каталогов;<br>
    <b>&quot;S&quot;</b> - сегмент памяти для оператора <b>&quot;STACKS=&quot;</b>;<br>
    <b>&quot;T&quot; </b>- сегмент памяти для оператора <b>&quot;INSTALL=&quot;</b>.
    </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(01h) 2</b></td>
    <td WIDTH="477">Параграф, начиная с которого
    располагается данный подсегмент. Обычно это
    следующий за управляющим блоком параграф. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(03h) 2</b></td>
    <td WIDTH="477">Размер подсегмента в параграфах. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(05h) 3</b></td>
    <td WIDTH="477">Не используются. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(08h) 8</b></td>
    <td WIDTH="477">Для подсегментов <b>&quot;I&quot;</b> и <b>&quot;D&quot;</b>
    в этом поле находится имя файла, из которого был
    загружен драйвер. </td>
  </tr>
</table>

<p>Кроме рассмотренных выше, в MS-DOS версии 5.0
появился новый тип управляющего блока памяти - <b>UMCB</b>
- управляющий блок для верхней области памяти <b>UMB
</b>(Upper Memory Block): </p>

<table BORDER="1">
  <tr>
    <td WIDTH="80"><b>(00h) 1</b></td>
    <td WIDTH="457">Тип блока: <b>4Dh</b> для всех блоков, кроме
    последнего. Для последнего блока используется
    значение <b>5Ah</b>. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(01h) 2</b></td>
    <td WIDTH="457">Первый доступный в верхней памяти <b>UMB</b>
    параграф для самого первого блока <b>UMCB</b>, <b>000Ah</b> -
    если управляющий блок расположен в конце <b>UMB</b>. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(03h) 2</b></td>
    <td WIDTH="457">Размер блока <b>UMB</b> в параграфах. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(05h) 3</b></td>
    <td WIDTH="457">Не используются. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(08h) 8</b></td>
    <td WIDTH="457">Тип блока:<b> &quot;UMB&quot;</b> для начального
    блока, <b>&quot;SM&quot;</b> - для конечного. </td>
  </tr>
</table>

<p>Начиная с версии 3.0 MS-DOS содержит функцию <b>58h</b>
прерывания <b>INT&nbsp;21h</b>, позволяющую определять и
изменять <i><b>стратегию выделения памяти </b></i>запущенным
программам. В версии 5.0 добавились новые
возможности, в частности, возможность выделения
блоков верхней памяти, используемых только в MS-DOS
версии 5.0. </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="402"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AH</b></td>
    <td WIDTH="402"><b>58h</b></td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AL</b></td>
    <td WIDTH="402">Подфункция: <p><b>00h</b> - определить
    используемую стратегию;<br>
    <b>01h</b> - установить стратегию;<br>
    <b>02h</b> - получить состояние списка блоков верхней
    памяти <b>UMB</b>;<br>
    <b>03h</b> - установить состояние списка блоков
    верхней памяти <b>UMB</b>. </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BL</b></td>
    <td WIDTH="402"><i><b>Подфункция</b> <b>01h - новая стратегия:</b></i>
    <p><b>00h</b> - первым заполняется первый свободный
    участок в области младших адресов памяти;<br>
    <b>01h</b> - аналогично, но используется участок
    памяти, наилучшим образом подходящий для
    запроса;<br>
    <b>02h</b> - аналогично, но используется последний
    свободный участок памяти;<br>
    <br>
    <b>40h ,41h 42h</b> - аналогично <b>00h, 01h, 02h,</b> но
    используются старшие адреса памяти;<br>
    <br>
    <b>80h, 81h, 82h</b> - аналогично <b>00h, 01h, 02h</b>, но сначала
    делается попытка выделить старшие адреса памяти,
    а в случае неудачи - младшие. </p>
    <p><i><b>Подфункция</b> <b>03h - новое состояние списка
    блоков верхней памяти:</b></i> </p>
    <p><b>BX = 0000h</b> - удалить блоки <b>UMB</b> из списка блоков
    памяти DOS;<br>
    <b>BX = 0001h</b> - добавить блоки <b>UMB</b> в список блоков
    памяти DOS. </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BH</b></td>
    <td WIDTH="402"><i><b>Подфункция</b> <b>01h - новая стратегия:</b></i>
    <p>Равен <b>00h</b>. </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="129"><i><b>Регистр</b></i></td>
    <td WIDTH="406"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>AX</b></td>
    <td WIDTH="406"><i><b>Подфункция</b> <b>00h - определить
    стратегию:</b></i> <p><b>AX</b> = код используемой
    стратегии (см. выше). </p>
    <p><i><b>Подфункция</b> <b>02h - определитьсостояние
    списка блоков верхней памяти:</b></i> </p>
    <p><b>AL = 00h</b> - блоки <b>UMB</b> удалены из списка блоков
    памяти DOS;<br>
    <b>AL = 01h</b> - блоки <b>UMB</b> входят в список блоков
    памяти DOS. </td>
  </tr>
</table>

<p>В версии 5.0 MS-DOS появились функция для
непосредственного <i><b>выделения</b></i> программам <i><b>блоков
старшей памяти</b></i> <b>HMA</b>. Это функция <b>4A02h</b>: </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288">4A02h</td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BX</b></td>
    <td WIDTH="288">Размер выделяемого блока памяти в
    байтах (после возврата содержимое этого регистра
    будет уничтожено). </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="130"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="130"><b>ES:DI</b></td>
    <td WIDTH="288">Адрес выделенного блока памяти или <b>FFFF:FFFF</b>
    в случае неудачи. </td>
  </tr>
</table>

<p>Прежде чем пользоваться только что описанной
функцией, имеет смысл определить размер
свободной старшей памяти при помощи функции <b>4A01h</b>:
</p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288"><b>4A01h</b></td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BX</b></td>
    <td WIDTH="288">Размер доступной области старшей памяти
    в байтах или <b>0000h</b>, если DOS не использует область
    <b>HMA</b>. </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>ES:DI</b></td>
    <td WIDTH="288">Адрес начала доступной области старшей
    памяти или <b>FFFF:FFFF</b>, если DOS не использует
    область <b>HMA</b>. </td>
  </tr>
</table>

<h2><a NAME="a7_6_4"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.4. Управление программами</font></a></h2>

<p>В версии 5.0 MS-DOS появились некоторые новые
функции, имеющие отношение к управлению
программами. Например, функция <b>4B05h</b> прерывания
<b>INT&nbsp;21h </b>предназначена для подготовки
программы к выполнению. Эта функция может
использоваться программами, перехватывающими
функцию <b>4B00h</b> (обычный запуск программы),
например, для установки версии MS-DOS. </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288">4B05h</td>
  </tr>
  <tr>
    <td WIDTH="124"><b>DS:DX</b></td>
    <td WIDTH="288">Адрес управляющей структуры (см. ниже) </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="129"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="129"><b>AX</b></td>
    <td WIDTH="288"><b>00h</b>, если сброшен флаг <b>CF</b> и,
    соответственно, функция выполнилась без ошибок; <br>
    код ошибки, если установлен флаг <b>CF</b>. </td>
  </tr>
</table>

<p>Перед вызовом функции необходимо подготовить
управляющую структуру: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="80"><b>(00h) 2</b></td>
    <td WIDTH="457">Зарезервировано и равно <b>00h</b>. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(02h) 2</b></td>
    <td WIDTH="457">Флаги типа программы: <p>Бит <b>0</b> -
    программа типа <b>.EXE</b>;<br>
    Бит <b>1</b> - оверлей. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(04h) 4</b></td>
    <td WIDTH="457">Указатель на ASCII-имя файла с программой. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(08h) 2</b></td>
    <td WIDTH="457"><b>PSP</b> сегмента новой программы. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(0Ah) 4</b></td>
    <td WIDTH="457">Стартовый адрес <b>CS:IP</b> новой программы. </td>
  </tr>
  <tr>
    <td WIDTH="80"><b>(0Eh) 4</b></td>
    <td WIDTH="457">Размер программы с учетом <b>PSP</b>. </td>
  </tr>
</table>

<p>После возврата из этой функции до завершения
запущенной программы нельзя вызывать прерывания
DOS, BIOS или другие программные прерывания. Если MS-DOS
работает в верхней области памяти <b>HMA</b>, после
возврата из этой функции адресная линия <b>A20</b>
выключается . </p>

<p>Некоторые недокументированные функции
управления программами были <i><b>включены в
документацию</b></i> MS-DOS версии 5.0: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="106"><i><b>Функция</b></i></td>
    <td WIDTH="433"><i><b>Назначение</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="106"><b>50h</b></td>
    <td WIDTH="433">Установить <b>PSP</b> для текущей программы. </td>
  </tr>
  <tr>
    <td WIDTH="106"><b>51h</b></td>
    <td WIDTH="433">Получить <b>PSP</b> текущей программы. </td>
  </tr>
</table>

<h2><a NAME="a7_6_5"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.5. Резидентные программы</font></a></h2>

<p>К сожалению, версия 5.0 операционной системы MS-DOS
не порадовала разработчиков какими-либо новыми
возможностями в плане создания резидентных
программ. Это, в частности, говорит о
неперспективности данного класса программ.
Очевидно, что при наличии переключателя программ
и таких средств, как Microsoft Windows, обеспечивающих
одновременное (или псевдо-одновременное)
выполнение программ, актуальность резидентных
программ падает. </p>

<p>Но так как нельзя игнорировать большое
количество уже созданных (и достаточно удобных в
использовании) резидентных программ, все
недокументированные ранее возможности, без
которых невозможно создать правильно работающую
резидентную программу, стали
документированными. </p>

<p>Взяв на себя обязательства поддерживать эти
возможности, фирма Microsoft гарантирует, что и в
следующих версиях MS-DOS вы по-прежнему сможете
использовать свои старые добрые резидентные
программы. </p>

<h2><a NAME="a7_6_6"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.6. Драйверы</font></a></h2>

<p>Что касается драйверов устройств, то версия 5.0
операционной системы содержит расширения для
работы с командами общего ввода/вывода - <b>GENERIC</b> <b>IOCTL</b>.
</p>

<p>В заголовке драйвера в слове атрибутов
определен зарезервированный ранее бит <b>7</b>. Если
этот бит установлен в <b>1</b>, драйвер поддерживает
новую команду с кодом <b>19h</b>. Эта команда
позволяет операционной системе определить,
спосбен ли данный драйвер работать с командами
общего ввода/вывода (<b>GENERIC IOCTL</b>). </p>

<p>Для проверки возможности использования <b>GENERIC
IOCTL</b> программа может вызвать одну из двух новых
функций - <b>4410h</b> или <b>4411h</b>. Первая функция
определяет поддержку <b>GENERIC IOCTL</b> для устройства,
заданного своим индексом (<b>handle</b>), вторая - для
устройства, заданного своим адресом (номером). </p>

<p>Функция <b>4410h</b>: </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288"><b>4410h</b></td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BX</b></td>
    <td WIDTH="288">Индекс (<b>handle</b>) устройства. </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>CH</b></td>
    <td WIDTH="288">Код категории: <p><b>00h</b> неизвестное
    устройство<br>
    <b>01h</b> COMn: <br>
    <b>03h</b> CON<br>
    <b>05h</b> LPTn: </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>CL</b></td>
    <td WIDTH="288">Код функции, для которого необходимо
    выполнить проверку поддержки: <p><b>45h</b> установить
    счетчик повторов<br>
    <b>4Ah</b> выбрать кодовую страницу<br>
    <b>4Ch</b> начать подготовку кодовой страницы<br>
    <b>4Dh</b> завершить подготовку кодовой страницы<br>
    <b>5Fh</b> установить информацию для отображения<br>
    <b>65h</b> получить счетчик повторов<br>
    <b>6Ah</b> запросить выбранную кодовую страницу<br>
    <b>6Bh</b> запросить подготовленный список<br>
    <b>7Fh</b> получить информацию для отображения </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288"><b>0000h</b>, флаг <b>CF</b> сброшен - данная
    функция <b>GENERIC IOCTL</b> поддерживается драйвером. <p><b>xx01h</b>,
    флаг <b>CF</b> установлен в <b>1</b> - функция не
    поддерживается. </td>
  </tr>
</table>

<p>Функция <b>4411h</b>: </p>

<p><font COLOR="#FF0000">Регистры на входе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288"><b>4410h</b></td>
  </tr>
  <tr>
    <td WIDTH="124"><b>BL</b></td>
    <td WIDTH="288">Номер устройства. </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>CH</b></td>
    <td WIDTH="288">Код категории (<b>08h</b> - диск) </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>CL</b></td>
    <td WIDTH="288">Код функции, для которого необходимо
    выполнить проверку поддержки. </td>
  </tr>
</table>

<p><font COLOR="#FF0000">Регистры на выходе:</font> </p>

<table>
  <tr>
    <td WIDTH="124"><i><b>Регистр</b></i></td>
    <td WIDTH="288"><i><b>Содержимое</b></i> </td>
  </tr>
  <tr>
    <td WIDTH="124"><b>AX</b></td>
    <td WIDTH="288"><b>0000h</b>, флаг <b>CF</b> сброшен - данная
    функция <b>GENERIC IOCTL</b> поддерживается драйвером. <p><b>xx01h</b>,
    флаг <b>CF</b> установлен в <b>1</b> - функция не
    поддерживается. </td>
  </tr>
</table>

<h2><a NAME="a7_6_7"><font SIZE="5" COLOR="#FF0000" FACE="Arial">7.6</font><font SIZE="5"
COLOR="#FF0000">.7. Переключатель задач</font></a></h2>

<p>Переключатель задач, входящий в диалоговую
оболочку DOSSHELL - одно из значительных
усовершенствований MS-DOS версии 5.0. Этото
переключатель позволяет запустить на выполнение
одновременно несколько программ, хотя в
действительности работать будет только одна - та,
которая была запущена последней. Неактивные
программы выгружаются на диск. </p>

<p>Нажимая клавиши &lt;ALT-TAB&gt;, можно выбирать для
выполнения одну из запущенных программ. </p>

<p>Обратим ваше внимание на одну <i><b>потенциальную
опасность</b></i>, связанную с использованием
переключателя задач. </p>

<p>Предположим, что одна из запущенных вами
программ устанавливает собственный обработчик
какого-либо аппаратного прерывания. Например, вы
запустили телекоммуникационную программу и
работаете через модем с удаленным компьютером.
Не исключено, что ваша программа устанавливает
собственный обработчик аппаратного прерывания
от асинхронного порта, к которому подключен
модем. </p>

<p>Так как передача данных через модем - дело не
быстрое, у вас может появиться необходимость
выполнить на компьютере какую-либо другую
работу, например, отредактировать и распечатать
текст. Нет проблем, вы переключаетесь на
программу редактирования текстов. Но... компьютер
почему-то &quot;зависает&quot;. </p>

<p>А дело оказывается в том, что выгрузив
телекоммуникационную программу на диск,
переключатель задач &quot;оторвал&quot; обработчик
аппаратного прерывания асинхронного порта.
Прерывание пришло, а обработчика-то и нет! </p>

<p>Для пользователя в данной ситуации есть только
один выход - не использовать переключатель
программ совместно с телекоммуникационными
программами. </p>

<p>Однако программист имеет возможность учесть в
своих разработках присутствие переключателя
задач. Программа, определив наличие
переключателя, может либо отказаться от работы,
либо запретить переключение, если оно
затребовано в неподходящий момент времени, либо
выполнить перед переключением некоторые
&quot;замораживающие&quot; действия (например,
замаскировать аппаратное прерывание). Когда
программа вновь получит управление, она может
&quot;разморозиться&quot;. </p>

<p>Последний способ взаимодействия с
переключателем самый удобный. Он возможен
благодаря тому, что переключатель задач имеет
механизм, позволяющий известить работающую
программу о том, что затребовано переключение.<br>
<br>
</p>
</body>
</html>
