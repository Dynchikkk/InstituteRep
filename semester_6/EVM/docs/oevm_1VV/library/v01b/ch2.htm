<html>

<head>
<title>2. Логическая структура диска в DOS</title>
</head>

<body BGCOLOR="#ffffff">

<h2><font SIZE="5" COLOR="#FF0000">2. Логическая структура диска
в DOS</font></h2>

<p>2.1. <a HREF="ch2.htm#ch2_1">Таблица разделов и логические
диски</a> </p>

<p>2.2. <a HREF="ch2.htm#ch2_2">Загрузочная запись BOOT</a> </p>

<p>2.3. <a HREF="ch2.htm#ch2_3">Таблица размещения файлов</a> </p>

<p>2.4. <a HREF="ch2.htm#ch2_4">Файлы и каталоги</a> </p>

<p>2.5. <a HREF="ch2.htm#ch2_5">Программа FDISK и диск-менеджеры</a>
</p>

<p>До сих пор при работе с дисками мы не обращались
за помощью к DOS, выполняя все дисковые операции
либо на уровне команд ввода/вывода, либо на
уровне функций BIOS. Операционная система
предоставляет намного более удобные средства
для работы с диском, чем обращение к отдельным
секторам по их номеру, номерам дорожки и головки.
К сожалению, некоторые операции можно выполнить
только с помощью функций BIOS или даже только с
помощью непосредственного программирования
контроллера дисковода. </p>

<p>Если возможности DOS по обслуживанию диска вас
устраивают, то лучше пользоваться именно
функциями DOS - вам не придется заботиться о многих
мелочах и вы будете застрахованы от некоторых
ошибок. Есть и другие причины предпочтительного
использования функций DOS - ваша программа будет
меньше зависеть от типа и конфигурации
конкретной машины, так как дисковые драйверы DOS
скроют от вас многие детали и особенности
конкретной системы. </p>

<p>Мы будем изучать возможности DOS по управлению
дисковой подсистемой от простых функций ко все
более сложным, постепенно вводя все необходимые
определения. </p>

<h3><a NAME="ch2_1"><font SIZE="4" COLOR="#008000">2.1. Таблица разделов и
логические диски</font></a></h3>

<p>Персональный компьютер обычно комплектуется
одним или двумя НМД. Однако операционная система
позволяет вам разбивать НМД на части, причем
каждая часть будет рассматриваться DOS как
отдельный, &quot;логический&quot; диск. </p>

<p>Зачем нужно разбивать диск на логические диски?
</p>

<p>Первые персональные компьютеры IBM PC были
укомплектованы только НГМД. Дискеты позволяют
хранить относительно небольшие объемы
информации, поэтому делить флоппи-диск на части
не имеет смысла. Следующая модель компьютера -
IBM&nbsp;XT- имела жесткий диск объемом 10 или 20
мегабайт. Диск объемом 20 мегабайтов имели и
некоторые экземпляры IBM AT. При использовании
таких дисков и операционных систем MS-DOS версий до
3.20 у пользователей не возникало никаких проблем
и желания разбить диск относительно малого
объема на еще меньшие части. </p>

<p>Проблемы возникли, когда производители НМД
освоили выпуск дисков объемом 40 мегабайтов и
больше. Оказалось, что используемый DOS механизм
16-ти разрядной адресации секторов не позволяет
использовать диски объемом, большим, чем 32
мегабайта. </p>

<p>Операционная система MS-DOS версии 3.30 предложила
некоторый выход из создавшегося положения. С
помощью утилиты <b>FDISK</b> можно было разбить
физический диск на логические, каждый из которых
не должен превышать по объему 32 мегабайта. </p>

<p>Впоследствии в версиях 4.00 MS-DOS и 3.31 COMPAQ DOS
указанное выше ограничение на размер
логического диска было снято, однако схема
разделения физического диска на логические
полностью сохранилась. Существуют и другие
причины, по которым может быть полезно
разделение большого диска на части: 

<ul>
  <li>В случае повреждения логического диска
    пропадает только та информация, которая
    находилась на этом логическом диске. </li>
  <li>Реорганизация и выгрузка диска маленького
    размера проще и быстрее, чем большого. </li>
  <li>Возможно разделение дискового пространства
    между отдельными пользователями персонального
    компьютера. Такая практика &quot;коллективной&quot;
    работы на персональном компьютере очень
    распространена. </li>
  <li>При использовании специальных утилит для
    разбиения диска на части (диск-менеджеров)
    возможна установка для отдельных логических
    дисков защиты от записи. Вы можете записывать на
    такие диски неизменяющуюся информацию. Вред от
    программ-вирусов также будет меньше - вирус не
    сможет записать себя на защищенный диск. </li>
  <li>Один диск может содержать несколько различных
    операционных систем, расположенных в разных
    разделах диска. В ходе начальной загрузки вы
    можете указать раздел диска, из которого должна
    производиться загрузка операционной системы. </li>
</ul>

<p>По своей внутренней структуре логический диск
полностью соответствует дискете, поэтому
сначала мы изучим логическую структуру жесткого
диска, затем сделаем некоторые замечания,
касающиеся дискет. </p>

<p>Самый первый сектор жесткого диска (сектор 1,
дорожка 0, головка 0) содержит так называемую<b>
главную загрузочную запись</b> (Master Boot Record). Эта
запись занимает не весь сектор, а только его
начальную часть. Сама по себе главная
загрузочная запись является программой. Эта
программа во время начальной загрузки
операционной системы с жесткого диска
помещается по адресу <b>7C00:0000</b>, после чего ей
передается управление. Загрузочная запись
продолжает процесс загрузки операционной
системы. </p>

<p>В конце самого первого сектора жесткого диска
располагается <b>таблица разделов диска</b> (Partition
Table). Эта таблица содержит четыре элемента,
описывающих максимально четыре раздела диска. В
последних двух байтах сектора находится число <b>55AA</b>.
Это признак таблицы разделов. </p>

<p>Для просмотра и изменения содержимого таблицы
разделов жесткого диска используется утилита DOS <b>FDISK</b>,
или аналогичная утилита другой операционной
системы. </p>

<p>Что представляет из себя элемент таблицы
разделов диска? </p>

<p>Это структура размером 16 байтов, описывающая
часть диска, называемую разделом. В структуре
описаны границы раздела в терминах номеров
сектора, дорожки и головки, там располагается
информация о размере раздела в секторах и о
назначении раздела. Разделы диска могут быть
активными, активный раздел может быть
использован для загрузки операционной системы.
Заметьте, что диск может содержать одновременно
несколько активных разделов, которые могут
принадлежать разным операционным системам. </p>

<p>Приведем формат первого сектора жесткого
диска: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="98">Смещение</td>
    <td WIDTH="86">Размер</td>
    <td WIDTH="315">Содержимое </td>
  </tr>
  <tr>
    <td WIDTH="98">(+0)</td>
    <td WIDTH="86">1BEh</td>
    <td WIDTH="315">Загрузочная запись - программа, которая
    загружается и выполняется во время начальной
    загрузки операционной системы </td>
  </tr>
  <tr>
    <td WIDTH="98">(+1BEh)</td>
    <td WIDTH="86">10H</td>
    <td WIDTH="315">Элемент таблицы разделов диска </td>
  </tr>
  <tr>
    <td WIDTH="98">(+1CEh)</td>
    <td WIDTH="86">10H</td>
    <td WIDTH="315">Элемент таблицы разделов диска </td>
  </tr>
  <tr>
    <td WIDTH="98">(+1DEh)</td>
    <td WIDTH="86">10H</td>
    <td WIDTH="315">Элемент таблицы разделов диска </td>
  </tr>
  <tr>
    <td WIDTH="98">(+1EEh)</td>
    <td WIDTH="86">10H</td>
    <td WIDTH="315">Элемент таблицы разделов диска </td>
  </tr>
  <tr>
    <td WIDTH="98">(+1FEh)</td>
    <td WIDTH="86">2</td>
    <td WIDTH="315">Признак таблицы разделов - 55AAh </td>
  </tr>
</table>

<p>Все элементы таблицы разделов диска имеют
одинаковый формат: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="105">Смещение</td>
    <td WIDTH="86">Размер</td>
    <td WIDTH="304">Содержимое </td>
  </tr>
  <tr>
    <td WIDTH="105">(+0)</td>
    <td WIDTH="86">1</td>
    <td WIDTH="304">Признак активного раздела: <br>
    0 - раздел не активный; <br>
    80h - раздел активный. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+1)</td>
    <td WIDTH="86">1</td>
    <td WIDTH="304">Номер головки для начального сектора
    раздела. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+2)</td>
    <td WIDTH="86">2</td>
    <td WIDTH="304">Номер сектора и цилиндра для начального
    сектора раздела в формате функции чтения сектора
    INT&nbsp;13h. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+4)</td>
    <td WIDTH="86">1</td>
    <td WIDTH="304">Код системы: <br>
    0 - неизвестная система; <br>
    1, 4 - DOS; <br>
    5 - расширенный раздел DOS. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+5)</td>
    <td WIDTH="86">1</td>
    <td WIDTH="304">Номер головки для последнего сектора
    раздела. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+6)</td>
    <td WIDTH="86">2</td>
    <td WIDTH="304">Номер сектора и цилиндра для последнего
    сектора раздела в формате функции чтения сектора
    INT&nbsp;13h. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+8)</td>
    <td WIDTH="86">4</td>
    <td WIDTH="304">Относительный номер сектора начала
    раздела. </td>
  </tr>
  <tr>
    <td WIDTH="105">(+12)</td>
    <td WIDTH="86">4</td>
    <td WIDTH="304">Размер раздела в секторах. </td>
  </tr>
</table>

<p>В самом первом секторе активного раздела
расположена <b>загрузочная запись </b>(Boot Record),
которую не следует путать с главной загрузочной
записью (Master Boot Record). Загрузочная запись
считывается в оперативную память главной
загрузочной записью, после чего ей передается
управление. Загрузочная запись и выполняет
загрузку операционной системы. </p>

<p>Таким образом, загрузка операционной системы с
жесткого диска - двухступенчатый процесс.
Вначале модули инициализации BIOS считывают
главную загрузочную запись в память по адресу <b>7C00:0000</b>
и ей передается управление. Главная загрузочная
запись просматривает таблицу разделов и находит
активный раздел. Если активных разделов
несколько, на консоль выводится сообщение о
необходимости выбора активного раздела для
продолжения загрузки. </p>

<p>После того как активный раздел найден, главная
загрузочная запись считывает самый первый
сектор раздела в оперативную память. Этот сектор
содержит загрузочную запись, которой главная
загрузочная запись и передает управление. </p>

<p>Загрузочная запись активного раздела
выполняет загрузку операционной системы,
находящейся в активном разделе. </p>

<p>Такой двухступенчатый метод загрузки
операционной системы необходим по той причине,
что способ загрузки зависит от самой
операционной системы, поэтому каждая
операционная система имеет свой собственный
загрузчик. Фиксированным является только
расположение загрузочной записи - самый первый
сектор активного раздела. </p>

<p>Расскажем подробнее<i><b> о некоторых полях
элемента таблицы раздела диска.</b></i> </p>

<p>Байт со смещением 0, как мы уже говорили,
является флагом активного раздела и может
принимать одно из двух значений - <b>0</b> или <b>80h</b>
соответственно для неактивного и активного
разделов диска. </p>

<p>Двухбайтовое слово, расположенное со смещением
<b>8</b>, содержит относительный номер первого
сектора раздела. Как он вычисляется? </p>

<p>Значение <b>0</b> соответствует дорожке <b>0</b>,
головке 0<b>,</b> сектору <b>1</b>. При увеличении
относительного номера сектора вначале
увеличивается номер сектора на дорожке, затем
номер головки, и, наконец, номер дорожки. Для
вычисления относительного номера сектора можно
использовать следующую формулу: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">RelSect = (Cyl * Sect * Head) + (Head * Sect) + (Sect -1)</font>
</pre>

<p>В этой формуле: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Cyl  - номер дорожки;
Sect - номер сектора на дорожке;
Head - номер головки.</font>
</pre>

<p>Замечание, касающееся границ разделов диска:
обычно разделы начинаются с четных номеров
дорожек, за исключением самого первого раздела.
Этот раздел может начинаться с сектора <b>2</b>
нулевой дорожки (головка <b>0</b>), так как самый
первый сектор диска занят главной загрузочной
записью. </p>

<p>Байт со смещением <b>4</b> - это код системы,
использующей раздел диска. Для DOS
зарезервированы значения <b>0, 1, 4, 5</b>. </p>

<p>Значение <b>0</b> соответствует неиспользуемому
разделу диска. </p>

<p>Если код системы в элементе таблицы раздела
равен <b>1</b> или <b>4</b>, это означает, что раздел
используется DOS в качестве <b>первичного раздела</b>
(Primary Partition). Первичный раздел используется DOS как
логический диск. Этот раздел обычно является
активным и из него выполняется загрузка
операционной системы. В зависимости от того,
какой код системы используется для обозначения
первичного раздела DOS (1 или 4) меняется одна из
характеристик логического диска - размер
элемента таблицы размещения файлов (<b>FAT</b>). Код <b>1</b>
используется для обозначения 12-битовой <b>FAT</b>, 4 -
для <b>16</b>-битовой <b>FAT</b>. Таблица размещения
файлов будет описана ниже в этой главе. </p>

<p>Значение кода системы, равное <b>5</b>, обозначает <b>расширенный
раздел DOS</b> (Extended DOS Partiton). </p>

<p>Нетрудно заметить, что даже используя все
элементы таблицы разделов для создания
логических дисков, невозможно создать более
четырех дисков. А что делать с винчестерами
объемом 300 или 700 мегабайтов? Использование
расширенного раздела DOS позволит вам создать
любое количество логических дисков. Все эти
диски будут располагаться в пределах одного
расширенного раздела. </p>

<p>Утилита MS-DOS <b>FDISK</b> позволяет вам создать один
первичный раздел DOS и один расширенный раздел.
Первичный раздел должен быть активным, он
используется как диск <b>С:</b> и из него
выполняется загрузка операционной системы.
Расширенный раздел разбивается утилитой на
логические диски<b> D:, E:</b> и т.д. Расширенный
раздел не может быть активным, следовательно,
невозможно выполнить загрузку операционной
системы с логических дисков, расположенных в
этом разделе. </p>

<p>Если в элементе таблицы разделов байт кода
системы имеет значение <b>5</b>, то в начале раздела,
указанном в этом элементе, располагается сектор,
содержащий таблицу логических дисков.
Фактически эта таблица является расширением
таблицы разделов диска, расположенной в самом
первом секторе физического диска. Таблица
логических дисков имеет формат, аналогичный
таблице разделов диска, но имеет только два
элемента. Один из них указывает на первый сектор
логического диска DOS, он имеет код системы <b>1</b>
или <b>4</b>. Второй элемент может иметь код системы,
равный <b>5</b> или <b>0</b>. Если этот код равен <b>5</b>, то
элемент указывает на следующую таблицу
логических дисков. Если код системы равен <b>0</b>,
то соответствующий элемент не используется. </p>

<p>Из сказанного выше следует, что таблицы
логических дисков связаны в список, на начало
этого списка указывает элемент таблицы разделов
диска с кодом системы, равным <b>5</b>. </p>

<p>Для таблицы логических дисков имеется отличие
в использовании полей границ логических дисков:
если код системы равен <b>1</b> или 4<b>,</b> эти границы
вычисляются относительно начала расширенного
раздела; для элемента с кодом системы <b>5</b>
используется абсолютная адресация (относительно
физического начала диска). </p>

<p>Приведем конкретный пример. Пусть на диске
создано два раздела - первичный и расширенный.
Первичный раздел используется для загрузки MS-DOS
(диск <b>С:</b>), расширенный раздел содержит
логические диски <b>D:, E:, F:</b>. На рисунке показано
расположение разделов на диске: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+            
¦  ГЛАВНАЯ ЗАГРУЗОЧНАЯ ЗАПИСЬ  ¦            | Сектор главной
¦                              ¦            | загрузочной
¦                              ¦            | записи.
¦  Таблица разделов диска:     ¦            |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦            | Сектор 1,
¦  Элемент 1                   +­­­+        | дорожка 0,
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦        | головка 0.
¦  Элемент 2                   +­­­+­+      |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦ ¦      |
¦  Элемент 3                   ¦   ¦ ¦      |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦ ¦      |
¦  Элемент 4                   ¦   ¦ ¦      
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦ ¦      
¦                              +­­­+ ¦      | Диск С:
¦  ПЕРВИЧНЫЙ РАЗДЕЛ DOS        ¦     ¦      |
¦                              ¦     ¦      |
¦                              ¦     ¦      |
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦     ¦      
¦  РАСШИРЕННЫЙ РАЗДЕЛ DOS      +­­­­­+
¦                              ¦            | Сектор
¦                              ¦            | таблицы
¦                              ¦            | логических
¦  Таблица логических дисков:  ¦            | дисков
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦            |
¦  Элемент 1                   +­­­+        |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦        |
¦  Элемент 2                   +­­­+­+      
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦ ¦
¦  ЛОГИЧЕСКИЙ ДИСК             +­­­+ ¦      | Диск D:
¦                              ¦     ¦      |
¦                              ¦     ¦
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦     ¦
¦  РАСШИРЕННЫЙ РАЗДЕЛ DOS      +­­­­­+
¦                              ¦            | Сектор
¦                              ¦            | таблицы
¦                              ¦            | логических
¦  Таблица логических дисков:  ¦            | дисков
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦            |
¦  Элемент 1                   +­­­+        |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦        |
¦  Элемент 2                   +­­­+­+      
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦ ¦
¦  ЛОГИЧЕСКИЙ ДИСК             +­­­+ ¦      | Диск E:
¦                              ¦     ¦      |
¦                              ¦     ¦      |
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦     ¦
¦  РАСШИРЕННЫЙ РАЗДЕЛ DOS      +­­­­­+
¦                              ¦            | Сектор
¦                              ¦            | таблицы
¦                              ¦            | логических
¦  Таблица логических дисков:  ¦            | дисков
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦            |
¦  Элемент 1                   +­­­+        |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦        |
¦  Элемент 2                   ¦   ¦
¦­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­¦   ¦  
¦  ЛОГИЧЕСКИЙ ДИСК             +­­­+        | Диск F:
¦                              ¦            |
¦                              ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>Операционная система не предоставляет
программам никаких средств для работы с главной
загрузочной записью и таблицей разделов диска.
Мы постараемся восполнить этот недостаток,
подготовив свои функции для работы с этими
данными. </p>

<p>Файл <b>sysp.h</b> содержит определения типов для
главной загрузочной записи и таблицы разделов
диска: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

/* Элемент таблицы разделов */

typedef struct _PART_ENTRY_ {
        unsigned char flag;
        unsigned char beg_head;
        unsigned beg_sec_cyl;
        unsigned char sys;
        unsigned char end_head;
        unsigned end_sec_cyl;
        unsigned long rel_sec;
        unsigned long size;
} PART_ENTRY;


/* Главная загрузочная запись */

typedef struct _MBOOT_ {
        char boot_prg[0x1be];
        PART_ENTRY part_table[4];
        unsigned char signature[2];
} MBOOT;

#pragma pack()</font>
</pre>

<p>Для того, чтобы прочитать главную загрузочную
запись для одного из установленных в компьютере
НМД, вы можете использовать следующую функцию: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      getmboot
*
*.Title     Считать главную загрузочную запись
*
*.Descr     Функция считывает главную загрузочную запись
*           для указанного НМД.
*
*.Params    int getmboot(MBOOT *master_boot, int drive);
*
*           master_boot - указатель на буфер, в который
*                         будет считана главная загрузочная
*                         запись
*
*           drive       - номер физического НМД
*                         (0 - первый НМД, 1 - второй,...)
*
*.Return    0 - если главная загрузочная запись считана
*               успешно;
*           Код ошибки, полученный от функции BIOS &quot;Чтение
*               сектора&quot; - если чтение главной загрузочной
*               записи выполнить невозможно.
**/

#include &lt;stdio.h&gt;
#include &lt;bios.h&gt;
#include &quot;sysp.h&quot;

int getmboot(MBOOT *master_boot, int drive) {

         struct diskinfo_t di;
         int status;

// Подготавливаем структуру для чтения
// главной загрузочной записи

         di.drive = drive | 0x80;
         di.head     = 0;
         di.track    = 0;
         di.sector   = 1;
         di.nsectors = 1;
         di.buffer   = (char*)master_boot;

// Читаем сектор, содержащий главную
// загрузочную запись

         status = _bios_disk( _DISK_READ, &amp;di ) &gt;&gt; 8;

         return(status);
}</font>
</pre>

<p>Как пример использования этой функции приведем
текст программы, определяющей количество
установленных в системе дисков и выводящей на
экран для каждого диска содержимое таблицы
разделов. В программе используется функция <b>disk_cfg()</b>,
определяющая конфигурацию дисковой подсистемы. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

  DISK_CONFIG cfg;
  MBOOT mb;
  int i,j, k, status;

  printf(&quot;\n&quot;
                &quot;\nТаблицы разделов диска&quot;
                &quot;\n  (C)Фролов А., 1991&quot;
                &quot;\n&quot;);

// Определяем конфигурацию дисковой подсистемы

  disk_cfg(&amp;cfg);

// Записываем в переменную i количество
// установленных в системе НМД

  j = cfg.n_hard;
  printf(&quot;\nУстановлено дисков: %d&quot;, j);

// Для каждого НМД выводим содержимое
// таблицы разделов

  for(i=0;i&lt;j;i++) {

// Читаем главную загрузочную запись

        status = getmboot(&amp;mb,i);
        if(status != 0) {
                printf(&quot;\nОшибка чтения диска %d, код ошибки: %d&quot;,
                                i, status);
                exit(1);
        }

        printf(&quot;\n\nТаблица разделов диска %d&quot;,i);
        printf(&quot;\n&quot;

&quot;\n------------------------------------------------------------&quot;
&quot;\n|Флаг|Начало раздела |Конец раздела  |Код  |Размер |Отн.   |&quot;
&quot;\n|    |---------------|---------------|сист.|раздела|номер  |&quot;
&quot;\n|    |Гол.|Сект.|Цил.|Гол.|Сект.|Цил.|     |       |сектора|&quot;
&quot;\n|----|----|-----|----|----|-----|----|-----|-------|-------|&quot;
&quot;\n&quot;);

        for(k=0; k&lt;4; k++) {
                printf(&quot;|%3d |%4d|%4d |%4d|%4d|%4d |%4d|%5d|%7u|&quot;,
                mb.part_table[k].flag,
                mb.part_table[k].beg_head,
                mb.part_table[k].beg_sec_cyl &amp; 0x3f,
                (mb.part_table[k].beg_sec_cyl &gt;&gt; 6) &amp; 0x3ff,
                mb.part_table[k].end_head,
                mb.part_table[k].end_sec_cyl &amp; 0x3f,
                (mb.part_table[k].end_sec_cyl &gt;&gt; 6) &amp; 0x3ff,
                mb.part_table[k].sys,
                mb.part_table[k].size);
                printf(&quot;%7u|\n&quot;,
                        mb.part_table[k].rel_sec);
        }
        printf(&quot;------------------------------------------------------------&quot;);
  }
}</font>
</pre>

<h3><a NAME="ch2_2"><font SIZE="4" COLOR="#008000">2.2. Загрузочная
запись BOOT</font></a></h3>

<p>Самый первый сектор логического диска (и самый
первый сектор на системной дискете) занимает <b>загрузочная
запись</b> (Boot Record). Эта запись считывается из
активного раздела диска программой <b>главной
загрузочной записи </b>(Master Boot Record) и запускается
на выполнение. Задача загрузочной записи -
выполнить загрузку операционной системы. Каждый
тип операционной системы имеет свою загрузочную
запись. Даже для разных версий одной и той же
операционной системы программа загрузки может
выполнять различные действия. </p>

<p>Кроме программы начальной загрузки
операционной системы в загрузочной записи
находятся параметры, описывающие характеристики
данного логического диска. Все эти параметры
располагаются в самом начале сектора, в его так
называемой форматированной области. Формат этой
области разный для DOS версий до 4.0 и версии 4.0. </p>

<p>Сначала приведем формат записи <b>BOOT</b> для DOS
версий, более ранних, чем 4.0. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="97">Смещение</td>
    <td WIDTH="97">Размер</td>
    <td WIDTH="292">Содержимое </td>
  </tr>
  <tr>
    <td WIDTH="97">(+0)</td>
    <td WIDTH="97">3</td>
    <td WIDTH="292">Команда JMP xxxx - переход типа NEAR на
    программу начальной загрузки </td>
  </tr>
  <tr>
    <td WIDTH="97">(+3)</td>
    <td WIDTH="97">8</td>
    <td WIDTH="292">Название фирмы-производителя
    операционной системы и версия, например: &quot;IBM
    5.0&quot; </td>
  </tr>
  <tr>
    <td WIDTH="97">(+11)</td>
    <td WIDTH="97">13</td>
    <td WIDTH="292">BPB - блок параметров <u>BIOS</u>BIOS </td>
  </tr>
  <tr>
    <td WIDTH="97">(+24)</td>
    <td WIDTH="97">2</td>
    <td WIDTH="292">Количество секторов на дорожке </td>
  </tr>
  <tr>
    <td WIDTH="97">(+26)</td>
    <td WIDTH="97">2</td>
    <td WIDTH="292">Количество головок (поверхностей диска) </td>
  </tr>
  <tr>
    <td WIDTH="97">(+28)</td>
    <td WIDTH="97">2</td>
    <td WIDTH="292">Количество скрытых секторов, эти
    сектора могут использоваться для схемы
    разбиения физического диска на разделы </td>
  </tr>
</table>

<p>В самом начале <b>BOOT</b>-сектора располагается
команда внутрисегментного перехода <b>JMP</b>. Она
нужна для обхода форматированной зоны сектора и
передачи управления загрузочной программе,
располагающейся со смещением <b>(+30).</b> </p>

<p>Название фирмы-производителя не используется
операционной системой. </p>

<p>Со смещением<b> (+11)</b> располагается <b>BPB</b> - блок
параметров BIOS, о котором мы уже говорили в
разделах книги, посвященных драйверам. Этот блок
содержит некоторые характеристики логического
диска, о которых мы будем говорить немного позже
и используется дисковыми драйверами. Для DOS
версий до 4.0 <b>BPB</b> имеет следующий формат: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">(0)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="94">sect_siz </td>
    <td WIDTH="299">Количество байтов в одном секторе диска.</td>
  </tr>
  <tr>
    <td WIDTH="48">(+2)</td>
    <td WIDTH="48">1</td>
    <td WIDTH="94">clustsiz </td>
    <td WIDTH="299">Количество секторов в одном кластере.</td>
  </tr>
  <tr>
    <td WIDTH="48">(+3)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="94">res_sect </td>
    <td WIDTH="299">Количество зарезервированных секторов.</td>
  </tr>
  <tr>
    <td WIDTH="48">(+5)</td>
    <td WIDTH="48">1</td>
    <td WIDTH="94">fat_cnt </td>
    <td WIDTH="299">Количество таблиц FAT.</td>
  </tr>
  <tr>
    <td WIDTH="48">(+6)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="94">root_siz </td>
    <td WIDTH="299">Максимальное количество дескрипторов
    файлов, содержащихся в корневом каталоге диска. </td>
  </tr>
  <tr>
    <td WIDTH="48">(+8)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="94">tot_sect </td>
    <td WIDTH="299">Общее количество секторов на носителе
    данных (в разделе DOS). </td>
  </tr>
  <tr>
    <td WIDTH="48">(+10) </td>
    <td WIDTH="48">1</td>
    <td WIDTH="94">media </td>
    <td WIDTH="299">Байт-описатель среды носителя данных.</td>
  </tr>
  <tr>
    <td WIDTH="48">(+11) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="94">fat_size </td>
    <td WIDTH="299">Количество секторов, занимаемых одной
    копией FAT. </td>
  </tr>
</table>

<p>Поля <b>BOOT</b>-сектора со смещениями <b>24</b> и <b>26</b>
содержат соответственно количество секторов на
дорожке и количество головок в дисководе. Поле со
смещением <b>28</b> содержит количество
&quot;скрытых&quot; секторов, которые не принадлежат
ни одному логическому диску. Эти сектора могут
содержать основную или вторичные таблицы
разделов диска. </p>

<p>Для MS-DOS версии 4.0 <b>BOOT</b>-сектор имеет другой
формат: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="96">Смещение</td>
    <td WIDTH="95">Размер</td>
    <td WIDTH="294">Содержимое </td>
  </tr>
  <tr>
    <td WIDTH="96">(+0)</td>
    <td WIDTH="95">3</td>
    <td WIDTH="294">Команда JMP xxxx - переход типа NEAR на
    программу начальной загрузки </td>
  </tr>
  <tr>
    <td WIDTH="96">(+3)</td>
    <td WIDTH="95">8</td>
    <td WIDTH="294">Название фирмы-производителя
    операционной системы и версия, например: &quot;IBM
    4.0&quot; </td>
  </tr>
  <tr>
    <td WIDTH="96">(+11)</td>
    <td WIDTH="95">25</td>
    <td WIDTH="294">Extended BPB - расширенный блок параметров <u>BIOS</u>BIOS
    </td>
  </tr>
  <tr>
    <td WIDTH="96">(+36)</td>
    <td WIDTH="95">1</td>
    <td WIDTH="294">Физический номер дисковода (0 -флоппи, 80h -
    жесткий диск) </td>
  </tr>
  <tr>
    <td WIDTH="96">(+37)</td>
    <td WIDTH="95">1</td>
    <td WIDTH="294">Зарезервировано </td>
  </tr>
  <tr>
    <td WIDTH="96">(+38)</td>
    <td WIDTH="95">1</td>
    <td WIDTH="294">Символ ')' - признак расширенной
    загрузочной записи DOS 4.0 </td>
  </tr>
  <tr>
    <td WIDTH="96">(+39)</td>
    <td WIDTH="95">4</td>
    <td WIDTH="294">Серийный номер диска (Volume Serial Number),
    создается во время форматирования диска </td>
  </tr>
  <tr>
    <td WIDTH="96">(+43)</td>
    <td WIDTH="95">11</td>
    <td WIDTH="294">Метка диска (Volume Label) </td>
  </tr>
  <tr>
    <td WIDTH="96">(+54)</td>
    <td WIDTH="95">8</td>
    <td WIDTH="294">Зарезервировано, обычно содержит запись
    типа 'FAT12 ', которая идентифицирует формат таблицы
    размещения файлов FAT </td>
  </tr>
</table>

<p>Первые два поля в <b>BOOT</b>-секторе для DOS 4.0
аналогичны описанным раньше. </p>

<p>Поле со смещением <b>(+38)</b> всегда содержит
символ ')'. Этот символ означает, что используется
формат расширенной загрузочной записи
операционной системы MS-DOS 4.0. </p>

<p>Серийный номер диска формируется во время
форматирования диска на основе даты и времени
форматирования. Это поле может быть использовано
для определения факта замены диска в дисководе. </p>

<p>Метка диска формируется при форматировании и
может быть изменена командой операционной
системы <b>LABEL</b>. Одновременно метка диска
помещается в корневой каталог. </p>

<p>Поле со смещением <b>11</b> содержит расширенный
блок параметров BIOS. Он состоит из обычного <b>BPB</b>
и дополнительного расширения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="67">(0)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">sect_siz </td>
    <td WIDTH="316">Количество байтов в одном секторе диска.</td>
  </tr>
  <tr>
    <td WIDTH="67">(+2)</td>
    <td WIDTH="48">1</td>
    <td WIDTH="88">clustsiz </td>
    <td WIDTH="316">Количество секторов в одном кластере.</td>
  </tr>
  <tr>
    <td WIDTH="67">(+3)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">res_sect </td>
    <td WIDTH="316">Количество зарезервированных секторов.</td>
  </tr>
  <tr>
    <td WIDTH="67">(+5)</td>
    <td WIDTH="48">1</td>
    <td WIDTH="88">fat_cnt </td>
    <td WIDTH="316">Количество таблиц FAT.</td>
  </tr>
  <tr>
    <td WIDTH="67">(+6)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">root_siz </td>
    <td WIDTH="316">Максимальное количество дескрипторов
    файлов, содержащихся в корневом каталоге диска. </td>
  </tr>
  <tr>
    <td WIDTH="67">(+8)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">tot_sect </td>
    <td WIDTH="316">Общее количество секторов на носителе
    данных (в разделе DOS). </td>
  </tr>
  <tr>
    <td WIDTH="67">(+10) </td>
    <td WIDTH="48">1</td>
    <td WIDTH="88">media </td>
    <td WIDTH="316">Байт-описатель среды носителя данных.</td>
  </tr>
  <tr>
    <td WIDTH="67">(+11) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">fat_size </td>
    <td WIDTH="316">Количество секторов, занимаемых одной
    копией FAT. </td>
  </tr>
  <tr>
    <td WIDTH="67">&nbsp;</td>
    <td WIDTH="48">&nbsp;</td>
    <td WIDTH="88">&nbsp;</td>
    <td WIDTH="316"><i>---- Расширение стандартного BPB -----</i> </td>
  </tr>
  <tr>
    <td WIDTH="67">(+13) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">sectors </td>
    <td WIDTH="316">Количество секторов на дорожке</td>
  </tr>
  <tr>
    <td WIDTH="67">(+15) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">heads </td>
    <td WIDTH="316">Количество магнитных головок</td>
  </tr>
  <tr>
    <td WIDTH="67">(+17) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">hidden_l </td>
    <td WIDTH="316">Количество скрытых секторов для
    раздела, который по размеру меньше 32 мегабайтов. </td>
  </tr>
  <tr>
    <td WIDTH="67">(+19) </td>
    <td WIDTH="48">2</td>
    <td WIDTH="88">hidden_h </td>
    <td WIDTH="316">Количество скрытых секторов для
    раздела, превышающего по размеру 32 мегабайта.
    (Только для DOS 4.0). </td>
  </tr>
  <tr>
    <td WIDTH="67">(+21) </td>
    <td WIDTH="48">4</td>
    <td WIDTH="88">tot_secs </td>
    <td WIDTH="316">Общее количество секторов на логическом
    диске для раздела, превышающего по размеру 32
    мегабайта. </td>
  </tr>
</table>

<p>Как обычный, так и расширенный блок параметров
BIOS содержит байт-описатель среды <b>media</b>. Этот
байт может служить для идентификации носителя
данных и может содержать следующие величины,
характеризующие носитель данных по количеству
сторон диска и количеству секторов на дорожке: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="59">FFh</td>
    <td WIDTH="327">2 стороны, 8 секторов на дорожке; </td>
  </tr>
  <tr>
    <td WIDTH="59">FEh</td>
    <td WIDTH="327">1 сторона, 8 секторов на дорожке; </td>
  </tr>
  <tr>
    <td WIDTH="59">FDh</td>
    <td WIDTH="327">2 стороны, 9 секторов на дорожке; </td>
  </tr>
  <tr>
    <td WIDTH="59">FCh</td>
    <td WIDTH="327">1 сторона, 9 секторов на дорожке; </td>
  </tr>
  <tr>
    <td WIDTH="59">F9h</td>
    <td WIDTH="327">2 стороны, 15 секторов на дорожке; </td>
  </tr>
  <tr>
    <td WIDTH="59">F8h</td>
    <td WIDTH="327">жесткий диск.</td>
  </tr>
</table>

<p>Мы не будем рассматривать восьмидюймовые
дискеты, которые используют значения <b>FEh</b> и <b>FDh</b>
байта описателя среды, так как такие дискеты
используются крайне редко. </p>

<p>Прежде чем мы продолжим изучение логической
структуры диска, покажем, как программа может
обратиться к <b>BOOT</b>-сектору. </p>

<p>DOS предоставляет программе возможность работы
с так называемыми логическими номерами секторов.
Это номера секторов внутри логического диска. </p>

<p>Вы знаете, что для адресации сектора при помощи
функций BIOS необходимо указывать номер дорожки,
номер головки и номер сектора на дорожке. DOS
организует &quot;сквозную&quot; нумерацию секторов,
при которой каждому сектору логического диска
присваивается свой уникальный номер. Порядок
нумерации выбран таким, что при последовательном
увеличении номера сектора вначале увеличивается
номер головки, затем номер дорожки. Это сделано
для сокращения перемещений блока головок при
обращении к последовательным логическим номерам
секторов. </p>

<p>Пусть, например, у нас есть дискета с девятью
секторами на дорожке. Сектор с логическим
номером, равным 1, расположен на нулевой дорожке и
для обращения к нему используется нулевая
головка. Это самый первый сектор на дорожке, в
терминах BIOS он имеет номер 1. Следующий сектор на
нулевой дорожке имеет логический номер 2,
последний сектор на нулевой дорожке имеет
логический номер 9. Сектор с логическим номером 10
расположен также на нулевой дорожке. Это тоже
самый первый сектор на дорожке, но теперь для
доступа к нему используется головка с номером 1. И
так далее, по мере увеличения логического номера
сектора изменяются номера головок и дорожек. </p>

<p>Для работы с логическим диском (или дискетой) на
уровне логических номеров секторов DOS
предоставляет программам два прерывания - <b>INT&nbsp;25h</b>
(чтение сектора по его логическому номеру) и<b>
INT&nbsp;26h</b> (запись сектора по его логическому
номеру). Вызов этих прерываний имеет различный
формат для разных версий DOS. Для тех версий,
которые не поддерживают размер логических
дисков более 32 М (MS-DOS 3.10, 3.20, 3.30) используется
следующий формат: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">INT&nbsp;25h - Чтение сектора по его логическому номеру</font>
</pre>

<table>
  <tr>
    <td WIDTH="120">На входе:</td>
    <td WIDTH="367">AL = Адрес дисковода (0 - A, 1 - B, ...) </td>
  </tr>
  <tr>
    <td WIDTH="120"></td>
    <td WIDTH="367">CX = Количество секторов, которые нужно
    прочитать </td>
  </tr>
  <tr>
    <td WIDTH="120"></td>
    <td WIDTH="367">DX = Логический номер начального сектора </td>
  </tr>
  <tr>
    <td WIDTH="120"></td>
    <td WIDTH="367">DS:BX = Адрес буфера для чтения </td>
  </tr>
  <tr>
    <td WIDTH="120">На выходе:</td>
    <td WIDTH="367">AH = Код ошибки при неуспешном завершении
    операции </td>
  </tr>
  <tr>
    <td WIDTH="120"></td>
    <td WIDTH="367">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
</table>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">INT&nbsp;26h - Запись сектора по его логическому номеру</font>
</pre>

<table>
  <tr>
    <td WIDTH="122">На входе:</td>
    <td WIDTH="365">AL = Адрес дисковода (0 - A, 1 - B, ...) </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="365">CX = Количество секторов, которые нужно
    записать </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="365">DX = Логический номер начального сектора </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="365">DS:BX = Адрес буфера, сожержащего
    записываемые данные </td>
  </tr>
  <tr>
    <td WIDTH="122">На выходе:</td>
    <td WIDTH="365">AH = Код ошибки при неуспешном завершении
    операции </td>
  </tr>
  <tr>
    <td WIDTH="122"></td>
    <td WIDTH="365">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
</table>

<p>Для версий DOS MS-DOS 4.0 и COMPAQ DOS 3.31 используется
другой способ задания номера логического
сектора. Так как шестнадцати разрядов регистра
недостаточно для адресации диска размером более
32М, то при работе с расширенным разделом диска
(т.е. с разделом диска, занимающим более 32
мегабайтов) при вызове этих прерываний регистры
используются по-другому. </p>

<p>Регистр <b>CX</b> содержит <b>FFFFh</b> - признак того,
что работа будет производится с логическим
диском, имеющим размер более 32 мегабайтов. </p>

<p>Регистры <b>DS:BX</b> содержат адрес управляющего
блока: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">(0)</td>
    <td WIDTH="48">4</td>
    <td WIDTH="389">Начальный номер логического сектора </td>
  </tr>
  <tr>
    <td WIDTH="48">(+4)</td>
    <td WIDTH="48">2</td>
    <td WIDTH="389">Количество секторов для чтения/записи </td>
  </tr>
  <tr>
    <td WIDTH="48">(+6)</td>
    <td WIDTH="48">4</td>
    <td WIDTH="389">FAR-адрес буфера для передачи данных </td>
  </tr>
</table>

<p>Так как для задания начального номера
логического сектора в этом управляющем блоке
отводится 4 байта, то снимается 32-мегабайтное
ограничение на размер логического диска. </p>

<p>Очень важное замечание, касающееся только что
рассмотренных прерываний DOS. Эти прерывания
оставляют в стеке одно слово - старое значение
регистра флагов. Поэтому после вызова прерывания
должна следовать, например, такая команда: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">pop ax</font>
</pre>

<p>Содержимое <b>BOOT</b>-сектора может быть
использовано для определения общего количества
секторов на логическом диске (например, в
программах проверки читаемости секторов диска),
для работы с таблицей размещения файлов <b>FAT</b>, о
которой мы будем говорить ниже, для определения
других характеристик логического диска. </p>

<p>Для работы с загрузочной записью мы
подготовили структуры, описывающие расширенный
блок параметров BIOS <b>EBPB</b> и собственно
загрузочную запись <b>BOOT</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

/* Расширенный блок параметров BIOS */

typedef struct _EBPB_ {
        unsigned sectsize;
        char clustsize;
        unsigned ressecs;
        char fatcnt;
        unsigned rootsize;
        unsigned totsecs;
        char media;
        unsigned fatsize;
        unsigned seccnt;
        unsigned headcnt;
        unsigned hiddensec_low;
        unsigned hiddensec_hi;
        unsigned long drvsecs;
} EBPB;

/* Загрузочная запись для MS-DOS 4.01 */

typedef struct _BOOT_ {
        char jmp[3];
        char oem[8];
        EBPB bpb;
        char drive;
        char reserved;
        char signature;
        unsigned volser_lo;
        unsigned volser_hi;
        char label[11];
        char fat_format[8];
        char boot_code[450];

} BOOT;

#pragma pack()</font>
</pre>

<p>Поле серийного номера диска разбито на две
компоненты - <b>volser_lo</b> и <b>volser_hi</b>. Это сделано для
облегчения представления серийного номера в
виде, аналогичном используемому командой DIR
операционной системы MS-DOS 4.0. </p>

<p>Для чтения загрузочной записи логического
диска вы можете использовать следующую функцию: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      getboot
*
*.Title     Считать загрузочную запись
*
*.Descr     Функция считывает загрузочную запись
*           для указанного НМД.
*
*.Params    int getmboot(BOOT _far *boot, int drive);
*
*           boot        - указатель на буфер, в который
*                         будет считана загрузочная
*                         запись
*
*           drive       - номер физического НМД
*                         (0 - первый НМД, 1 - второй,...)
*
*.Return    0 - если загрузочная запись считана
*               успешно;
*           1 - произошла ошибка
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

int getboot(BOOT *boot, int drive) {

         union REGS reg;
         struct SREGS segreg;

// Заполняем регистровые структуры для вызова
// прерывания DOS INT 25h

         reg.x.ax = drive;
         reg.x.bx = FP_OFF(boot);
         segreg.ds = FP_SEG(boot);
         reg.x.cx = 1;
         reg.x.dx = 0;
         int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);

// Извлекаем из стека оставшееся там после
// вызова прерывания слово

         _asm pop ax

         return(reg.x.cflag);
}</font>
</pre>

<p>Эта функция используется в следующей
программе, показывающей содержимое загрузочной
записи для указанного логического диска: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

  BOOT _far *boot_rec;
  int i, status;
  char drive;

  printf(&quot;\n&quot;
                        &quot;\nЧтение загрузочной записи логического диска&quot;
                        &quot;\n  (C)Фролов А., 1991&quot;
                        &quot;\n&quot;);


// Заказываем буфер для чтения BOOT-записи.
// Адрес буфера присваиваем FAR-указателю.

  boot_rec = _fmalloc(sizeof(*boot_rec));

// Запрашиваем диск, для которого необходимо
// выполнить чтение загрузочной записи.

  printf(&quot;\n&quot;
                        &quot;\nВведите обозначение диска, для просмотра&quot;
                        &quot;\nзагрузочной записи (A, B, ...):&quot;);

  drive = getche();

// Вычисляем номер дисковода

  drive = toupper(drive) - 'A';

// Читаем загрузочную запись в буфер

  status = getboot((BOOT _far*)boot_rec, drive);

// Если произошла ошибка (например, неправильно указано
// обозначение диска), завершаем работу программы

  if(status) {
                printf(&quot;\nОшибка при чтении BOOT-сектора&quot;);
                exit(-1);
  }

  printf(&quot;\nСодержимое BOOT-сектора для диска %c&quot;,drive+'A');
  printf(&quot;\n&quot;
                        &quot;\nOEM - название фирмы и версия DOS - &quot;);

  for(i=0;i&lt;8;i++) printf(&quot;%c&quot;,boot_rec-&gt;oem[i]);

  printf(&quot;\nНомер диска                       - %x&quot;
                        &quot;\nПризнак расширенной BOOT-записи   - %c&quot;
                        &quot;\nСерийный номер диска              - %04X-%04X&quot;
                        &quot;\nМетка диска                       - &quot;,
                        (unsigned char)boot_rec-&gt;drive,
                        boot_rec-&gt;signature,
                        boot_rec-&gt;volser_hi,
                        boot_rec-&gt;volser_lo);

  for(i=0;i&lt;11;i++) printf(&quot;%c&quot;,boot_rec-&gt;label[i]);

  printf(&quot;\nФормат FAT                        - &quot;);
  for(i=0;i&lt;8;i++) printf(&quot;%c&quot;,boot_rec-&gt;fat_format[i]);

  printf(&quot;\n\nИнформация из BPB:\n&quot;);

  printf(&quot;\nКоличество байтов в секторе       - %d&quot;
                &quot;\nКоличество секторов в кластере    - %d&quot;
                &quot;\nЗарезервировано секторов          - %d&quot;
                &quot;\nКоличество копий FAT              - %d&quot;
                &quot;\nМакс. количество файлов в корневом каталоге - %d&quot;
                &quot;\nОбщее количество секторов на диске          - %d&quot;
                &quot;\nБайт-описатель среды              - %x&quot;
                &quot;\nКоличество секторов в FAT         - %d&quot;,
                boot_rec-&gt;bpb.sectsize,
                boot_rec-&gt;bpb.clustsize,
                boot_rec-&gt;bpb.ressecs,
                boot_rec-&gt;bpb.fatcnt,
                boot_rec-&gt;bpb.rootsize,
                boot_rec-&gt;bpb.totsecs,
                (unsigned char)boot_rec-&gt;bpb.media,
                boot_rec-&gt;bpb.fatsize);

  printf(&quot;\n\nИнформация из расширения BPB:\n&quot;);

  printf(&quot;\nСекторов на дорожке               - %d&quot;
                &quot;\nКоличество головок                - %d&quot;
                &quot;\nСкрытых секторов для диска &lt; 32M  - %d&quot;
                &quot;\nСкрытых секторов для диска &gt;= 32M - %d&quot;
                &quot;\nВсего секторов на диске           - %u&quot;,
                boot_rec-&gt;bpb.seccnt,
                boot_rec-&gt;bpb.headcnt,
                boot_rec-&gt;bpb.hiddensec_low,
                boot_rec-&gt;bpb.hiddensec_hi,
                boot_rec-&gt;bpb.totsecs);

// Освобождаем буфер

  _ffree(boot_rec);
}</font>
</pre>

<p>Приведенная выше программа использует функции<b>
_fmalloc()</b> и <b>_ffree()</b> соответственно для заказа и
освобождения массива памяти. В отличие от широко
известных функций <b>malloc()</b> и <b>free()</b>, эти функции
используют <b>FAR</b>-указатели на полученную и
отдаваемую области памяти. </p>

<h3><a NAME="ch2_3"><font SIZE="4" COLOR="#008000">2.3. Таблица
размещения файлов</font></a></h3>

<p>Сразу после загрузочного сектора на логическом
диске находятся сектора, содержащие <b>таблицу
размещения файлов</b> <b>FAT</b> (File Allocation Table). В
отечественной литературе иногда можно встретить
аббревиатуру ТРФ, однако мы будем пользоваться
общепринятым сокращением - <b>FAT</b>. </p>

<p>Для того, чтобы назначение этой таблицы стало
более понятным, вспомним, как организовано
хранение информации на различных носителях
данных. </p>

<p>Магнитные ленты. Этот вид носителей информации
использовался еще в самых первых ЭВМ. В
современных компьютерах магнитные ленты
используются для разгрузки магнитных дисков. </p>

<p>При использовании магнитных лент информация
записывается в виде файлов с последовательным
доступом. Последовательный доступ означает, что
для чтения какого-либо файла требуется вначале
прочитать все предыдущие файлы. При записи
информация может добавляться в конец ленты,
после той информации, которая была записана в
последний раз. </p>

<p>Если вы попытаетесь перезаписать файл, то это
может привести к потере всех файлов,
расположенных на магнитной ленте после
перезаписываемого. </p>

<p>Доступ к информации, записанной на магнитном
диске, может выполняться либо последовательным,
либо прямым методом доступа. Использование
прямого метода доступа позволяет
позиционировать головки сразу на тот файл,
который вам нужен (или на нужную запись файла).
Например, вы можете задать номер сектора на
оперделенной дорожке и номер головки. </p>

<p>Но метод доступа - это еще не все. Важное
значение имеет способ распределения места на
диске для файлов. От правильного выбора способа
распределения зависит эффективность работы
программ. </p>

<p>Операционная система ОС ЕС для ЭВМ ряда ЕС
позволяет задать начальное количество цилиндров
диска для размещения набора данных и размер
области диска, которая может быть использована
для этого набора дополнительно. Если при записи в
файл все распределенное для файла место на диске
окажется исчерпанным, программа завершится
аварийно, даже если на диске еще есть свободные
цилиндры. </p>

<p>Операционные системы, подобные DOS, UNIX, OS/2
используют дисковое пространство другим
способом. </p>

<p>В этих операционных системах при создании
файла для него не задается начальное
распределение памяти в дорожках или секторах. По
мере того, как файл увеличивается в размерах,
операционная система распределяет этому файлу
сектора из числа свободных, не используемых
другими файлами. При этом файл располагается не
обязательно в смежных областях диска, он может
быть разбросан по разным дорожкам и секторам. </p>

<p>Очевидно, что в этом случае операционная
система должна вести учет используемых участков
диска. Для каждого файла она должна хранить
где-то информацию о том, какому файлу какие
участки диска распределены. </p>

<p>В операционной системе MS-DOS для хранения этой
информации используется таблица размещения
файлов. </p>

<p>Весь диск разбивается операционной системой на
участки одинакового размера, называемые
кластерами. Кластер может содержать несколько
секторов. Для каждого кластера <b>FAT</b> имеет свою
индивидуальную ячейку, в которой хранится
информация об использовании данного кластера.
Другими словами, таблица размещения файлов - это
массив, содержащий информацию о кластерах.
Размер этого массива определяется общим
количеством кластеров на логическом диске.
(Именно кластеров, а не секторов!). </p>

<p>Что же хранится в таблице размещения файлов? </p>

<p>Все свободные кластеры помечены в ней нулями.
Если файл занимает несколько кластеров, то эти
кластеры связаны в список. Для связанных в список
кластеров элементы таблицы <b>FAT</b> содержат
номера следующих используемых данным файлом
кластеров. Конец списка отмечен в таблице
специальным значением. Номер первого кластера,
распределенного файлу, хранится в элементе
каталога, описывающего данный файл. </p>

<p>Утилиты операционной системы и некоторые
специальные утилиты проверяют диск на предмет
наличия дефектных областей. Кластеры, которые
находятся в этих дефектных областях, отмечаются
в <b>FAT</b> как плохие и не используются
операционной системой. </p>

<p>Итак, <b>FAT</b> - массив информации об
использовании кластеров диска, содержит
односвязные списки кластеров, распределенных
файлам. Номера начальных кластеров файлов
хранятся в каталогах, о которых мы будем говорит
в разделе &quot;Файлы и каталоги&quot;. Прежде чем
углубляться в тонкости таблицы размещения
файлов, приведем рисунок, иллюстрирующий
сказанное выше. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                                         +­­­­­+
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+ ¦
¦AUTOEXECBAT¦ ... ¦Номер 1-го кластера: 11¦..¦ ¦
+­­­­­­­­­­­+­­­­­+­­­­­­­­­­­­­­­­­­­­­­­+­­¦ ¦
¦CONFIG  SYS¦ ... ¦Номер 1-го кластера: 27¦..¦ ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+ ¦
                                         ¦     ¦
                                         ¦     ¦
                                         +­­­­­+­­­­­­+
     +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+      ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+   ¦
¦...¦12¦13¦14¦15¦16¦17¦18¦19¦20¦FF¦ 0¦ 0¦ 0¦ 0¦...¦   ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+   ¦
+­­­­­­­­­­­­­­­­­­­+                                 ¦
¦...¦28¦29¦30¦FF¦...¦                                 ¦
+­­­­­­­­­­­­­­­­­­­+                                 ¦
     +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>На этом рисунке показаны фрагменты корневого
каталога диска <b>С:</b> и элементы <b>FAT</b> для файлов <b>autoexec.bat</b>
и <b>config.sys</b>. Реально эти файлы не используют
столько кластеров. Из рисунка видно, что в
каталоге для файлов указаны номера первых
кластеров (соответственно 11 и 27). Таблица <b>FAT</b> в
одиннадцатой ячейке содержит число 12 - номер
следующего кластера, распределенного файлу <b>autoexec.bat</b>.
Ячейка с номером 12 содержит число 13, и так далее.
Последняя ячейка, соответствующая последнему
кластеру распределенному этому файлу, содержит
специальное значение - <b>FF</b>. В этом примере все
кластеры файлов расположены подряд, но это может
быть и не так. </p>

<p>Существуют<i> <b>два формата</i> FAT</b> - 12-битовый и
16-битовый. Эти форматы используют,
соответственно, 12 и 16 битов для хранения
информации об одном кластере диска. </p>

<p><i><b>12-битовый формат</b></i> удобен для дискет с
небольшим количеством секторов - вся таблица
размещения файлов помещается целиком в одном
секторе. Если размер диска такой, что для
представления всех секторов двенадцати разрядов
недостаточно, можно увеличить размер кластера,
например до восьми секторов. Однако большой
размер кластера приводит к неэффективному
использованию дискового пространства. Это
происходит из-за того, что минимальный
выделяемый файлу элемент - кластер - имеет
слишком большой размер. Даже для файла, имеющего
длину 1 байт выделяется целиком кластер. Значит,
если размер кластера составляет 8 секторов, то
для хранения одного байта будет использовано 4
килобайта дисковой памяти. </p>

<p>При использовании <b>FAT</b> <i><b>16-битового формата</b></i>
операционная система может работать с диском,
который имеет размер более 32 мегабайт. DOS версии
4.0 при использовании 16-битового формата <b>FAT</b> и
кластеров размером 4 сектора может работать с
разделами, по размеру достигающими 134 мегабайтов.
</p>

<h3>Как программа может определить формат FAT?</h3>

<p>Для DOS версии 3.0 16-битовый формат используется,
если размер диска превышает 4086 кластеров. Это
число получилось исходя из того, что в 12 разрядах
может быть представлено максимальное число 4096,
кроме того, значения, большие <b>0ff6</b>,
зарезервированы. </p>

<p>Для DOS версии 3.2 16-битовый формат FAT используется
в том случае, когда размер диска превышает 20790
секторов (именно секторов, а не кластеров).
Фактически это означает, что 16-битовый формат
используется только для дисков, имеющих размер
более 10 мегабайтов. </p>

<p>Сектор загрузочной записи (<b>BOOT</b>-сектор) диска,
отформатированного в DOS версии 4.0 в поле со
смещением <b>36h</b> содержит восьмибайтовую строку,
идентифицирующую формат <b>FAT</b>. Она имеет вид
&quot;FAT12 &quot; или &quot;FAT16 &quot;. Вы можете использовать
это поле для определения формата <b>FAT</b>. В
структуре <b>BOOT</b>, описанной в файле <b>sysp.h,</b> это
поле называетcя <b>fat_format</b>. </p>

<p>Если разделы на жестком диске создавались
утилитой DOS <b>FDISK</b>, формат <b>FAT</b> можно
определить, анализируя содержимое поля <b>sys</b>
главной загрузочной записи (Master Boot Record). Если это
поле содержит значение 1, используется 12-битовый
формат, если 4 - 16-битовый. Однако диск,
подготовленный программами диск-менеджеров,
может иметь нестандартный для DOS формат таблицы
разделов диска (Partition Table), и поле <b>sys</b> может
содержать другие величины, отличные от 1 и 4. </p>

<h3>Опишем подробно формат FAT.</h3>

<p>Первый байт <b>FAT</b> называется <i><b>&quot;Описатель
среды&quot;</b></i> (Media Descriptor) или байт <b>ID</b>
идентификации <b>FAT</b>. Он имеет такое же значение,
как и байт-описатель среды, находящийся в <b>BOOT</b>-секторе
логического диска. </p>

<p>Следующие 5 байтов для 12-битового формата или 7
байтов для 16-битового формат всегда содержат
значение <b>0ffh</b>. </p>

<p>Остальная часть <b>FAT</b> состоит из 12-битовых или
16-битовых ячеек, каждая ячейка соответствует
одному кластеру диска. Эти ячейки могут
содержать следующие значения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="90">FAT12</td>
    <td WIDTH="99">FAT16</td>
    <td WIDTH="305">Что означает </td>
  </tr>
  <tr>
    <td WIDTH="90">000h</td>
    <td WIDTH="99">0000h</td>
    <td WIDTH="305">Свободный кластер </td>
  </tr>
  <tr>
    <td WIDTH="90">ff0h - ff6h</td>
    <td WIDTH="99">fff0h - fff6h</td>
    <td WIDTH="305">Зарезервированный кластер</td>
  </tr>
  <tr>
    <td WIDTH="90">ff7h</td>
    <td WIDTH="99">fff7h</td>
    <td WIDTH="305">Плохой кластер </td>
  </tr>
  <tr>
    <td WIDTH="90">ff8h - fffh</td>
    <td WIDTH="99">fff8h - ffffh</td>
    <td WIDTH="305">Последний кластер в списке</td>
  </tr>
  <tr>
    <td WIDTH="90">002h - fefh</td>
    <td WIDTH="99">0002h - ffefh</td>
    <td WIDTH="305">Номер следующего кластера в списке</td>
  </tr>
</table>

<p>Непосредственный доступ к <b>FAT</b> может
потребоваться вам для организации сканирования
каталогов для поиска нужных файлов, для чтения
каталогов как файлов, для организации защиты
информации от несанкционированного копирования.
Общая схема использования <b>FAT</b> такая: 

<ul>
  <li>Читаем <b>FAT</b> целиком в память. Обычно <b>FAT</b>
    располагается сразу после <b>BOOT</b>-сектора
    (логический сектор с номером 1). Для точного
    определения начального сектора <b>FAT</b> следует
    прочитать в память <b>BOOT</b>-сектор и
    проанализировать содержимое блока параметров
    BIOS. В поле <b>ressecs</b> записано количество
    зарезервированных секторов, которые
    располагаются перед <b>FAT</b>. Поле <b>fatsize</b> содержит
    размер <b>FAT</b> в секторах. Кроме того, следует
    учитывать, что на диске может находиться
    несколько копий <b>FAT</b>. Операционная система
    использует только первую копию, остальные нужны
    для утилит восстановления содержимого диска,
    таких как <b>CHKDSK</b>. Количество копий <b>FAT</b>
    находится в поле <b>fatcnt</b> <b>BOOT</b>-сектора. </li>
  <li>Затем необходимо узнать номер первого кластера
    файла, для которого необходимо определить его
    расположение на диске. </li>
  <li>Используем номер первого кластера как индекс в <b>FAT</b>
    для извлечения номера следующего кластера. </li>
  <li>Повторяем предыдущую процедуру до тех пор, пока
    извлеченное из <b>FAT</b> значение не будет
    соответствовать концу файла. </li>
</ul>

<p>Процедура извлечения номера кластера из <b>FAT</b>
зависит от формата таблицы размещения файлов. </p>

<p>16-битовую <b>FAT</b> можно представить как массив
16-битовых чисел. Для определения номера
следующего кластера вам надо просто извлечь
16-битовое значение из <b>FAT</b>, использовав в
качестве индекса номер предыдущего кластера. </p>

<p>Для 12-битовой <b>FAT</b> процедура значительно
сложнее. Необходимо выполнить следующие
действия: 

<ul>
  <li>Умножить номер начального кластера на 3. </li>
  <li>Разделить результат на 2 (так как каждый элемент
    таблицы имеет длину 1.5 байта). </li>
  <li>Прочитать 16-битовое слово из <b>FAT</b>, используя в
    качестве смещения значение, полученное после
    деления на 2. </li>
  <li>Если номер начального кластера четный, на
    выбранное из <b>FAT</b> слово надо наложить маску <b>0fffh</b>,
    оставив младшие 12 битов. Если номер начального
    кластера нечетный, выбранное из <b>FAT</b> значение
    необходимо сдвинуть вправо на 4 бита, оставив
    старшие 12 битов. </li>
  <li>Полученный результат - номер следующего
    кластера в цепочке, значение <b>0fffh</b>
    соответствует концу цепочки кластеров. </li>
</ul>

<p>Используя описанные выше методики чтения <b>FAT</b>,
вы сможете для каждого файла определить цепочку
занимаемых им кластеров. Для чтения файла при
помощи прерывания DOS <b>INT&nbsp;25h</b> вам будет нужно
установить соответствие между номерами
кластеров и номерами секторов, в которых
располагаются эти кластеры. Для того чтобы это
сделать, необходимо определить расположение и
размер корневого каталога. Поэтому следующий
раздел книги будет посвящен каталогам и файлам.
Там же будут приведены примеры программ для
работы с <b>FAT</b>. </p>

<h3><a NAME="ch2_4"><font SIZE="4" COLOR="#008000">2.4. Файлы и каталоги</font></a>
</h3>

<p>Вы, конечно, знаете, что файловая система DOS
имеет древовидную структуру. В корневом каталоге
располагаются 32-байтовые элементы, которые
содержат информацию о файлах и других каталогах.
Для чтения корневого каталога необходимо
определить его расположение и размер. </p>

<p>Корневой каталог находится сразу за последней
копией <b>FAT</b>. Количество секторов, занимаемых
одной копией <b>FAT</b>, находится в блоке параметров
BIOS в <b>BOOT</b>-секторе в поле <b>fatsize</b>, количество
копий <b>FAT</b> - в поле <b>fatcnt</b> блока <b>BPB</b>.
Следовательно, перед корневым каталогом
находится один <b>BOOT</b>-сектор и <b>(fatcnt_*_fatsize)</b>
секторов таблицы размещения файлов <b>FAT</b>. </p>

<p>Размер корневого каталога можно определить
исходя из значения поля <b>rootsize</b>. В этом поле при
форматировании диска записывается максимальное
количество файлов и каталогов, которые могут
находиться в корневом каталоге. Для каждого
элемента в каталоге отводится 32 байта, поэтому
корневой каталог имеет длину<b> (32_*_rootsize) </b>байтов.
</p>

<p>Корневой каталог занимает непрерывную область
фиксированного размера. Размер корневого
каталога задается при форматировании и
определяет максимальное количество файлов и
каталогов, которые могут быть описаны в корневом
каталоге. Для определения количества секторов,
занимаемых корневым каталогом, можно
воспользоваться следующей формулой: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">RootSecs = sectsize_/_(32_*_rootsize)</font>
</pre>

<p>В этой формуле <b>sectsize</b> - размер сектора в
байтах, он может быть получен из
соответствующего поля <b>BOOT</b>-сектора. </p>

<p>После корневого каталога на логическом диске
находится область файлов и подкаталогов
корневого каталога. На рисунке изображены все
области логического диска. Такую структуру имеют
логические диски, расположенные в разделах
жестких дисков, а также дискеты. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Области логического диска       Номер начального сектора
                                                на логическом диске

+­­­­­­­­­­­­­­­­­­­+
¦                   ¦             0
¦ BOOT-сектор и     ¦
¦ зарезервированные ¦
¦ сектора           ¦
¦                   ¦
+­­­­­­­­­­­­­­­­­­­¦
¦                   ¦             ressecs - количество резервных
¦ Первая копия FAT  ¦                            секторов
¦                   ¦
+­­­­­­­­­­­­­­­­­­­¦
¦                   ¦             ressecs+fatsize
¦ Вторая копия FAT  ¦
¦                   ¦
+­­­­­­­­­­­­­­­­­­­¦
¦                   ¦             ressecs+(fatsize*fatcnt)
¦ Корневой каталог  ¦
¦                   ¦
+­­­­­­­­­­­­­­­­­­­¦
¦                   ¦             ressecs+(fatsize*fatcnt)+
¦ Область данных    ¦               sectsize_/_(32*rootsize)
¦                   ¦
+­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>Область данных разбита на кластеры, причем
нумерация кластеров начинается с числа 2.
Кластеру с номером 2 соответствуют первые
сектора области данных. Теперь мы можем привести
формулу, которая позволит нам связать номер
кластера с номерами секторов, занимаемых им на
логическом диске: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">SectNu = DataStart + ((ClustNu-2) * clustsize)</font>
</pre>

<p>В этой формуле: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">SectNu  - номер первого сектора, распределенного
                  кластеру с номером ClustNu;

DataStart = ressecs+(fatsize*fatcnt)+(sectsize/(32*rootsize));

ClustNu - номер кластера, для которого необходимо определить
                  номер первого сектора;

clustsize       - количество секторов, занимаемых кластером,
                  находится в блоке параметров BIOS.</font>
</pre>

<p>Этой формулой мы воспользуемся для чтения
корневого каталога. </p>

<p>Как мы уже говорили, любой каталог содержит
32-байтовые элементы - дескрипторы, описывающие
файлы и другие каталоги. Приведем формат
дескриптора: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="93">Смещение</td>
    <td WIDTH="96">Размер</td>
    <td WIDTH="307">Содержимое </td>
  </tr>
  <tr>
    <td WIDTH="93">(+0)</td>
    <td WIDTH="96">8</td>
    <td WIDTH="307">Имя файла или каталога, выравненное на
    левую границу и дополненное пробелами. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+8)</td>
    <td WIDTH="96">3</td>
    <td WIDTH="307">Расширение имени файла, выравненное на
    левую границу и дополненное пробелами. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+11)</td>
    <td WIDTH="96">1</td>
    <td WIDTH="307">Атрибуты файла. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+12)</td>
    <td WIDTH="96">10</td>
    <td WIDTH="307">Зарезервировано. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+22)</td>
    <td WIDTH="96">2</td>
    <td WIDTH="307">Время создания файла или время его
    последней модификации. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+24)</td>
    <td WIDTH="96">2</td>
    <td WIDTH="307">Дата создания файла или дата его
    последней модификации. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+26)</td>
    <td WIDTH="96">2</td>
    <td WIDTH="307">Номер первого кластера, распределенного
    файлу. </td>
  </tr>
  <tr>
    <td WIDTH="93">(+28)</td>
    <td WIDTH="96">4</td>
    <td WIDTH="307">Размер файла в байтах. </td>
  </tr>
</table>

<p>Байт атрибутов является принадлежностью
каждого файла. Биты этого байта имеют следующие
значения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="440">Файл предназначен только для чтения, в
    этот файл нельзя писать и его нельзя стирать. </td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="440">Скрытый файл, этот файл не будет
    появляться в списке файлов, создаваемом командой
    операционной системы DIR. </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="440">Системный файл. Этот бит обычно
    установлен в файлах, являющихся составной частью
    операционной системы. </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="440">Данный дескриптор описывает метку
    диска. Для этого дескриптора поля имени файла и
    расширения имени файла должны рассматриваться
    как одно поле длиной 11 байтов. Это поле содержит
    метку диска. </td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="440">Дескриптор описывает файл, являющийся
    подкаталогом данного каталога. </td>
  </tr>
  <tr>
    <td WIDTH="48">5</td>
    <td WIDTH="440">Флаг архивации. Если этот бит установлен
    в 1, то это означает, что данный файл не был
    выгружен утилитой архивации (например,
    программой BACKUP). </td>
  </tr>
  <tr>
    <td WIDTH="48">6-7</td>
    <td WIDTH="440">Зарезервированы.</td>
  </tr>
</table>

<p>Обычно файлы имеют следующие комбинации битов
в байте атрибутов: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="440">Обычные файлы (тексты программ,
    загрузочные модули, пакетные файлы). </td>
  </tr>
  <tr>
    <td WIDTH="48">7</td>
    <td WIDTH="440">Только читаемые, скрытые, системные
    файлы. Такая комбинация битов байта атрибутов
    используется для файлов операционной системы
    IO.SYS, MSDOS.SYS. </td>
  </tr>
  <tr>
    <td WIDTH="48">8</td>
    <td WIDTH="440">Метка тома. Дескриптор метки тома может
    находиться только в корневом каталоге
    логического диска. </td>
  </tr>
  <tr>
    <td WIDTH="48">10h</td>
    <td WIDTH="440">Дескриптор, описывающий каталог. </td>
  </tr>
  <tr>
    <td WIDTH="48">20h</td>
    <td WIDTH="440">Обычный файл, который не был выгружен
    утилитами BACKUP или XCOPY. </td>
  </tr>
</table>

<p>В любом каталоге, кроме корневого, два первых
дескриптора имеют специальное назначение.
Первый дескриптор содержит в поле имени строку: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">&quot;.       &quot;</font>
</pre>

<p>Этот дескриптор указывает на содержащий его
каталог. Т.е. каталог имеет ссылку сам на себя. </p>

<p>Второй специальный дескриптор содержит в поле
имени строку: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">&quot;..      &quot;</font>
</pre>

<p>Этот дескриптор указывает на каталог более
высокого уровня. </p>

<p>Если в поле номера первого занимаемого
кластера дескриптора с именем <b>&quot;.. &quot; </b>находится
нулевое значение, это означает, что данный
каталог содержится в корневом каталоге. </p>

<p>Таким образом, в древовидной структуре
каталогов имеются ссылки как в прямом, так и в
обратном направлении. Эти ссылки можно
использовать для проверки сохранности структуры
каталогов файловой системы. </p>

<p>При удалении файла первый байт его имени
заменяется на байт <b>E5h</b> (символ <b>'х'</b>). Все
кластеры, распределенные файлу, отмечаются в <b>FAT</b>
как свободные. Если вы только что удалили файл,
его еще можно восстановить, так как в дескрипторе
сохранились все поля, кроме первого байта имени
файла. Но если на диск записать новые файлы, то
содержимое кластеров удаленного файла будет
изменено и восстановление станет невозможным. </p>

<p>Остановимся подробнее на полях времени и даты
создания или последней модификации файла. DOS
обновляет содержимое этих полей после любой
операции, изменяющей содержимое файла - создания
файла, перезаписи содержимого файла, добавления
данных в файл или обновления содержимого файла.
После обновления файла DOS устанавливает бит
архивации 5 байта атрибутов в 1. </p>

<p>Формат поля времени показан на рисунке: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">15            11 10               5 4                   0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Часы (0...23) ¦  Минуты (0...59) ¦  Секунды/2 (0...29) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>Старшие пять битов содержат значение часа
модификации файла, шесть битов с номерами 5-10
содержат значение минут модификации файла, и,
наконец, в младших 5 битах хранится значение
секунд, деленное на 2. Для того, чтобы время
обновления файла уместилось в шестнадцати битах,
пришлось пойти на снижение точности времени до
двух секунд. </p>

<p>Формат даты обновления файла напоминает формат
времени: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">15             9 8               5 4              0
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
¦ Год (0...119) ¦  Месяц (1...12) ¦  День (1...31) ¦
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+</font>
</pre>

<p>Для того, чтобы получить значение года
обновления файла, необходимо прибавить к
величине, хранимой в старших семи битах, значение
1980. Поля месяца и дня каких-либо особенностей не
имеют, они полностью соответствуют календарной
дате. </p>

<p>Поле длины в дескрипторе содержит точную длину
файла в байтах. Для каталогов в поле длины
записано нулевое значение. Вы не можете работать
с каталогом, как с обычным файлом средствами DOS.
Единственный способ прочитать каталог как файл -
использовать <b>FAT</b> для определения цепочки
занимаемых каталогом кластеров и прочитать
сектора, соответствующие этим кластерам при
помощи прерывания DOS<b> INT&nbsp;25h.</b> </p>

<p>Для удобства работы с каталогами файл <b>sysp.h</b>
содержит следующие определения типов: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)


/* Время последнего обновления файла */

typedef struct _FTIME_ {
        unsigned sec : 5, min : 6, hour : 5;
} FTIME;



/* Дата последнего обновления файла */

typedef struct _FDATE_ {
        unsigned day : 5, month : 4, year : 7;
} FDATE;



/* Дескриптор файла в каталоге */

typedef struct _FITEM_ {
        char name[8];
        char ext[3];
        char attr;
        char reserved[10];
        FTIME time;
        FDATE date;
        unsigned cluster_nu;
        unsigned long size;
} FITEM;
#pragma pack()</font>
</pre>

<p>Приведем исходный текст программы, которая
читает <b>BOOT</b>-сектор выбранного диска,
определяет формат <b>FAT</b>, вычисляет размер и
расположение <b>FAT</b> и корневого каталога. Затем
программа читает <b>FAT</b> и корневой каталог в
динамически получаемые буфера и выводит на экран
содержимое корневого каталога. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

  BOOT _far *boot_rec;
  int i,j, k, status, fat_sectors;
  long total_sectors;
  int fat, root_begin, root_sectors;
  char drive;
  unsigned _far *fat_buffer;
  FITEM _far *root_buffer, _far *rptr;

  union REGS reg;
  struct SREGS segreg;


  printf(&quot;\n&quot;
                &quot;\nЧтение корневого каталога логического диска&quot;
                &quot;\n  (C)Фролов А., 1991&quot;
                &quot;\n&quot;);


// Заказываем буфер для чтения BOOT-записи.
// Адрес буфера присваиваем FAR-указателю.

  boot_rec = _fmalloc(sizeof(*boot_rec));

// Запрашиваем диск, для которого необходимо
// выполнить чтение загрузочной записи.

  printf(&quot;\n&quot;
                &quot;\nВведите обозначение диска, для просмотра&quot;
                &quot;\nкорневого каталога (A, B, ...):&quot;);

  drive = getche();

// Вычисляем номер дисковода

  drive = toupper(drive) - 'A';

// Читаем загрузочную запись в буфер

  status = getboot((BOOT _far*)boot_rec, drive);

// Если произошла ошибка (например, неправильно указано
// обозначение диска), завершаем работу программы

  if(status) {
        printf(&quot;\nОшибка при чтении BOOT-сектора&quot;);
        exit(-1);
  }

// Определяем формат таблицы FAT

  total_sectors = boot_rec-&gt;bpb.totsecs;

// Если мы работаем с расширенным разделом диска,
// общее количество секторов на диска берем из
// расширенного PBP

  if(total_sectors == 0) total_sectors = boot_rec-&gt;bpb.drvsecs;

// Формат FAT определяем исходя из общего
// количества секторов на логическом диске

  if(total_sectors &gt; 20791) {
        printf(&quot;\nFAT имеет 16-битовый формат&quot;);
        fat=16;
  }
  else {
        printf(&quot;\nFAT имеет 12-битовый формат&quot;);
        fat=12;
  }

// Определяем количество секторов, занимаемых FAT

  fat_sectors = boot_rec-&gt;bpb.fatsize;

// Заказываем буфер для FAT

  fat_buffer = _fmalloc(fat_sectors * boot_rec-&gt;bpb.sectsize);

// Вычисляем номер первого сектора FAT

  j = boot_rec-&gt;bpb.ressecs;

// Читаем FAT в буфер fat_buffer

// Заполняем регистровые структуры для вызова
// прерывания DOS INT 25h

         reg.x.ax = drive;
         reg.x.bx = FP_OFF(fat_buffer);
         segreg.ds = FP_SEG(fat_buffer);
         reg.x.cx = fat_sectors;
         reg.x.dx = j;
         int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);

// Извлекаем из стека оставшееся там после
// вызова прерывания слово

         _asm pop ax

// Вычисляем номер первого сектора корневого каталога

        root_begin = j + fat_sectors * boot_rec-&gt;bpb.fatcnt;

// Вычисляем длину корневого каталога

        root_sectors = (boot_rec-&gt;bpb.rootsize * 32) /
                                boot_rec-&gt;bpb.sectsize;

// Заказываем буфер для корневого каталога

        root_buffer = _fmalloc(root_sectors * boot_rec-&gt;bpb.sectsize);


// Читаем корневой каталог в буфер root_buffer

         reg.x.ax = drive;
         reg.x.bx = FP_OFF(root_buffer);
         segreg.ds = FP_SEG(root_buffer);
         reg.x.cx = root_sectors;
         reg.x.dx = root_begin;
         int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);
         _asm pop ax

// Показываем содержимое корневого каталога

        printf(&quot;\n&quot;
         &quot;\nИмя файла    Аттр. Дата        Время     Кластер Размер&quot;
         &quot;\n------------ ----- ----------  --------  ------- ------&quot;);

        for(rptr = root_buffer;;rptr++) {
                printf(&quot;\n&quot;);

// Признак конца каталога - нулевой байт в начале
// имени файла

                if(rptr-&gt;name[0] == 0) break;

// Выводим содержимое дескриптора файла

                for(i=0; i&lt;8; i++) printf(&quot;%c&quot;,rptr-&gt;name[i]);
                printf(&quot;.&quot;);
                for(i=0; i&lt;3; i++) printf(&quot;%c&quot;,rptr-&gt;ext[i]);
                printf(&quot; %02X    %02d-%02d-%02d  %02d:%02d:%02d &quot;,
                        rptr-&gt;attr,
                        rptr-&gt;date.day,
                        rptr-&gt;date.month,
                        rptr-&gt;date.year + 1980,
                        rptr-&gt;time.hour,
                        rptr-&gt;time.min,
                        rptr-&gt;time.sec * 2);
                printf(&quot; %-5d   %lu&quot;,
                        rptr-&gt;cluster_nu,
                        rptr-&gt;size);

        }

// Освобождаем буфера

  _ffree(root_buffer);
  _ffree(boot_rec);
  _ffree(fat_buffer);
}</font>
</pre>

<p>Запустив программу два раза для диска <b>С:</b> и
RAM-диска <b>G:</b> мы получили на экране следующую
картину: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Чтение корневого каталога логического диска
  (C)Фролов А., 1991


Введите обозначение диска, для просмотра
корневого каталога (A, B, ...):c
FAT имеет 12-битовый формат

Имя файла    Аттр. Дата        Время     Кластер Размер
------------ ----- ----------  --------  ------- ------
IO      .SYS 07    26-11-1988  00:55:26  2       33337
MSDOS   .SYS 07    26-11-1988  00:56:18  11      37376
DOS     .    10    22-09-1990  00:50:34  21      0
ARC     .    10    22-09-1990  00:58:08  22      0
SYSPRG  .    10    03-10-1990  12:09:10  23      0
COMMAND .COM 20    30-11-1988  00:00:04  25      37557
SSTOR   .SYS 20    03-04-1989  12:00:00  354     17884
DUMM1004.COM 20    17-06-1990  12:59:24  35      1004
AUTOEXEC.B21 20    20-12-1990  11:21:02  359     677
AUTOEXEC.C60 20    28-07-1990  09:17:26  360     241
хYSLOG  .    20    15-01-1991  19:42:48  441     510
SD      .INI 20    08-10-1990  10:05:52  362     2497
NULLFILE.    20    17-02-1991  13:59:28  0       0
CLSCREEN.SYS 20    06-06-1990  20:58:36  363     157
AUTOEXEC.BAT 20    18-10-1990  16:14:14  364     677
FRECOVER.IDX 27    08-10-1990  10:07:16  504     29
FRECOVER.DAT 21    08-10-1990  10:07:16  467     18432
CONFIG  .SYS 20    02-02-1991  21:19:34  332     390
х       .    20    04-02-1991  21:34:34  361     254


Чтение корневого каталога логического диска
  (C)Фролов А., 1991


Введите обозначение диска, для просмотра
корневого каталога (A, B, ...):g
FAT имеет 12-битовый формат

Имя файла    Аттр. Дата        Время     Кластер Размер
------------ ----- ----------  --------  ------- ------
MS-RAMDR.IVE 08    03-01-1990  00:00:00  0       0
TEMP    .    10    17-02-1991  13:59:22  2       0
INCLUDE .    10    17-02-1991  13:59:26  3       0
BOOK3   .DOC 20    17-02-1991  15:27:38  18      181248</font>
</pre>

<p>Заметьте, что приведенная выше программа
предоставляет вам параметр, который невозможно
получить с помощью команды операционной системы <b>DIR</b>
- номер первого кластера, распределенного файлу.
Операционная система MS-DOS не дает программам иной
возможности определить номер первого кластера
файла, чем чтение каталога по секторам. </p>

<p>Для исследования подкаталогов корневого
каталога и для демонстрации основных приемов
работы с таблицей размещения файлов <b>FAT</b>
предназначена следующая программа. Вы можете
использовать ее для исследования структуры
каталогов диска. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

  BOOT _far *boot_rec;
  int i,j, k, status, fat_sectors;
  long total_sectors;
  int ffat, root_begin, root_sectors;
  char drive;
  unsigned _far *fat_buffer;
  FITEM _far *root_buffer, _far *rptr;
  char cbuf[128];
  char _far *clust_buffer;
  int cur_clust;

  union REGS reg;
  struct SREGS segreg;


  printf(&quot;\n&quot;
                &quot;\nЧтение каталогов логического диска&quot;
                &quot;\n  (C)Фролов А., 1991&quot;
                &quot;\n&quot;);


// Заказываем буфер для чтения BOOT-записи.
// Адрес буфера присваиваем FAR-указателю.

  boot_rec = _fmalloc(sizeof(*boot_rec));

// Запрашиваем диск, для которого необходимо
// выполнить чтение загрузочной записи.

  printf(&quot;\n&quot;
                &quot;\nВведите обозначение диска (A, B, ...):&quot;);

  drive = getche();

// Вычисляем номер дисковода

  drive = toupper(drive) - 'A';

// Читаем загрузочную запись в буфер

  status = getboot((BOOT _far*)boot_rec, drive);

// Если произошла ошибка (например, неправильно указано
// обозначение диска), завершааем работу программы

  if(status) {
        printf(&quot;\nОшибка при чтении BOOT-сектора&quot;);
        exit(-1);
  }

// Определяем формат таблицы FAT

  total_sectors = boot_rec-&gt;bpb.totsecs;

// Если мы работаем с расширенным разделом диска,
// общее количество секторов на диска берем из
// расширенного PBP

  if(total_sectors == 0) total_sectors = boot_rec-&gt;bpb.drvsecs;

// Формат FAT определяем исходя из общего
// количества секторов на логическом диске

  if(total_sectors &gt; 20791) {
        printf(&quot;\nFAT имеет 16-битовый формат&quot;);
        ffat=16;
  }
  else {
        printf(&quot;\nFAT имеет 12-битовый формат&quot;);
        ffat=12;
  }

// Определяем количество секторов, занимаемых FAT

  fat_sectors = boot_rec-&gt;bpb.fatsize;

// Заказываем буфер для FAT

  fat_buffer = _fmalloc(fat_sectors * boot_rec-&gt;bpb.sectsize);

// Вычисляем номер первого сектора FAT

  j = boot_rec-&gt;bpb.ressecs;

// Читаем FAT в буфер fat_buffer

// Заполняем регистровые структуры для вызова
// прерывания DOS INT 25h

         reg.x.ax = drive;
         reg.x.bx = FP_OFF(fat_buffer);
         segreg.ds = FP_SEG(fat_buffer);
         reg.x.cx = fat_sectors;
         reg.x.dx = j;
         int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);

// Извлекаем из стека оставшееся там после
// вызова прерывания слово

         _asm pop ax

// Вычисляем номер первого сектора корневого каталога

        root_begin = j + fat_sectors * boot_rec-&gt;bpb.fatcnt;

// Вычисляем длину корневого каталога

        root_sectors = (boot_rec-&gt;bpb.rootsize * 32) /
                                boot_rec-&gt;bpb.sectsize;

// Заказываем буфер для корневого каталога

        root_buffer = _fmalloc(root_sectors * boot_rec-&gt;bpb.sectsize);

// Читаем корневой каталог в буфер root_buffer

         reg.x.ax = drive;
         reg.x.bx = FP_OFF(root_buffer);
         segreg.ds = FP_SEG(root_buffer);
         reg.x.cx = root_sectors;
         reg.x.dx = root_begin;
         int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);
         _asm pop ax

// Показываем содержимое корневого каталога

        printf(&quot;\n&quot;
         &quot;\nИмя файла    Аттр. Дата        Время     Кластер Размер&quot;
         &quot;\n------------ ----- ----------  --------  ------- ------&quot;);

        for(rptr = root_buffer;;rptr++) {
                printf(&quot;\n&quot;);

// Признак конца каталога - нулевой байт в начале
// имени файла

                if(rptr-&gt;name[0] == 0) break;

// Выводим содержимое дескриптора файла

                for(i=0; i&lt;8; i++) printf(&quot;%c&quot;,rptr-&gt;name[i]);
                printf(&quot;.&quot;);
                for(i=0; i&lt;3; i++) printf(&quot;%c&quot;,rptr-&gt;ext[i]);
                printf(&quot; %02X    %02d-%02d-%02d  %02d:%02d:%02d &quot;,
                        rptr-&gt;attr,
                        rptr-&gt;date.day,
                        rptr-&gt;date.month,
                        rptr-&gt;date.year + 1980,
                        rptr-&gt;time.hour,
                        rptr-&gt;time.min,
                        rptr-&gt;time.sec * 2);
                printf(&quot; %-5d   %lu&quot;,
                        rptr-&gt;cluster_nu,
                        rptr-&gt;size);

        }

// Получаем буфер для чтения кластеров каталога

        clust_buffer = _fmalloc(boot_rec-&gt;bpb.clustsize
                                                * boot_rec-&gt;bpb.sectsize);

        printf(&quot;\nНомер первого кластера каталога:&quot;);
        gets(cbuf);
        cur_clust = atoi(cbuf);

// Переменная k используется в качестве флага.
// При первом просмотре каталога ее значение равно 0,
// затем эта переменная устанавливается в 1.

        k=0;

        for(;;) {

// Сохраняем номер кластера каталога

                j=cur_clust;

// Вычисляем номер следующего кластера, распределенного
// каталогу

                cur_clust = fat(fat_buffer, ffat, cur_clust);
                printf(&quot;%d &quot;,cur_clust);

// Читаем кластер в буфер clust_buffer

                 reg.x.ax = drive;
                 reg.x.bx = FP_OFF(clust_buffer);
                 segreg.ds = FP_SEG(clust_buffer);
                 reg.x.cx = boot_rec-&gt;bpb.clustsize;
                 reg.x.dx = root_begin + root_sectors
                                        + ((j-2)*boot_rec-&gt;bpb.clustsize);
                 int86x(0x25, &amp;reg, &amp;reg, &amp;segreg);
                 _asm pop ax

// Показываем содержимое каталога

                 rptr = (FITEM _far *)clust_buffer;

// Первый дескриптор в каталоге указывает на
// этот же каталог. В поле имени первого дескриптора
// находится строка &quot;.       &quot;. Этот факт можно использовать
// для проверки каталога. Если вы по ошибке указали
// номер кластера, не принадлежащего каталогу,
// программа завершит работу с сообщением об ошибке.

                 if(k == 0) {
                        k=1;
                        if(strncmp(rptr-&gt;name,&quot;.       &quot;,8) != 0) {
                                printf(&quot;\nЭто не каталог !&quot;);
                                exit(-1);
                        }
                 }

                 printf(&quot;\n&quot;
                 &quot;\nИмя файла    Аттр. Дата        Время     Кластер Размер&quot;
                 &quot;\n------------ ----- ----------  --------  ------- ------&quot;);

                 for(;;rptr++) {
                        printf(&quot;\n&quot;);

// Признак конца каталога - нулевой байт в начале
// имени файла

                        if(rptr-&gt;name[0] == 0) break;

// Выводим содержимое дескриптора файла

                        for(i=0; i&lt;8; i++) printf(&quot;%c&quot;,rptr-&gt;name[i]);
                        printf(&quot;.&quot;);
                        for(i=0; i&lt;3; i++) printf(&quot;%c&quot;,rptr-&gt;ext[i]);
                        printf(&quot; %02X    %02d-%02d-%02d  %02d:%02d:%02d &quot;,
                                rptr-&gt;attr,
                                rptr-&gt;date.day,
                                rptr-&gt;date.month,
                                rptr-&gt;date.year + 1980,
                                rptr-&gt;time.hour,
                                rptr-&gt;time.min,
                                rptr-&gt;time.sec * 2);
                        printf(&quot; %-5d   %lu&quot;,
                                rptr-&gt;cluster_nu,
                                rptr-&gt;size);

                }

// Если этот кластер - последний из распределенных каталогу,
// завершаем работу программы

                if((cur_clust == 0xfff) || (cur_clust == 0xffff)) break;

        }

// Освобождаем буфера

  _ffree(root_buffer);
  _ffree(boot_rec);
  _ffree(fat_buffer);
  _ffree(clust_buffer);
}</font>
</pre>

<p>Эта программа обращается к таблице размещения
файлов при помощи функции <b>fat()</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      fat
*
*.Title     Выбрать элемент из FAT
*
*.Descr     Функция выбирает элемент с заданным номером из таблицы
*           размещения файлов FAT. Формат FAT передается
*           функции как параметр.
*
*.Params    int fat(b_fat, t_fat, idx);
*
*           char _far *b_fat  - буфер, содержащий FAT
*
*           int t_fat         - формат FAT, может быть
*                               равен 12 или 16
*
*           int idx           - номер элемента FAT, который
*                               должен быть выбран
*
*.Return    Содержимое ячейки FAT с указанным номером
**/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;sysp.h&quot;

int fat(char _far *b_fat, int t_fat, int idx) {

  div_t clust_nu ;
  int cluster;

  if(t_fat == 12) {

                /*  FAT -  12  */

          clust_nu = div(idx * 3, 2);

          if( clust_nu.rem != 0 )

                cluster = (*((int*)(b_fat + clust_nu.quot)) &gt;&gt; 4) &amp; 0xfff;

          else

                cluster = *((int*)(b_fat + clust_nu.quot)) &amp; 0xfff;
  }

  else if(t_fat == 16) {

                /*  FAT - 16  */

          cluster = *((int*)(b_fat + idx * 2));
  }

  else {
                printf(&quot;*FAT()* FAT format error\n&quot;);
                exit(-100);
  }

  return(cluster);
}</font>
</pre>

<p>В качестве примера приведем результат работы
программы для диска <b>E:</b> </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Чтение каталогов логического диска
  (C)Фролов А., 1991


Введите обозначение диска (A, B, ...):e
FAT имеет 12-битовый формат

Имя файла    Аттр. Дата        Время     Кластер Размер
------------ ----- ----------  --------  ------- ------
C600    .    10    22-09-1990  01:22:14  2       0
SOLO    .    10    22-09-1990  11:15:42  6       0
QC25    .    10    07-10-1990  22:53:48  7       0
SYSPRG  .    10    03-10-1990  09:19:08  12      0
WORD    .    10    02-02-1991  14:02:14  15      0
SD      .INI 20    17-02-1991  15:36:52  799     2497
FRECOVER.IDX 27    17-02-1991  15:42:10  2551    29
FRECOVER.DAT 21    17-02-1991  15:42:10  1958    21504
х       .    20    17-02-1991  16:37:30  1973    347

Номер первого кластера каталога:3
4095 

Имя файла    Аттр. Дата        Время     Кластер Размер
------------ ----- ----------  --------  ------- ------
.       .    10    22-09-1990  01:22:24  3       0
..      .    10    22-09-1990  01:22:24  2       0
UTILS   .HLP 20    08-02-1990  00:09:42  800     162023
QH      .HLP 20    29-01-1990  19:32:04  840     20763
CV      .HLP 20    07-02-1990  21:33:32  846     239863</font>
</pre>

<p>Обратите внимание на выделенные элементы
каталога. Это ссылки соответственно на сам
каталог и на каталог более высокого уровня. </p>

<h3><a NAME="ch2_5"><font SIZE="4" COLOR="#008000">2.5. Программа FDISK и
диск-менеджеры</font></a></h3>

<p>В этом разделе мы сделаем несколько замечаний,
касающихся программ, формирующих логическую
структуру дисков. </p>

<p>После низкоуровневого форматирования,
формирующего адресные маркеры, маркеры данных и
сектора, необходимо создать разделы диска.
Операционная система MS-DOS позволяет сделать это с
помощью утилиты <b>FDISK</b>. Версия 4.0 MS-DOS и более
поздние версии не накладывают ограничений на
размер разделов и логических дисков. Однако при
использовании утилиты <b>FDISK</b> вы не сможете
организовать защиту логических дисков от записи
или от несанкционированного доступа. </p>

<p>Программы диск-менеджеров, такие как <b>ADM</b> и <b>SpeedStor</b>,
в некоторой степени решают вопросы защиты от
записи и несанкционированного доступа. Но
появляются новые проблемы. </p>

<p>Диск-менеджеры используют свой собственный
механизм разбиения диска на разделы, и,
следовательно, логическая структура диска,
подготовленного программами диск-менеджеров,
отличается от стандартной для MS-DOS. Прежде всего
это касается таблицы разделов диска (Partition Table),
находящейся в главной загрузочной записи.
Элементы таблицы разделов имеют отличный от
используемого MS-DOS код системы. Этот код зависит
от используемой программы диск-менеджера. </p>

<p>Если ваш диск подготовлен программой <b>SpeedStor</b>,
то все элементы таблицы разделов будут заняты
(MS-DOS оставляет два элемента неиспользованными).
Для того, чтобы установить на этот же диск другую
операционную систему (например, XENIX или OS/2) вам
придется выгрузить содержимое всего диска на
дискеты или стриммер (кассетный накопитель на
магнитной ленте), удалить все разделы <b>SpeedStor</b>,
создать разделы другой операционной системы, и
уже затем разделы MS-DOS. Если бы диск был
подготовлен утилитой <b>FDISK</b>, то зарезервировав
заранее место для другой операционной системы,
вы смогли бы без проблем использовать два
оставшихся элемента таблицы разделов. </p>

<p>В таблице разделов диска, подготовленной
программой <b>FDISK</b>, находится информация об
используемом формате таблицы размещения файлов <b>FAT</b>.
Вы можете пользоваться этой информацией, но
только в том случае, если диск подготовлен
утилитой <b>FDISK</b>. </p>

<p>Из сказанного выше следует, что если работа
вашей программы не должна зависеть от того, каким
способом были подготовлены разделы диска, вам не
следует работать непосредственно с таблицей
разделов диска. Для многих приложений, включая
защиту от несанкционированного копирования, вам
будет достаточно прочитать загрузочный сектор
логического диска и воспользоваться той
информацией, которая в нем содержится.<br>
</p>
</body>
</html>
