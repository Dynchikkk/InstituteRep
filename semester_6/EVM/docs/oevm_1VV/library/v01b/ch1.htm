<html>

<head>
<title>1. Работа с дисками на физическом уровне</title>
</head>

<body BGCOLOR="#ffffff">

<h2>1. Работа с дисками на физическом уровне</h2>

<p>1.1. <a HREF="ch1.htm#ch1_1">Дисководы и контроллеры</a> </p>

<p>1.2. <a HREF="ch1.htm#ch1_2">Сектора, головки, цилиндры...</a> </p>

<p>1.3. <a HREF="ch1.htm#ch1_3">Характеристики дисководов</a> </p>

<p>1.4. <a HREF="ch1.htm#ch1_4">Программирование контроллера
НГМД</a> </p>

<p>1.5. <a HREF="ch1.htm#ch1_5">Функции BIOS для работы с дисками</a>
</p>

<p>1.6. <a HREF="ch1.htm#ch1_6">Использование функций BIOS</a> </p>

<p>1.7. <a HREF="ch1.htm#ch1_7">Функция _bios_disk()</a> </p>

<p>Начнем мы с того, что расскажем об аппаратном
обеспечении дисковой подсистемы - о контроллерах
и дисководах. </p>

<h3><a NAME="ch1_1">1.1. Дисководы и контроллеры</a></h3>

<p>Первые персональные компьютеры фирмы IBM - IBM PC не
имели жесткого диска (&quot;винчестера&quot;, или, по
отечественной терминологии, накопителя на
жестком магнитном диске - НМД). Они были
оборудованы двумя флоппи-дисками (накопителями
на гибком магнитном диске - НГМД), которые и
представляли собой дисковую подсистему.
Отечественная персональная профессиональная
ЭВМ (ППЭВМ) ЕС-1840 и некоторые модели ЕС-1841 также не
имеют НМД. В таких компьютерах установлены, как
правило, два дисковода для флоппи-дисков (дискет).
Эти дисководы подключены к контроллеру -
специальному устройству, находящемуся в корпусе
персонального компьютера и выполняющему функции
управления дисководами. Контроллер обычно
выполнен в виде платы и вставлен в разъем общей
шины, который находится на материнской плате
(Motherboard) компьютера: </p>

<p><img SRC="img00002.gif" WIDTH="385" HEIGHT="214"> </p>

<p>В оригинальном компьютере IBM&nbsp;PC и в
отечественных ЕС­1840/1841 используются
флоппи-диски диаметром 5 дюймов. </p>

<p>Компьютер IBM XT и его ближайший отечественный
аналог ЕС­1841 может иметь один или два НГМД для
дискет диаметром 5 дюймов и, как правило, один НМД
емкостью 20 мегабайтов. Все дисководы
подключаются к одному общему контроллеру, как
это показано на рисунке: </p>

<p><img SRC="img00003.gif" WIDTH="389" HEIGHT="262"> </p>

<p>Машины IBM AT и машины более высокого класса могут
содержать несколько дисковых контроллеров, два
флоппи-диска с различным диаметром (3 и 5 дюймов) и
несколько жестких дисков. Впрочем, иногда
обходятся одним флоппи-диском диаметром 5 или 3
дюйма. Если вы решили установить несколько
дисковых контроллеров, необходимо позаботиться
о том, чтобы эти контроллеры имели различные
адреса на шине ввода/вывода компьютера. Это
достигается правильной установкой
соответствующих перемычек или переключателей,
находящихся на плате контроллера, о чем подробно
рассказано в документации на контроллер. </p>

<p>На рисунке показано, как могут быть подключены
к машине AT несколько различных дисководов: </p>

<p><img SRC="img00004.gif" WIDTH="389" HEIGHT="263"> </p>

<p>Покупая новый дисковод или контроллер,
необходимо помнить о совместимости. Существует
много типов контроллеров и дисководов,
отличающихся используемым интерфейсом,
способами записи информации и другими
характеристиками. Эта книга не содержит
конкретных рекомендаций по подбору дисководов и
контроллеров, однако мы приведем несколько
простых советов, которые помогут вам избежать
некоторых неприятностей. 

<ol>
  <li>Покупайте дисковод вместе с тем контроллером,
    который для него предназначен. В этом случае
    совместимость дисковода и контроллера
    гарантируется. </li>
  <li>Если вы покупаете дисковод для замены
    испорченного, выбирайте тот же тип и ту же
    фирму-изготовитель. Не надейтесь, что если
    дисковод имеет такую же емкость в мегабайтах, что
    и использовавшийся раньше, то он сможет работать
    в вашей системе. </li>
  <li>Если дисковод должен работать в сети на сервере,
    убедитесь в том, что сетевая операционная
    система поддерживает данный тип дисковода и
    контроллера. Необходимая информация по этому
    вопросу находится в документации по сетевой
    операционной системе. </li>
  <li>Не всегда удается заменить пятидюймовый НГМД на
    трехдюймовый. Убедитесь в том, что ваш контроллер
    может работать с трехдюймовым НГМД. Например,
    контроллер ППЭВМ ЕС-1841 не работает с такими
    дисководами. </li>
  <li>Проверьте, достаточна ли мощность блока
    питания, встроенного в компьютер, для
    подключения новых дисководов, при необходимости
    используйте блок расширения. </li>
</ol>

<p>Относительно недавно появились диски,
расположенные непосредственно на плате
контроллера, или, другими словами, совмещенные с
контроллером (<b>Hardcard</b>). Эти диски имеют емкость
несколько десятков мегабайтов, и их можно
установить несколько штук. </p>

<p>Другая разновидность жестких дисков - сменные
диски (<b>Cartridge</b>). В этих устройствах используется
сменный магнитный носитель, иногда
герметизированный и со встроенными элементами
механического привода и встроенными магнитными
головками. Емкость таких дисков составляет
несколько десятков мегабайтов. Для сменных
дисков используются специальные контроллеры и
специальное программное обеспечение. </p>

<p>Пожалуй, самая интересная разновидность
современных дисковых накопителей - оптические,
или лазерные. </p>

<p>В настоящее время существует три типа
оптических дисковых накопителей - <b>CD&nbsp;ROM, WORM</b> и
стираемые диски. </p>

<p>Диски <b>CD&nbsp;ROM </b>(Compact-Disk, Read-Only Memory) - это диски,
которые по своему формату и технологии записи
информации напоминают компакт-диски для записи
звука. Они имеют диаметр 120 миллиметров и могут
содержать порядка 600 мегабайтов информации. Эта
информация записывается один раз и впоследствии
может только читаться, как из постоянного
запоминающего устройства. </p>

<p><b>WORM</b>-диски (Write Once, Read Many) предназначены для
однократной записи и многократного считывания
данных. Эти диски наилучшим образом подходят для
архивного хранения информации, например,
содержимого обширных баз данных. </p>

<p>Стираемые диски могут многократно
использоваться для записи и чтения информации.
Это самые дорогостоящие дисковые накопители. </p>

<p>Основной недостаток лазерных накопителей -
относительно невысокое быстродействие по
сравнению с традиционными накопителями на
жестких дисках. Однако этот недостаток
постепенно преодолевается и, по-видимому,
оптические накопители скоро получат широкое
распространение, особенно для работы с большими
архивами и базами данных. </p>

<p>Для работы с оптическими накопителями
используются специальные контроллеры и
специальное программное обеспечение. </p>

<h3><a NAME="ch1_2">1.2. Сектора, головки, цилиндры...</a></h3>

<p>Что же, собственно, представляет из себя диск? </p>

<p>Флоппи-диск - это круглая пластинка, покрытая с
двух сторон магнитным материалом, напоминающим
используемый в магнитных лентах для обычных
бытовых магнитофонов, только отличающимся по
некоторым характеристикам (например, по форме и
ширине петли гистерезиза). Ближе к центру в диске
находится маленькое отверстие, предназначенное
для синхронизации: </p>

<p><img SRC="img00005.gif" WIDTH="318" HEIGHT="120"> </p>

<p>Когда флоппи-диск вставляется в дисковод, с
обеих сторон (сверху и снизу) к нему прижимаются
магнитные головки. Они действительно
прижимаются, зазора между головками и
поверхностью флоппи-диска нет. </p>

<p>С помощью специального шагового двигателя
головки могут перемещаться скачкообразно вдоль
радиуса диска, как бы прочерчивая по поверхности
диска концентрические окружности. Эти
окружности называются дорожками, треками или
цилиндрами - в литературе можно встретить
различные названия: </p>

<p><img SRC="img00006.gif" WIDTH="343" HEIGHT="286"> </p>

<p>Жесткий диск состоит из нескольких жестких
круглых пластинок, покрытых магнитным
материалом: </p>

<p><img SRC="img00007.gif" WIDTH="442" HEIGHT="185"> </p>

<p>Эти пластинки вращаются с огромной скоростью
(порядка 3600 оборотов в минуту) в герметичном
корпусе. Как и для флоппи-диска, около каждой
стороны пластинки располагается по одной
магнитной головке, но эти головки не
соприкасаются с поверхностью диска, а плавают на
воздушной подушке в непосредственной близости
от диска. </p>

<p>Подавая команды дисковому контроллеру,
программа может перемещать блок головок вдоль
радиуса диска, переходя таким образом от одного
цилиндра к другому. Такие команды обычно
выдаются не прикладной программой, а модулями <u>BIOS</u><font
SIZE="1">BIOS</font>, обслуживающими дисковый накопитель.
Однако при необходимости программа может сама
управлять положением блока головок. </p>

<p>Перемещаясь вдоль окружности дорожки,
магнитная головка может записывать или
считывать информацию примерно так, как это
происходит в бытовом магнитофоне. Запись
производится по битам, при этом добавляется
различная служебная информация и информация для
контроля правильности данных. </p>

<p>Данные записываются не сплошным потоком, а
блоками определенного размера. Эти блоки
называются секторами. Сектор - это наименьший
объем данных, который записывается или
прочитывается контроллером. Для сектора
выполняется контроль правильности записи или
чтения. При записи сектора вычисляется
контрольная сумма всех байтов, находящихся в
секторе, и эта контрольная сумма записывается на
диск в служебную область, находящуюся после
сектора. При чтении эта контрольная сумма
вычисляется заново и сравнивается со считанной
из служебной области. При несовпадении
контроллер сообщает программе об ошибке. </p>

<p>Дорожки нумеруются начиная от нулевой, головки
тоже начиная от нулевой, а вот сектора - начиная с
первого. Почему так было сделано - сказать трудно,
но именно такая нумерация используется при
работе с контроллером диска и функциями
прерывания <u>BIOS</u><font SIZE="1">BIOS</font>, обслуживающими
дисковую подсистему. </p>

<p>Итак, подведем некоторые итоги. 

<ul>
  <li>С точки зрения программы, работающей с
    контроллером НГМД или НМД, диск разбит на
    дорожки. </li>
  <li>Каждый диск обслуживают несколько головок, в
    зависимости от количества круглых пластинок,
    покрытых магнитным материалом, из которых
    состоит диск. </li>
  <li>Информация записывается и читается блоками,
    поэтому все дорожки как бы разбиты на сектора. </li>
  <li>В операциях чтения или записи на физическом
    уровне необходимо указывать номер дорожки (0,1,...),
    головки (0,1,...), номер сектора (1,2,...). </li>
</ul>

<p>На самом деле для правильной работы с дисками
на физическом уровне программа должна
располагать существенно большей информацией о
дисках, чем просто номера дорожек или головок.
Например, она должна знать, сколько головок и
сколько дорожек имеет то или иное дисковое
устройство, сколько байтов содержится в одном
секторе и многое другое. </p>

<p>Следущий раздел книги посвящен тому, как узнать
конфигурацию дисковой подсистемы и основные
параметры установленных дисковых накопителей. </p>

<h3><a NAME="ch1_3">1.3. Характеристики дисководов</a></h3>

<p>Прежде чем начать работу с дисками на
физическом уровне, необходимо выяснить
конфигурацию дисковой подсистемы - сколько
дисководов и какого типа подключено к
компьютеру, сколько дорожек и головок имеется на
каждом из дисководов и т.п. Способ, которым
определяется конфигурация дисковой подсистемы,
зависит от модели компьютера (PC, XT, AT), поэтому
вначале займемся определением типа
персонального компьютера. </p>

<p>ПЗУ BIOS <font SIZE="1">BIOS</font>содержит по адресу <b>FFFF:FFFE</b>
байт, значение которого можно использовать для
идентификации типа компьютера: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="56">FF</td>
    <td WIDTH="317">оригинальный IBM PC</td>
  </tr>
  <tr>
    <td WIDTH="56">FE</td>
    <td WIDTH="317">XT, Portable PC</td>
  </tr>
  <tr>
    <td WIDTH="56">FD</td>
    <td WIDTH="317">PCjr</td>
  </tr>
  <tr>
    <td WIDTH="56">FC</td>
    <td WIDTH="317">AT</td>
  </tr>
  <tr>
    <td WIDTH="56">FB</td>
    <td WIDTH="317">XT с памятью 640 К на материнской плате </td>
  </tr>
  <tr>
    <td WIDTH="56">F9</td>
    <td WIDTH="317">Convertible PC</td>
  </tr>
</table>

<p>Для компьютеров IBM PC и IBM XT конфигурация
дисковой подсистемы определяется установкой
переключателей на материнской плате, в
частности, переключателями устанавливается
количество подключенных к системе НГМД. </p>

<p>Машины IBM AT (и машины более высокого класса)
имеют на материнской плате КМОП-память с малым
энергопотреблением и питающуюся от аккумулятора
(КМОП - это технология изготовления микросхем -
КОМПЛЕМЕНТАРНАЯ пара
МЕТАЛЛ-ОКИСЕЛ-ПОЛУПРОВОДНИК). В КМОП-памяти
хранится информация о конфигурации дисковой
подсистемы, при инициализации BIOS считывает эту
информацию и записывает ее в свою внутреннюю
область данных. </p>

<p>Для определения модели компьютера мы
предлагаем следующую функцию: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      pc_model
*
*.Title     Определить модель компьютера
*
*.Descr     Функция возвращает байт, идентифицирующий
*           модель персонального компьютера
*
*.Params    Нет
*
*.Return    Код модели персонального компьютера:
*
*              0xff - оригинальный PC;
*              0xfe - XT, Portable PC;
*              0xfd - PCjr;
*              0xfc - AT;
*              0xfb - XT с памятью 640К;
*              0xf9 - Convertible PC.
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

char unsigned pc_model(void) {

        char unsigned _far *modptr;

        modptr = FP_MAKE(0xf000,0xfffe);

        return *modptr;
}

</font>
</pre>

<p>Проанализировав значение, возвращаемое этой
функцией, можно сделать предварительное
заключение о конфигурации дисковой подсистемы
компьютера. Если мы получили значения <b>0xff, 0xfd, 0xf9,</b>
то наш компьютер не имеет НМД - это одна из
разновидностей IBM PC. Значения <b>0xfe, 0xfb</b> могут
соответствовать IBM XT и совместимым с ним машинам.
Такие машины могут быть оборудованы НМД. И,
наконец, значение<b> 0xfc</b> соответствует IBM AT. Для
этой машины конфигурация дисковой подсистемы
должна определяться исходя из содержимого
КМОП-памяти. </p>

<p>Следует заметить, что новые модели компьютеров
могут иметь другие, не перечисленные выше, коды
идентификации. </p>

<p>Прерывание BIOS <b>INT&nbsp;11h</b> возвращает в регистре <b>AX</b>
байт конфигурации системы, который можно
использовать для определения количества НГМД и
наличия НМД. Самый младший бит байта
конфигурации - бит <b>0</b> - содержит признак
наличия в системе НМД. Если этот бит установлен в <b>1</b>,
то НМД присутствует в системе, иначе дисковая
подсистема состоит только из накопителей на
гибких магнитных дисках. </p>

<p>Биты <b>7</b> и <b>6</b> содержат информацию о
количестве флоппи-дисков: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="117"><i>Содержимое битов 7 и 6</i></td>
    <td WIDTH="284"><i>Количество установленных
    флоппи-дисков</i> </td>
  </tr>
  <tr>
    <td WIDTH="117">00</td>
    <td WIDTH="284">1</td>
  </tr>
  <tr>
    <td WIDTH="117">01</td>
    <td WIDTH="284">2</td>
  </tr>
  <tr>
    <td WIDTH="117">10</td>
    <td WIDTH="284">3</td>
  </tr>
  <tr>
    <td WIDTH="117">11</td>
    <td WIDTH="284">4</td>
  </tr>
</table>

<p>Это прерывание лучше всего использовать для
машин XT и PC. Для машин AT необходимо исследовать
содержимое КМОП-памяти. Займемся этим. </p>

<p>КМОП-память не адресуема непосредственно из
программы, как обычная оперативная память. Для
работы с ней необходимо использовать команды
ввода/вывода в порты с адресами <b>70h</b> и <b>71h</b>.
Перед началом операции чтения/записи в порт <b>70h</b>
надо записать адрес для КМОП-памяти (<b>0...3Fh</b>).
Затем из порта <b>71h</b> можно прочитать содержимое
требуемой ячейки КМОП-памяти или записать в этот
порт байт, который будет записан в КМОП-память. </p>

<p>Приведем фрагмент программы, составленной на
языке ассемблера, который считывает байт из
КМОП-памяти с адресом <b>12h</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">mov al,12h
out 70h,al ; задаем адрес в КМОП-памяти
jmp $+2    ; небольшая задержка
in al,71h  ; записываем в AL считанное значение
</font>
</pre>

<p>Запись в КМОП-память выполняется аналогично. </p>

<p>При анализе конфигурации дисковой подсистемы
для нас представляют наибольший интерес ячейки
КМОП-памяти со следующими адресами: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">14h - байт конфигурации
</font>
</pre>

<p>Биты <b>7, 6</b> этого байта имеют такое же значение,
что и в младшем байте слова конфигурации,
возвращаемого прерыванием BIOS <b>INT&nbsp;11h</b> - они
содержат информацию о количестве установленных
дисководов для флоппи-дисков. </p>

<p>Значение бита <b>0</b>, равное нулю, говорит о том,
что система не содержит НГМД. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">10h - тип используемых флоппи-дисков
</font>
</pre>

<p>Младшая и старшая тетрады этого байта
описывают соответственно второй и первый НГМД: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="67"><b>0000</b></td>
    <td WIDTH="246">дисковод не установлен; </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>0001</b></td>
    <td WIDTH="246">дисковод на 360К; </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>0010</b></td>
    <td WIDTH="246">дисковод на 1,2М. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>0011</b></td>
    <td WIDTH="246">дисковод на 720К. </td>
  </tr>
  <tr>
    <td WIDTH="67"><b>0100</b></td>
    <td WIDTH="246">дисковод на 1.44М. </td>
  </tr>
</table>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">12h - тип жестких дисков C: и D:
</font>
</pre>

<p>Этот байт разделен на две тетрады аналогично
байту, описывающему НГМД. Однако в тетраде можно
закодировать только <b>16</b> различных значений, а
типов НМД значительно больше. Поэтому тип <b>15</b>
используется специальным образом - если тип НМД в
младшей тетраде (диск&nbsp;<b>C:</b>) равен <b>15</b>, то
правильное значение типа находится в КМОП-памяти
по адресу <b>19h</b>. Аналогично для диска <b>D:</b> этот
тип можно взять из байта по адресу <b>1Ah</b> (если
старшая тетрада байта с адресом <b>12h</b> равна <b>15</b>).
</p>

<p>Если в вашем компьютере установлены диски с
интерфейсом ESDI или SCSI или другим
специализированным интерфейсом, то как правило,
для работы с ними используется специальный
&quot;дисковый&quot; BIOS. При этом в КМОП-памяти в
ячейке <b>12h</b> для типа диска может быть указано
нулевое значение, несмотря на то, что диск
установлен. Прерывание BIOS<b> INT&nbsp;11h</b> скажет вам,
что в системе имеется НМД. </p>

<p>Если используется &quot;дисковый&quot; BIOS, то он сам
инициализирует таблицу параметров диска и
выполняет обработку дискового прерывания <b>INT&nbsp;13h</b>.
Так как MS-DOS для работы использует именно это
прерывание, то не возникает никаких проблем,
связанных с отсутствием типа диска в КМОП-памяти.
Другие операционные системы, такие как XENIX и OS/2,
могут использовать для работы с диском
собственные драйверы. При установке они могут
запрашивать информацию о типе установленного
диска. </p>

<p>Если ваша машина содержит дисковый BIOS, то не
исключено, что у вас будут проблемы при установке
операционных систем XENIX и OS/2. В этом случае
необходимо убедиться в том, что устанавливаемая
операционная система содержит драйверы для
работы с вашим типом диска. </p>

<p>Теперь мы готовы к тому, чтобы определить
конфигурацию дисковой подсистемы - количество и
типы используемых дисководов. </p>

<p>Приведем функцию, которая заполнит структуру
типа <b>DISK_CONFIG</b>, описанную в файле <b>sysp.h,</b>
информацией о конфигурации дисковой подсистемы. </p>

<p>Структура <b>DISK_CONFIG </b>содержит поля: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="93">n_floppy</td>
    <td WIDTH="341">количество установленных в системе
    НГМД. </td>
  </tr>
  <tr>
    <td WIDTH="93">n_hard </td>
    <td WIDTH="341">количество установленных жестких НМД. </td>
  </tr>
  <tr>
    <td WIDTH="93">t_floppy1</td>
    <td WIDTH="341">тип первого НГМД. </td>
  </tr>
  <tr>
    <td WIDTH="93">t_floppy2</td>
    <td WIDTH="341">тип второго НГМД. </td>
  </tr>
  <tr>
    <td WIDTH="93">t_hard1</td>
    <td WIDTH="341">тип первого НМД.</td>
  </tr>
  <tr>
    <td WIDTH="93">t_hard2</td>
    <td WIDTH="341">тип второго НМД.</td>
  </tr>
</table>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      disk_cfg
*
*.Title     Определить конфигурацию дисковой подсистемы
*
*.Descr     Функция заполняет структуру, описывающую
*           конфигурацию дисковой подсистемы:
*
*              typedef struct _DISK_CONFIG_ {
*                 int  n_floppy;
*                 int  n_hard;
*                 int  t_floppy1;
*                 int  t_floppy2;
*                 int  t_hard1;
*                 int  t_hard2;
*              } DISK_CONFIG;
*
*
*.Params    Нет
*
*.Return    Ничего
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void disk_cfg(DISK_CONFIG* cfg) {

        char unsigned _far *modptr;
        char unsigned pc_type;
        char cfg_byte;
        int  cfg_word;

        union REGS inregs, outregs;


// Определяем тип компьютера

        modptr = FP_MAKE(0xf000,0xfffe);
        pc_type = *modptr;

// В зависимости от типа компьютера выбираем
// способ определения конфигурации дисковой
// подсистемы

        switch (pc_type) {

                case 0xfc:

// Для IBM AT считываем конфигурацию дисковой
// подсистемы из КМОП-памяти

// Считываем байт конфигурации

                        outp(0x70, 0x14);
                        cfg_byte = inp(0x71);

// Определяем количество установленных флоппи-дисков

                        if((cfg_byte &amp; 1) == 0) {

// Если младший бит байта конфигурации равен 0,
// флоппи-диски не установлены

                                cfg-&gt;n_floppy  = 0;
                                cfg-&gt;t_floppy1 = 0;
                                cfg-&gt;t_floppy2 = 0;

                        }
                        else {

// Определяем количество установленных
// флоппи-дисков

                                cfg-&gt;n_floppy = ((cfg_byte &gt;&gt; 6) &amp; 3) + 1;

// Определяем типы флоппи-дисков

                                outp(0x70, 0x10);
                                cfg_byte = inp(0x71);

                                cfg-&gt;t_floppy2 = cfg_byte &amp; 0xf;
                                cfg-&gt;t_floppy1 = (cfg_byte &gt;&gt; 4) &amp; 0xf;

                        }

// Определяем конфигурацию жестких дисков

                        outp(0x70, 0x12);
                        cfg_byte = inp(0x71);

                        if(cfg_byte == 0) {

// Если обе тетрады равны нулю, система
// не содержит жестких дисков

                                cfg-&gt;n_hard  = 0;
                                cfg-&gt;t_hard1 = 0;
                                cfg-&gt;t_hard2 = 0;
                        }
                        else {

// Определяем тип первого диска - диска C:

                                if((cfg_byte &amp; 0xf) != 0xf)
                                        cfg-&gt;t_hard1 = cfg_byte &amp; 0xf;

                                else {
                                        outp(0x70, 0x19);
                                        cfg-&gt;t_hard1 = inp(0x71);
                                }

// Определяем тип второго диска - диска D:

                                if((cfg_byte &amp; 0xf0) != 0xf0)
                                        cfg-&gt;t_hard2 = (cfg_byte &gt;&gt; 4) &amp; 0xf;

                                else {
                                        outp(0x70, 0x1a);
                                        cfg-&gt;t_hard2 = inp(0x71);
                                }

                        }

// Вычисляем количество установленных
// в системе жестких дисков

                        cfg-&gt;n_hard = 0;
                        if(cfg-&gt;t_hard1 != 0) cfg-&gt;n_hard++;
                        if(cfg-&gt;t_hard2 != 0) cfg-&gt;n_hard++;

// Для некоторых совместимых с IBM AT машин невозможно
// определить тип диска, так как в КМОП-памяти для
// типа диска установлено значение 0, несмотря на то,
// что диск установлен (например машина Bondwell,
// модель В-300). В таких случаях можно определить
// наличие жесткого диска, используя слово
// конфигурации, возвращаемое прерыванием INT 11h.

                        if(cfg-&gt;n_hard == 0) {

                                int86(0x11, &amp;inregs, &amp;outregs);
                                cfg_word = outregs.x.ax;

// Определяем наличие жесткого диска

                                if((cfg_word &amp; 1) != 0) {

                                        cfg-&gt;n_hard =  1;

// Считаем, что тип используемого жесткого
// диска неопределен

                                        cfg-&gt;t_hard1 = 0;
                                        cfg-&gt;t_hard2 = 0;

                                }
                        }

                break;

                default:

// Для остальных типов компьютеров вызываем
// прерывание INT 11h, используем возвращаемый
// этим прерыванием байт конфигурации

                        int86(0x11, &amp;inregs, &amp;outregs);
                        cfg_word = outregs.x.ax;

// Определяем количество установленных
// флоппи-дисков

                        cfg-&gt;n_floppy = ((cfg_word &gt;&gt; 6) &amp; 3) + 1;

// Считаем, что тип используемого флоппи-диска
// неопределен

                        cfg-&gt;t_floppy1 = 0;
                        cfg-&gt;t_floppy2 = 0;

// Определяем наличие жесткого диска

                        if((cfg_word &amp; 1) != 0) {

                                cfg-&gt;n_hard =  1;

// Считаем, что тип используемого жесткого
// диска неопределен

                                cfg-&gt;t_hard1 = 0;
                                cfg-&gt;t_hard2 = 0;

                        }

                break;

        }

}
</font>
</pre>

<p>Пользуясь приведенной выше функцией мы всегда
сможем определить количество дисководов для
флоппи-дисков и жестких дисков, но не всегда
сможем определить их тип. Это само по себе не
страшно, так как для работы с дисками на
физическом уровне нам надо знать не столько тип
диска, сколько другие его характеристики, такие
как количество головок, секторов и др. Эти
характеристики можно определить из таблиц
параметров для дискет и жестких дисков,
заполняемых модулями BIOS процессе инициализации
системы. </p>

<p>Приведем сокращенную таблицу параметров для
стандартных типов жестких дисков, возвращаемых
функцией <b>disk_cfg</b>. Информация, которая
содержится в этой таблице, используется BIOS
процессе инициализации, когда модули BIOS
анализируют содержимое КМОП-памяти. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><i>Тип</i></td>
    <td WIDTH="111"><i>Количество цилиндров</i> </td>
    <td WIDTH="124"><i>Количество головок</i></td>
    <td WIDTH="161"><i>Емкость диска в байтах</i> </td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="111">306</td>
    <td WIDTH="124">4</td>
    <td WIDTH="161">10.653.696</td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="111">615</td>
    <td WIDTH="124">4</td>
    <td WIDTH="161">21.411.840</td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="111">615</td>
    <td WIDTH="124">6</td>
    <td WIDTH="161">32.117.760</td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="111">940</td>
    <td WIDTH="124">8</td>
    <td WIDTH="161">65.454.080</td>
  </tr>
  <tr>
    <td WIDTH="48">5</td>
    <td WIDTH="111">940</td>
    <td WIDTH="124">6</td>
    <td WIDTH="161">49.090.560</td>
  </tr>
  <tr>
    <td WIDTH="48">6</td>
    <td WIDTH="111">615</td>
    <td WIDTH="124">4</td>
    <td WIDTH="161">21.411.840</td>
  </tr>
  <tr>
    <td WIDTH="48">7</td>
    <td WIDTH="111">462</td>
    <td WIDTH="124">8</td>
    <td WIDTH="161">32.169.984</td>
  </tr>
  <tr>
    <td WIDTH="48">8</td>
    <td WIDTH="111">733</td>
    <td WIDTH="124">5</td>
    <td WIDTH="161">31.900.160</td>
  </tr>
  <tr>
    <td WIDTH="48">9</td>
    <td WIDTH="111">900</td>
    <td WIDTH="124">15 </td>
    <td WIDTH="161">117.504.000</td>
  </tr>
  <tr>
    <td WIDTH="48">10</td>
    <td WIDTH="111">820</td>
    <td WIDTH="124">3 </td>
    <td WIDTH="161">21.411.840</td>
  </tr>
  <tr>
    <td WIDTH="48">11</td>
    <td WIDTH="111">855</td>
    <td WIDTH="124">5 </td>
    <td WIDTH="161">37.209.600</td>
  </tr>
  <tr>
    <td WIDTH="48">12</td>
    <td WIDTH="111">855</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">52.093.440</td>
  </tr>
  <tr>
    <td WIDTH="48">13</td>
    <td WIDTH="111">306</td>
    <td WIDTH="124">8 </td>
    <td WIDTH="161">21.307.392</td>
  </tr>
  <tr>
    <td WIDTH="48">14</td>
    <td WIDTH="111">733</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">44.660.224</td>
  </tr>
  <tr>
    <td WIDTH="48">15</td>
    <td WIDTH="111">0</td>
    <td WIDTH="124">0</td>
    <td WIDTH="161">0</td>
  </tr>
  <tr>
    <td WIDTH="48">16</td>
    <td WIDTH="111">612</td>
    <td WIDTH="124">4 </td>
    <td WIDTH="161">21.307.392</td>
  </tr>
  <tr>
    <td WIDTH="48">17</td>
    <td WIDTH="111">977</td>
    <td WIDTH="124">5 </td>
    <td WIDTH="161">42.519.040</td>
  </tr>
  <tr>
    <td WIDTH="48">18</td>
    <td WIDTH="111">977</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">59.526.656</td>
  </tr>
  <tr>
    <td WIDTH="48">19</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">62.390.272</td>
  </tr>
  <tr>
    <td WIDTH="48">20</td>
    <td WIDTH="111">733</td>
    <td WIDTH="124">5 </td>
    <td WIDTH="161">31.900.160</td>
  </tr>
  <tr>
    <td WIDTH="48">21</td>
    <td WIDTH="111">733</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">44.660.224</td>
  </tr>
  <tr>
    <td WIDTH="48">22</td>
    <td WIDTH="111">733</td>
    <td WIDTH="124">5 </td>
    <td WIDTH="161">31.900.160</td>
  </tr>
  <tr>
    <td WIDTH="48">23</td>
    <td WIDTH="111">306</td>
    <td WIDTH="124">4 </td>
    <td WIDTH="161">10.653.696</td>
  </tr>
  <tr>
    <td WIDTH="48">24</td>
    <td WIDTH="111">977</td>
    <td WIDTH="124">5 </td>
    <td WIDTH="161">42.519.040</td>
  </tr>
  <tr>
    <td WIDTH="48">25</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">9 </td>
    <td WIDTH="161">80.216.064</td>
  </tr>
  <tr>
    <td WIDTH="48">26</td>
    <td WIDTH="111">1224</td>
    <td WIDTH="124">7 </td>
    <td WIDTH="161">74.575.872</td>
  </tr>
  <tr>
    <td WIDTH="48">27</td>
    <td WIDTH="111">1224</td>
    <td WIDTH="124">11 </td>
    <td WIDTH="161">117.190.656</td>
  </tr>
  <tr>
    <td WIDTH="48">28</td>
    <td WIDTH="111">1224</td>
    <td WIDTH="124">15 </td>
    <td WIDTH="161">159.805.440</td>
  </tr>
  <tr>
    <td WIDTH="48">29</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">8 </td>
    <td WIDTH="161">71.303.168</td>
  </tr>
  <tr>
    <td WIDTH="48">30</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">11 </td>
    <td WIDTH="161">98.041.856</td>
  </tr>
  <tr>
    <td WIDTH="48">31</td>
    <td WIDTH="111">918</td>
    <td WIDTH="124">11 </td>
    <td WIDTH="161">87.892.992</td>
  </tr>
  <tr>
    <td WIDTH="48">32</td>
    <td WIDTH="111">925</td>
    <td WIDTH="124">9 </td>
    <td WIDTH="161">72.460.800</td>
  </tr>
  <tr>
    <td WIDTH="48">33</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">10 </td>
    <td WIDTH="161">89.128.960</td>
  </tr>
  <tr>
    <td WIDTH="48">34</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">12 </td>
    <td WIDTH="161">106.954.752</td>
  </tr>
  <tr>
    <td WIDTH="48">35</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">13 </td>
    <td WIDTH="161">115.867.648</td>
  </tr>
  <tr>
    <td WIDTH="48">36</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">14 </td>
    <td WIDTH="161">124.780.544</td>
  </tr>
  <tr>
    <td WIDTH="48">37</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">2 </td>
    <td WIDTH="161">17.825.792</td>
  </tr>
  <tr>
    <td WIDTH="48">38</td>
    <td WIDTH="111">1024</td>
    <td WIDTH="124">16 </td>
    <td WIDTH="161">142.606.336</td>
  </tr>
  <tr>
    <td WIDTH="48">39</td>
    <td WIDTH="111">918</td>
    <td WIDTH="124">15 </td>
    <td WIDTH="161">119.854.080</td>
  </tr>
  <tr>
    <td WIDTH="48">40</td>
    <td WIDTH="111">820</td>
    <td WIDTH="124">6 </td>
    <td WIDTH="161">42.823.680</td>
  </tr>
</table>

<p>Для всех приведенных в таблице типов дисков на
цилиндре (на дорожке) располагается <b>17</b>
секторов. </p>

<p>Стандартная машина IBM XT комплектуется обычно
НМД с типом 1, тип 2 используется стандартной IBM AT.
Остальные типы НМД поддерживаются не всеми
версиями BIOS, например, типы 16...23 поддерживаются
BIOS<font SIZE="1"> </font>только тех версий, которые были
изготовлены не позднее 15/11/85. </p>

<p>Наиболее широко распространены флоппи-диски
емкостью 360К, 1.2М, 720К, 1.44М. Их параметры приведены
в следующей таблице: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><i>Тип</i></td>
    <td WIDTH="90"><i>Емкость, Кбайтов</i> </td>
    <td WIDTH="91"><i>Диаметр, дюймы</i></td>
    <td WIDTH="116"><i>Количество секторов на одну дорожку</i> </td>
    <td WIDTH="110"><i>Количество цилиндров</i></td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="90">360</td>
    <td WIDTH="91">5</td>
    <td WIDTH="116">9</td>
    <td WIDTH="110">40</td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="90">1200</td>
    <td WIDTH="91">5</td>
    <td WIDTH="116">15</td>
    <td WIDTH="110">80</td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="90">720</td>
    <td WIDTH="91">3</td>
    <td WIDTH="116">9</td>
    <td WIDTH="110">40</td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="90">1440</td>
    <td WIDTH="91">3</td>
    <td WIDTH="116">18</td>
    <td WIDTH="110">80</td>
  </tr>
</table>

<p>Тип дискеты в приведенной таблице
соответствует возвращаемому функцией <b>disk_cfg.</b> </p>

<p>Анализируя содержимое КМОП-памяти в машинах AT
или установку переключателей конфигурации на
материнской плате в машинах PC и XT, BIOS процессе
инициализации создает таблицу параметров
дискеты <b>DPT</b> (Diskette Parameter Table), а также одну или две
таблицы параметров жесткого диска <b>HDPT</b> (Hard Disk
Parameter Table). Если имеется специальный дисковый BIOS,
то он сам создает таблицы <b>HDPT</b>. </p>

<p><b><i>Таблица параметров дискеты </i>DPT</b> имеет
длину 10 байт, ее адрес располагается в области
данных <b>BIOS</b> по адресу <b>0000:0078</b>, что
соответствует вектору прерывания<b> INT&nbsp;1Eh</b>.
Таблица содержит параметры, важные для работы
дисковода: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="75">(0) 1</td>
    <td WIDTH="82">srt_hut</td>
    <td WIDTH="354">Биты 0...3 - SRT (Step Rate Time) - задержка для
    переключения головок, лежит в пределах 1-16 мс и
    задается с интервалом 1 мс (0Fh - 1mc, 0Eh - 2 mc, 0Dh - 3 mc, ...);<br>
    биты 4...7 - задержка разгрузки головки, лежит в
    пределах 16-240 мс и задается с интервалом 16 мс (1 - 16
    mc, 2 - 32 mc, ..., 0Fh - 240 mc). </td>
  </tr>
  <tr>
    <td WIDTH="75">(+1) 1</td>
    <td WIDTH="82">dma_hlt</td>
    <td WIDTH="354">Бит 0 - значение этого бита, равное 1,
    говорит о том, что используется прямой доступ к
    памяти (DMA); <br>
    биты 2...7 - время загрузки головок HLT - интервал
    между сигналом загрузки головок и началом
    операции чтение/запись, лежит в пределах 2-254 мс и
    задается с интервалом 2 мс (1 - 2 mc, 2 - 4 mc, ..., 0FFh - 254 mc). </td>
  </tr>
  <tr>
    <td WIDTH="75">(+2) 1</td>
    <td WIDTH="82">motor_w</td>
    <td WIDTH="354">Задержка перед выключением двигателя. </td>
  </tr>
  <tr>
    <td WIDTH="75">(+3) 1</td>
    <td WIDTH="82">sec_size</td>
    <td WIDTH="354">Код размера сектора в байтах (0 - 128
    байтов, 1 - 256, 2 - 512, 3 - 1024). </td>
  </tr>
  <tr>
    <td WIDTH="75">(+4) 1</td>
    <td WIDTH="82">eot</td>
    <td WIDTH="354">Номер последнего сектора на дорожке </td>
  </tr>
  <tr>
    <td WIDTH="75">(+5) 1</td>
    <td WIDTH="82">gap_rw</td>
    <td WIDTH="354">Длина межсекторного промежутка для
    чтения/записи. </td>
  </tr>
  <tr>
    <td WIDTH="75">(+6) 1</td>
    <td WIDTH="82">dtl</td>
    <td WIDTH="354">Максимальная длина передаваемых данных,
    используется когда не задана длина сектора. </td>
  </tr>
  <tr>
    <td WIDTH="75">(+7) 1</td>
    <td WIDTH="82">gap_f</td>
    <td WIDTH="354">Длина межсекторного промежутка для
    операции форматирования. </td>
  </tr>
  <tr>
    <td WIDTH="75">(+8) 1</td>
    <td WIDTH="82">fill_char</td>
    <td WIDTH="354">Байт-заполнитель для форматирования
    (обычно используется F6h). </td>
  </tr>
  <tr>
    <td WIDTH="75">(+9) 1</td>
    <td WIDTH="82">hst</td>
    <td WIDTH="354">Время установки головки в
    миллисекундах. </td>
  </tr>
  <tr>
    <td WIDTH="75">(+10) 1</td>
    <td WIDTH="82">mot_start</td>
    <td WIDTH="354">Время запуска двигателя в 1/8 долях
    секунды. </td>
  </tr>
</table>

<p>Все времена в таблице зависят от частоты
тактового генератора контроллера НГМД,
приведенные значения соответствуют частоте 8
МГц. </p>

<p>Для удобства работы с таблицей параметров
дискеты файл <b>sysp.h</b> содержит определение типа <b>DPT</b>:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

typedef struct _DPT_ {
        unsigned char srt_hut;
        unsigned char dma_hlt;
        unsigned char motor_w;
        unsigned char sec_size;
        unsigned char eot;
        unsigned char gap_rw;
        unsigned char dtl;
        unsigned char gap_f;
        unsigned char fill_char;
        unsigned char hst;
        unsigned char mot_start;
} DPT;

#pragma pack()
</font>
</pre>

<p>Адреса таблиц параметров жестких дисков <b>HDPT</b>
расположены по адресам, соответствующим
векторам прерываний <b>INT&nbsp;41h</b> (для первого
физического диска) и <b>INT&nbsp;46h</b> (для второго
физического диска). Эти таблицы имеют следующий
формат: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="88">(0) 2</td>
    <td WIDTH="101">max_cyl</td>
    <td WIDTH="327">Максимальное количество цилиндров на
    диске. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+2) 1</td>
    <td WIDTH="101">max_head</td>
    <td WIDTH="327">Максимальное количество магнитных
    головок. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+3) 2</td>
    <td WIDTH="101">srwcc</td>
    <td WIDTH="327">Начальный цилиндр для предварительной
    записи (Starting reduced-write current cylinder). </td>
  </tr>
  <tr>
    <td WIDTH="88">(+5) 2</td>
    <td WIDTH="101">swpc</td>
    <td WIDTH="327">Начальный цилиндр для предварительной
    компенсации при записи (Starting write precompensation cylinder). </td>
  </tr>
  <tr>
    <td WIDTH="88">(+7) 1</td>
    <td WIDTH="101">max_ecc</td>
    <td WIDTH="327">Максимальная длина блока коррекции
    ошибок ECC (Maximum ECC data burst length). </td>
  </tr>
  <tr>
    <td WIDTH="88">(+8) 1</td>
    <td WIDTH="101">dstopt</td>
    <td WIDTH="327">Опции устройства:<br>
    бит 7 - запрет восстановления; <br>
    бит 6 - запрет восстановления по блоку коррекции
    ошибок ECC (Error Correction Code);<br>
    биты 2-0 - опции устройства. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+9) 1</td>
    <td WIDTH="101">st_del</td>
    <td WIDTH="327">Стандартная величина задержки. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+10) 1</td>
    <td WIDTH="101">fm_del</td>
    <td WIDTH="327">Величина задержки для форматирования
    диска. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+11) 1</td>
    <td WIDTH="101">chk_del</td>
    <td WIDTH="327">Величина задержки для проверки диска. </td>
  </tr>
  <tr>
    <td WIDTH="88">(+12) 4</td>
    <td WIDTH="101">reserve</td>
    <td WIDTH="327">Зарезервировано. </td>
  </tr>
</table>

<p>Файл <b>sysp.h</b> содержит соответствующее
определение типа <b>HDPT</b>: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

typedef struct _HDPT_ {
        unsigned max_cyl;
        unsigned char max_head;
        unsigned srwcc;
        unsigned swpc;
        unsigned char max_ecc;
        unsigned char dstopt;
        unsigned char st_del;
        unsigned char fm_del;
        unsigned char chk_del;
        char reserve[4];
} HDPT;

#pragma pack()
</font>
</pre>

<p>Наиболее полезная информация, которую можно
извлечь из таблицы параметров дискеты - это код
размера сектора. Если вам когда-либо понадобится
работать с нестандартным размером сектора (512
байтов), вам не обойтись без этой таблицы. </p>

<p>Таблица параметров жесткого диска содержит
такие важнейшие значения, как максимальное
количество цилиндров и максимальное количество
головок. Если вам не удалось определить тип
диска, то таблица <b>HDPT</b> - единственное надежное
место, откуда можно получить информацию о
цилиндрах и головках. </p>

<p>Для удобства использования таблиц параметров
дискет и дисков мы подготовили следующие
функции: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      get_dpt
*
*.Title     Вычислить адрес таблицы параметров дискеты
*
*.Descr     Функция возвращает указатель на таблицу
*           параметров дискеты
*
*.Params    Нет
*
*.Return    Указатель на таблицу параметров дискеты DPT
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

DPT _far *get_dpt(void) {
void _far * _far *ptr;

        ptr = (void _far * _far *)FP_MAKE(0x0,0x78);
        return(*ptr);
}
/**
*.Name      get_hdp1
*
*.Title     Вычислить адрес таблицы параметров диска 1
*
*.Descr     Функция возвращает указатель на таблицу
*           параметров диска 1
*
*.Params    Нет
*
*.Return    Указатель на таблицу параметров диска 1 HDPT
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

HDPT _far *get_hdp1(void) {
void _far * _far *ptr;

        ptr = (void _far * _far *)FP_MAKE(0x0,0x104);
        return(*ptr);

}
/**
*.Name      get_hdp2
*
*.Title     Вычислить адрес таблицы параметров диска 2
*
*.Descr     Функция возвращает указатель на таблицу
*           параметров диска 2
*
*.Params    Нет
*
*.Return    Указатель на таблицу параметров диска 2 HDPT
**/

#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

HDPT _far *get_hdp2(void) {
void _far * _far *ptr;

        ptr = (void _far * _far *)FP_MAKE(0x0,0x118);
        return(*ptr);

}
</font>
</pre>

<p>В качестве примера приведем программу, которая
определяет конфигурацию дисковой подсистемы и
отображает основные характеристики
используемых дисководов. Программа обращается к
таблицам параметров НГМД и НМД: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);
void main(void) {

  DISK_CONFIG cfg;
  DPT  _far *dpt_ptr;
  HDPT _far *hdpt1_ptr;
  HDPT _far *hdpt2_ptr;

  printf(&quot;\n&quot;
                        &quot;\nКонфигурация дисковой подсистемы&quot;
                        &quot;\n  (C)Фролов А., 1991&quot;
                        &quot;\n&quot;);

// Определяем конфигурацию дисковой подсистемы

  disk_cfg(&amp;cfg);

  printf(&quot;\nУстановлено:&quot;
                        &quot;\n   Флоппи-дисков: %d&quot;
                        &quot;\n   Дисков:        %d&quot;,
                        cfg.n_floppy,
                        cfg.n_hard);

  printf(&quot;\nТипы флоппи-дисков:  A: - %d, B: - %d&quot;
                        &quot;\nТипы дисков:         C: - %d, D: - %d&quot;,
                        cfg.t_floppy1, cfg.t_floppy2,
                        cfg.t_hard1,   cfg.t_hard2);

// Получаем адрес таблицы параметров дискеты

  dpt_ptr = get_dpt();

  printf(&quot;\n&quot;
                        &quot;\nКод размера сектора дискеты:                   %d&quot;
                        &quot;\nЗаполняющий символ для форматирования дискеты: %2.2X&quot;,
                        dpt_ptr-&gt;sec_size,
                        dpt_ptr-&gt;fill_char);

// Получаем адреса первой и второй таблицы
// параметров жесткого диска

  hdpt1_ptr = get_hdp1();
  hdpt2_ptr = get_hdp2();

  printf(&quot;\n&quot;
                        &quot;\nПараметры первого диска:&quot;
                        &quot;\n   Количество цилиндров:     %d&quot;
                        &quot;\n   Количество головок:       %d&quot;
                        &quot;\n&quot;
                        &quot;\nПараметры второго диска:&quot;
                        &quot;\n   Количество цилиндров:     %d&quot;
                        &quot;\n   Количество головок:       %d&quot;,
                        hdpt1_ptr-&gt;max_cyl,
                        hdpt1_ptr-&gt;max_head,
                        hdpt2_ptr-&gt;max_cyl,
                        hdpt2_ptr-&gt;max_head);

}
</font>
</pre>

<h3><a NAME="ch1_4">1.4. Программирование контроллера НГМД</a>
</h3>

<p>Большинство дисковых операций можно выполнить
на уровне функций BIOS. Это самый простой и
надежный способ работы с диском на физическом
уровне. Однако в отдельных случаях вам может
потребоваться непосредственный доступ к
контроллеру НГМД - например, если вы
разрабатываете систему защиты данных от
копирования. </p>

<p>Информация, приведенная в этом разделе,
ориентирована прежде всего не на выполнение
операций чтения/записи (которые лучше выполнять
с помощью функций BIOS), а на управление
контроллером и получение состояния контроллера.
Именно эти возможности требуются для
организации защиты данных от копирования. </p>

<p>Для лучшего понимания работы контроллера мы
приведем схему расположения зон данных на
дорожке флоппи-диска: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">+­­­­­­­­+      Прединдексный синхронизирующий промежуток
¦   FF   ¦
¦   00   ¦
+­­­­­­­­¦      Индексная адресная метка
¦  IAM   ¦
+­­­­­­­­¦      Промежуток 1
¦        ¦
+­­­­­­­­¦      Сектор 1
¦        ¦
+­­­­­­­­¦      Промежуток GPL
¦        ¦
+­­­­­­­­¦      Сектор 2
¦        ¦
+­­­­­­­­¦      Промежуток GPL
¦        ¦
+­­­­­­­­¦
¦        ¦
¦ * * *  ¦
¦        ¦
+­­­­­­­­¦      Промежуток GPL
¦        ¦
+­­­­­­­­¦      Сектор N
¦        ¦
+­­­­­­­­¦      Промежуток GPL
¦        ¦
+­­­­­­­­¦      Конечный промежуток
¦        ¦
+­­­­­­­­+
</font>
</pre>

<p>Каждый сектор на дорожке состоит из областей
индексных данных и данных. Сектора разделены
промежутком <b>GPL</b>, в конце дорожки располагается
конечный промежуток, его размер зависит от
скорости вращения диска, длин секторов и других
промежутков. Область индексных данных содержит
информацию о номере дорожки, головки, сектора,
код длины сектора. Область данных содержит сами
данные. Приведем формат сектора: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">+­­­­­­­­+      Адресная метка индексных данных
¦  IDAM  ¦
+­­­­­­­­¦      Номер дорожки
¦        ¦
+­­­­­­­­¦      Номер головки
¦        ¦
+­­­­­­­­¦      Номер сектора
¦        ¦
+­­­­­­­­¦      Код длины сектора
¦        ¦
+­­­­­­­­¦      Два байта циклического контроля
¦        ¦
+­­­­­­­­¦      Промежуток
¦   FF   ¦
¦   00   ¦
+­­­­­­­­¦      Адресная метка данных
¦        ¦
+­­­­­­­­¦      Данные
¦        ¦
¦********¦
¦        ¦
+­­­­­­­­¦      Два байта циклического контроля
¦        ¦
+­­­­­­­­+
</font>
</pre>

<p>Программа обращается к контроллеру для
выполнения различных операций с помощью команд
ввода/вывода. Для машин IBM&nbsp;PC и XT используются
три порта с адресами <b>3F2h, 3F4h</b> и <b>3F5h</b>. В машинах
класса AT дополнительно используются два порта с
адресами <b>3F6h</b> и <b>3F7h</b>. </p>

<p>Порт <b>3F2h</b> работает только на запись, это порт
вывода. С его помощью можно выбирать для работы
один из дисководов (одновременно можно работать
только с одним дисководом), сбрасывать
контроллер в исходное состояние, разрешать или
запрещать прерывания от контроллера и работу
схем прямого доступа к памяти, включать или
выключать двигатели дисководов. </p>

<p>Назначение отдельных битов этого порта: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="68">0-1</td>
    <td WIDTH="370">Выбор дисковода. Машины AT не используют
    бит 1, так как в этих машинах только два НГМД. </td>
  </tr>
  <tr>
    <td WIDTH="68">2</td>
    <td WIDTH="370">0 - сброс контроллера; <br>
    1 - разрешение работы контроллера. </td>
  </tr>
  <tr>
    <td WIDTH="68">3</td>
    <td WIDTH="370">1 - разрешение прерываний и прямого
    доступа к памяти. </td>
  </tr>
  <tr>
    <td WIDTH="68">4-7</td>
    <td WIDTH="370">Значение 1 в каждом разряде вызывает
    включение соответствующего двигателя дисковода.
    Для машин AT биты 6-7 не используются. </td>
  </tr>
</table>

<p>Порт <b>3F4h</b> предназначен только для чтения. С
его помощью можно получить байт основного
состояния контроллера. Назначение битов: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0-3</td>
    <td WIDTH="422">Значение 1 говорит о том, что
    соответствующий дисковод занят, он выполняет
    операцию поиска. Для машины AT биты 2-3 не
    используются. </td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="422">Контроллер занят выполнением команды
    чтения или записи. </td>
  </tr>
  <tr>
    <td WIDTH="48">5</td>
    <td WIDTH="422">0 - используется режим прямого доступа к
    памяти; <br>
    1 - режим прямого доступа к памяти не
    используется. </td>
  </tr>
  <tr>
    <td WIDTH="48">6</td>
    <td WIDTH="422">Направление передачи данных:<br>
    0 - от процессора к контроллеру; <br>
    1 - от контроллера к процессору. </td>
  </tr>
  <tr>
    <td WIDTH="48">7</td>
    <td WIDTH="422">Запрос на передачу данных - контроллер
    готов к записи или чтению данных. </td>
  </tr>
</table>

<p>Порт <b>3F5h</b> предназначен для записи или чтения
данных. Он используется при всех операциях
контроллера. </p>

<p>Выполнение любой операции начинается с того,
что программа посылает в этот порт байт кода
операции, за которым следует один или несколько
байтов параметров. Количество байтов параметров
и их назначение зависит от кода операции (т.е. от
первого байта). После выполнения операции
программа считывает несколько байтов результата
для анализа правильности выполнения операции. </p>

<p>Порт <b>3F7h</b> работает на запись и чтение, он
используется только в машинах AT. </p>

<p>При записи биты<b> 0-1</b> определяют скорость
передачи данных: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">00</td>
    <td WIDTH="330">500 Кбайтов/с (высокая плотность HD); </td>
  </tr>
  <tr>
    <td WIDTH="48">01</td>
    <td WIDTH="330">300 Кбайтов/с (двойная плотность DD); </td>
  </tr>
  <tr>
    <td WIDTH="48">10</td>
    <td WIDTH="330">250 Кбайтов/с (одинарная плотность SD); </td>
  </tr>
  <tr>
    <td WIDTH="48">11</td>
    <td WIDTH="330">зарезервировано.</td>
  </tr>
</table>

<p>Приведем назначение отдельных битов порта 3F7h
для чтения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="332">1 - выбран дисковод 0</td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="332">1 - выбран дисковод 1</td>
  </tr>
  <tr>
    <td WIDTH="48">2-5</td>
    <td WIDTH="332">Выбраны головки, бит 2 соответствует
    головке 0, бит 3 - головке 1 и т.д. </td>
  </tr>
  <tr>
    <td WIDTH="48">6</td>
    <td WIDTH="332">Переключатель записи.</td>
  </tr>
  <tr>
    <td WIDTH="48">7</td>
    <td WIDTH="332">1 - признак замены дискеты. </td>
  </tr>
</table>

<p>Контроллер НГМД может выполнять 15 операций, или
команд. Выполнение команды разделяется на три
фазы - командная фаза, фаза выполнения, фаза
результата. В командной фазе программа должна
передать контроллеру всю информацию,
необходимую для выполнения команды. В фазе
выполнения команда выполняется, и в фазе
результата программа получает от контроллера
информацию о состоянии контроллера. </p>

<p>Информация, необходимая для выполнения
команды, передается контроллеру через порт
данных <b>3F5h</b>. В соответствии с форматом команды
программа должна последовательно вывести в этот
порт код команды и все параметры. </p>

<p>Прежде чем программа начнет командную фазу, она
должна убедиться в том, что контроллер завершил
выполнение предыдущей операции и готов к приему
команды. Для этого программа должна считать байт
основного состояния контроллера из порта с
адресом <b>3F4h</b> и проверить биты <b>6</b> и <b>7</b>. Бит <b>6</b>
должен быть установлен в <b>0</b>. Это означает, что
данные будут передаваться от процессора к
контроллеру. Бит <b>7</b> должен быть установлен в <b>1</b>
- это готовность контроллера к приему команды. </p>

<p>Фаза выполнения начинается после установки
битов <b>6</b> и <b>7</b> байта основного состояния в <b>1</b>.
После завершения выполнения команды контроллер
формирует сигнал запроса прерывания. </p>

<p>В фазе результата процессор считывает
состояние контроллера. Это состояние хранится в
нескольких внутренних регистрах контроллера: </p>

<p><b>RS</b> - регистр основного состояния; </p>

<p><b>ST0, ST1, ST2, ST3</b> - регистры дополнительного
состояния. </p>

<p>Регистр основного состояния доступен через
порт <b>3F4h</b>, содержимое остальных регистров
процессор считывает после выполнения
контроллером команды через порт данных <b>3F5h</b>. </p>

<p>Приведем форматы для всех команд контроллера
НГМД. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Команда Байты команды

Чтение данных
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦SK ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение удаленных данных
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
        ¦       MT ¦MFM¦SK ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦ 0 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Запись данных
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Запись удаленных данных
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение данных с дорожки
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦SK ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до &quot;равно&quot;
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦SK ¦ 1 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до &quot;меньше&quot; или &quot;равно&quot;
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦SK ¦ 1 ¦ 1 ¦ 0 ¦ 0 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Сканирование до &quot;больше&quot; или &quot;равно&quot;
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦MT ¦MFM¦SK ¦ 1 ¦ 1 ¦ 1 ¦ 0 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Форматирование дорожки
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 0 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Считывание индексных данных
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦MFM¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 1 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Инициализация
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение состояния прерывания
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦ 0 ¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Определить параметры
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Чтение состояния накопителя
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 0 ¦ 0 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+

Поиск
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 1 ¦ 1 ¦ 1 ¦ 1 ¦
                +­­­+­­­+­­­+­­­+­­­+­­­+­­­+­­­¦
                ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦ 0 ¦HDS¦DS1¦DS0¦
                +­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
</font>
</pre>

<p>Первые несколько команд имеют одинаковый
формат параметров и байтов результата. </p>

<p>Приведем байты параметров, которые должны
следовать за командами и байты результата,
которые процессор должен считать после
выполнения команды. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="145"><i>Команда</i></td>
    <td WIDTH="169"><i>Байты параметров</i> </td>
    <td WIDTH="185"><i>Байты результата</i></td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение данных</td>
    <td WIDTH="169">C, H, R, N, EOT,EOT, GPL, DTL </td>
    <td WIDTH="185">ST0, ST1, ST2,C, H, R, N</td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение удаленных данных</td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Запись данных</td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Запись удаленных данных</td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение данных с дорожки</td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Сканирование до &quot;равно&quot;</td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Сканирование до &quot;меньше&quot; или
    &quot;равно&quot; </td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Сканирование до &quot;больше&quot; или
    &quot;равно&quot; </td>
    <td WIDTH="169">&nbsp;</td>
    <td WIDTH="185">&nbsp;</td>
  </tr>
  <tr>
    <td WIDTH="145">Форматирование дорожки</td>
    <td WIDTH="169">N, SC, GPL, D </td>
    <td WIDTH="185">ST0, ST1, ST2,C, H, R, N</td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение индексных данных</td>
    <td WIDTH="169">отсутствуют </td>
    <td WIDTH="185">ST0, ST1, ST2,C, H, R, N</td>
  </tr>
  <tr>
    <td WIDTH="145">Инициализация</td>
    <td WIDTH="169">отсутствуют </td>
    <td WIDTH="185">отсутствуют</td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение состояния прерывания</td>
    <td WIDTH="169">отсутствуют </td>
    <td WIDTH="185">ST0, PCN</td>
  </tr>
  <tr>
    <td WIDTH="145">Определить параметры</td>
    <td WIDTH="169">1 байт:<br>
    мл. тетрада - HUT<br>
    ст. тетрада - SRT <br>
    <br>
    2 байт:<br>
    бит 0 - ND<br>
    биты 1-7 - HLT </td>
    <td WIDTH="185">отсутствуют</td>
  </tr>
  <tr>
    <td WIDTH="145">Чтение состояния накопителя</td>
    <td WIDTH="169">отсутствуют </td>
    <td WIDTH="185">ST3</td>
  </tr>
  <tr>
    <td WIDTH="145">Поиск</td>
    <td WIDTH="169">C</td>
    <td WIDTH="185">отсутствуют </td>
  </tr>
</table>

<p>После выполнения команды центральный
процессор должен получить от контроллера байты
результата. Среди них - содержимое внутренних
регистров состояния контроллера <b>ST0, ST1, ST2, ST3</b>.
Опишем назначение отдельных битов этих
регистров. </p>

<p>Формат регистра ST0: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="88"><i>Биты</i></td>
    <td WIDTH="94"><i>Название</i> </td>
    <td WIDTH="329"><i>Назначение</i></td>
  </tr>
  <tr>
    <td WIDTH="88">1, 0</td>
    <td WIDTH="94">US1, US2</td>
    <td WIDTH="329">Эти биты содержат код накопителя при
    прерывании </td>
  </tr>
  <tr>
    <td WIDTH="88">2</td>
    <td WIDTH="94">HD</td>
    <td WIDTH="329">Номер головки. </td>
  </tr>
  <tr>
    <td WIDTH="88">3</td>
    <td WIDTH="94">NC</td>
    <td WIDTH="329">Накопитель не готов,
    устанавливается,если накопитель не готов
    выполнить команду чтения или записи. </td>
  </tr>
  <tr>
    <td WIDTH="88">4</td>
    <td WIDTH="94">EC</td>
    <td WIDTH="329">Сбой оборудования </td>
  </tr>
  <tr>
    <td WIDTH="88">5</td>
    <td WIDTH="94">SE</td>
    <td WIDTH="329">Завершена команда &quot;Поиск&quot; </td>
  </tr>
  <tr>
    <td WIDTH="88">7, 6</td>
    <td WIDTH="94">I, C</td>
    <td WIDTH="329">Код прерывания:<br>
    00 - нормальное завершение;<br>
    01 - аварийное завершение;<br>
    10 - некорректная команда;<br>
    11 - нет готовности дисковода. </td>
  </tr>
</table>

<p>Формат регистра ST1: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="87"><i>Биты</i></td>
    <td WIDTH="93"><i>Название</i> </td>
    <td WIDTH="334"><i>Назначение</i></td>
  </tr>
  <tr>
    <td WIDTH="87">0</td>
    <td WIDTH="93">MA</td>
    <td WIDTH="334">Пропуск адресной метки. Этот бит
    устанавливается в 1, если контроллер не может
    найти адресную метку </td>
  </tr>
  <tr>
    <td WIDTH="87">1</td>
    <td WIDTH="93">NN</td>
    <td WIDTH="334">Защита записи, устанавливается , если
    при выполнении операции контроллер получает от
    дисковода сигнал защиты записи. </td>
  </tr>
  <tr>
    <td WIDTH="87">2</td>
    <td WIDTH="93">ND</td>
    <td WIDTH="334">Не найден сектор. </td>
  </tr>
  <tr>
    <td WIDTH="87">3</td>
    <td WIDTH="93">-</td>
    <td WIDTH="334">Зарезервирован </td>
  </tr>
  <tr>
    <td WIDTH="87">4</td>
    <td WIDTH="93">OR</td>
    <td WIDTH="334">Переполнение, процессор не успевает
    выполнять обмен данными с контроллером </td>
  </tr>
  <tr>
    <td WIDTH="87">5</td>
    <td WIDTH="93">DE</td>
    <td WIDTH="334">Ошибка в данных при проверке
    контрольной суммы </td>
  </tr>
  <tr>
    <td WIDTH="87">6</td>
    <td WIDTH="93">-</td>
    <td WIDTH="334">Зарезервирован. </td>
  </tr>
  <tr>
    <td WIDTH="87">7</td>
    <td WIDTH="93">EN</td>
    <td WIDTH="334">Несуществующий сектор, устанавливается,
    когда контроллер пытается прочесть сектор с
    адресом, большим существующего. </td>
  </tr>
</table>

<p>Формат регистра ST2: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="88"><i>Биты</i></td>
    <td WIDTH="91"><i>Название</i> </td>
    <td WIDTH="338"><i>Назначение</i></td>
  </tr>
  <tr>
    <td WIDTH="88">0</td>
    <td WIDTH="91">MD</td>
    <td WIDTH="338">Пропущен адресный маркер в поле данных. </td>
  </tr>
  <tr>
    <td WIDTH="88">1</td>
    <td WIDTH="91">BC</td>
    <td WIDTH="338">Нечитающаяся дорожка. </td>
  </tr>
  <tr>
    <td WIDTH="88">2</td>
    <td WIDTH="91">SN</td>
    <td WIDTH="338">Ошибка сканирования. Устанавливается,
    если при выполнении команды сканирования
    контроллер не может найти требуемую дорожку. </td>
  </tr>
  <tr>
    <td WIDTH="88">3</td>
    <td WIDTH="91">SH</td>
    <td WIDTH="338">Сканирование выполнено, дорожка
    найдена. </td>
  </tr>
  <tr>
    <td WIDTH="88">4</td>
    <td WIDTH="91">WC</td>
    <td WIDTH="338">Ошибка адреса дорожки. </td>
  </tr>
  <tr>
    <td WIDTH="88">5</td>
    <td WIDTH="91">DD</td>
    <td WIDTH="338">Ошибка в поле данных. </td>
  </tr>
  <tr>
    <td WIDTH="88">6</td>
    <td WIDTH="91">CM</td>
    <td WIDTH="338">Во время операции чтения или
    сканирования не обнаружен сектор с маркером
    удаленных данных. </td>
  </tr>
  <tr>
    <td WIDTH="88">7</td>
    <td WIDTH="91">-</td>
    <td WIDTH="338">Зарезервирован. </td>
  </tr>
</table>

<p>Формат регистра ST3: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="88"><i>Биты</i></td>
    <td WIDTH="91"><i>Название</i> </td>
    <td WIDTH="341"><i>Назначение</i></td>
  </tr>
  <tr>
    <td WIDTH="88">1, 0</td>
    <td WIDTH="91">US1, US2</td>
    <td WIDTH="341">Код выбранного дисковода. </td>
  </tr>
  <tr>
    <td WIDTH="88">2</td>
    <td WIDTH="91">HD</td>
    <td WIDTH="341">Номер выбранной головки. </td>
  </tr>
  <tr>
    <td WIDTH="88">3</td>
    <td WIDTH="91">TS</td>
    <td WIDTH="341">Используется режим двухсторонней
    записи. </td>
  </tr>
  <tr>
    <td WIDTH="88">4</td>
    <td WIDTH="91">T0</td>
    <td WIDTH="341">Головка установлена на дорожку 0. </td>
  </tr>
  <tr>
    <td WIDTH="88">5</td>
    <td WIDTH="91">RDY</td>
    <td WIDTH="341">Дисковод готов к работе. </td>
  </tr>
  <tr>
    <td WIDTH="88">6</td>
    <td WIDTH="91">WP</td>
    <td WIDTH="341">Защита записи на диске. </td>
  </tr>
  <tr>
    <td WIDTH="88">7</td>
    <td WIDTH="91">FT</td>
    <td WIDTH="341">Неисправность дисковода. </td>
  </tr>
</table>

<p>Дополнительно перед выполнением операции и
после ее завершения надо проанализировать
содержимое описанного выше регистра основного
состояния контроллера RS. </p>

<p>В форматах команд и таблицах используются
следующие обозначения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="59">MT</td>
    <td WIDTH="433">двухсторонняя операция</td>
  </tr>
  <tr>
    <td WIDTH="59">MFM</td>
    <td WIDTH="433">двойная/одинарная плотность записи </td>
  </tr>
  <tr>
    <td WIDTH="59">SK</td>
    <td WIDTH="433">пропуск удаленных данных </td>
  </tr>
  <tr>
    <td WIDTH="59">HDS</td>
    <td WIDTH="433">номер головки для двухстороннего
    накопителя </td>
  </tr>
  <tr>
    <td WIDTH="59">DS1, DS0</td>
    <td WIDTH="433">номер выбираемого накопителя </td>
  </tr>
  <tr>
    <td WIDTH="59">C</td>
    <td WIDTH="433">номер цилиндра</td>
  </tr>
  <tr>
    <td WIDTH="59">H</td>
    <td WIDTH="433">номер головки для двухстороннего
    накопителя </td>
  </tr>
  <tr>
    <td WIDTH="59">R</td>
    <td WIDTH="433">номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="59">N</td>
    <td WIDTH="433">число байтов в секторе</td>
  </tr>
  <tr>
    <td WIDTH="59">EOT</td>
    <td WIDTH="433">номер последнего сектора на дорожке </td>
  </tr>
  <tr>
    <td WIDTH="59">GPL</td>
    <td WIDTH="433">размер промежутка</td>
  </tr>
  <tr>
    <td WIDTH="59">DTL</td>
    <td WIDTH="433">число считываемых/записываемых байтов </td>
  </tr>
  <tr>
    <td WIDTH="59">SC</td>
    <td WIDTH="433">число секторов в цилиндре </td>
  </tr>
  <tr>
    <td WIDTH="59">D</td>
    <td WIDTH="433">данные</td>
  </tr>
  <tr>
    <td WIDTH="59">PCN</td>
    <td WIDTH="433">номер цилиндра после выполнения команды
    чтения состояния прерывания </td>
  </tr>
  <tr>
    <td WIDTH="59">SRT</td>
    <td WIDTH="433">время шага, мс</td>
  </tr>
  <tr>
    <td WIDTH="59">HUT</td>
    <td WIDTH="433">время разгрузки головки </td>
  </tr>
  <tr>
    <td WIDTH="59">HLT</td>
    <td WIDTH="433">время загрузки головки </td>
  </tr>
  <tr>
    <td WIDTH="59">ND</td>
    <td WIDTH="433">режим прерывания</td>
  </tr>
  <tr>
    <td WIDTH="59">NCN</td>
    <td WIDTH="433">номер цилиндра после поиска </td>
  </tr>
</table>

<p><i><b>Команда &quot;Определить параметры&quot;</b></i>
задает времена задержки для трех внутренних
таймеров контроллера. Первый байт параметров
состоит из двух полей - <b>SRT</b> и <b>HUT</b>. Поле <b>SRT</b>
задает временной интервал между шаговыми
импульсами двигателя перемещения головки. Это
поле имеет ширину 4 бита. Поле <b>HUT</b> определяет
время разгрузки головки и тоже имеет ширину 4
бита. </p>

<p>Второй байт параметров состоит из полей <b>HLT</b> и
<b>ND</b>. Поле <b>HLT</b> имеет ширину 7 битов и
определяет время загрузки головки. Бит <b>ND</b>
определяет использование канала прямого доступа
- если этот бит установлен в 0, то ПДП
используется, иначе обмен данными идет через
центральный процессор. </p>

<p>Параметры для команды &quot;Определить
параметры&quot; лучше всего взять из таблицы
параметров дискеты, заполняющейся BIOS во время
инициализации системы. Конечно, если вам нужны
нестандартные параметры, вы можете попробовать
использовать свои, ориентируясь на значения из
таблицы параметров дискеты. </p>

<p><i><b>Команда &quot;Инициализация&quot;</b></i> может
выполняться одновременно для всех накопителей.
По этой команде головки перемещаются на нулевую
дорожку. </p>

<p><i><b>Команда &quot;Поиск&quot;</b></i> используется для
установки головки на нужную дорожку. Поиск может
выполняться одновременно для нескольких
накопителей. </p>

<p><i><b>Команда &quot;Чтение состояния прерывания&quot; </b></i>может
вырабатываться после завершения других команд
для выяснения состояния контроллера после
прерывания. Эту команду удобно использовать
после команд &quot;Поиск&quot; или
&quot;Инициализация&quot;. </p>

<p>После поступления <i><b>команды &quot;Чтение
данных&quot;</b></i> загружается головка, контроллер
считывает метки адреса идентификатора <b>ID</b> и
поля <b>ID</b>. Контроллер последовательно считывает
номера секторов, и как только считанный номер
совпадет с требуемым, считывает данные сектора
байт за байтом и передает их либо центральному
процессору, либо каналу прямого доступа к памяти.
При передаче данных контроллер должен
обслуживаться каждые <b>27</b> мкс в режиме
одинарной плотности и <b>13</b> мкс в режиме двойной
плотности, иначе в регистре состояния <b>ST3</b>
устанавливается флаг переполнения OR<b>.</b> </p>

<p>Если контроллер не может найти нужный сектор,
то в регистре <b>ST1</b> устанавливается флаг
отсутствия данных <b>ND</b>. При ошибке считывания
данных, обнаруженной схемами избыточного
циклического контроля <b>CRC</b>, устанавливается
флаг ошибки данных <b>DE</b>. </p>

<p>При считывании адресной метки удаленных данных
в регистре <b>ST2</b> и сброшенном в <b>0</b> бите <b>SK</b>
команды флаг <b>CM</b> устанавливается в <b>1</b>,
читаются все данные из этого сектора, затем
выполнение команды прекращается. </p>

<p>Поле команды <b>MT</b> позволяет задать выполнение
многодорожечной операции, при которой
контроллер считывает данные с обеих сторон
дискеты. Поле <b>MFM</b> определяет плотность
обрабатываемой информации: значение <b>0</b>
соответствует одинарной плотности, <b>1</b> -
двойной. </p>

<p>Если поле команды <b>N</b> содержит <b>0</b>, то поле <b>DTL</b>
определяет объем передаваемых данных. Если поле <b>N</b>
содержит отличное от нуля значение, поле <b>DTL</b>
игнорируется и должно содержать значение <b>0FFh</b>. </p>

<p>Выполнение<i><b> команды &quot;Запись&quot;</b></i>
аналогично. В режиме записи обмен данными
процессора с контроллером должен происходить
каждые <b>31</b> мкс в режиме одинарной плотности и
каждые <b>15</b> мкс в режиме двойной плотности. </p>

<p><i><b>По команде &quot;Запись удаленных данных&quot; </b></i>в
начале поля данных записывается адресная метка
удаленных данных вместо обычной адресной метки
данных. </p>

<p><i><b>По команде &quot;Чтение данных дорожки&quot;</b></i>
считываются все поля данных с каждого сектора
дорожки как непрерывные блоки данных. С помощью
этой команды можно производить многодорожечные
операции, пропуски. </p>

<p><i><b>Команда &quot;Чтение индексных данных&quot;</b></i>
позволяет определить положение головки. </p>

<p><i><b>Команда &quot;Форматирование дорожки&quot;</b></i>
форматирует всю дорожку - на нее записываются
интервалы, адресные метки, поля индексных данных
и поля данных. Вам не обязательно располагать
сектора в порядке увеличения номеров, т.к. при
форматировании контроллер запрашивает
параметры <b>C, H, R, N.</b> </p>

<p><b>Группа команд &quot;Сканирование&quot; </b>позволяет
сравнивать данные, поступающие от контроллера и
от центрального процессора. Контроллер
выполняет побайтное сравнение и ищет сектор,
удовлетворяющий заданному условию. При
выполнении условия сканирования в регистре
состояния <b>ST2</b> устанавливается флаг <b>SH</b>, в
противном случае - флаг <b>SN</b>. </p>

<p>Как пользоваться всеми этими командами? </p>

<p>Выполнив сброс контроллера, вам надо его
проинициализировать, задав все рабочие
параметры. Затем можно выдавать контроллеру
команды, каждый раз проверяя регистр его
основного состояния <b>ST</b> и анализируя байты
результата <b>ST0...ST3</b>. Можно предложить следующую
последовательность действий: 

<ul>
  <li>Сброс контроллера выдачей в порт <b>3F2h</b> байта с
    битом <b>2</b>, установленным в <b>0</b>. </li>
  <li>Разрешение работы контроллера выдачей в этот же
    порт байта с битом <b>2</b>, установленным в <b>1</b>. </li>
  <li>Выдача контроллеру команды
    &quot;Инициализация&quot;. </li>
  <li>Выдача контроллеру команды &quot;Определить
    параметры&quot;. </li>
  <li>Включить двигатель и выждать примерно 0,5 с
    (время разгона двигателя). </li>
  <li>Установить головки в нужное положение командой
    &quot;Поиск&quot;. </li>
  <li>Проверить результаты установки командой
    &quot;Чтение состояния прерывания&quot;. </li>
  <li>Для машины AT установить нужную скорость
    передачи данных, выдав в порт <b>3F7h</b> байт с
    соответствующим значением: <b>0</b> для дискет с
    высокой плотностью записи (HD), <b>1</b> для двойной
    плотности (DD) и <b>2</b> для одинарной (SD). </li>
  <li>Если установка головок произведена правильно,
    можно выдавать команды чтения/записи данных.
    Перед этим надо правильно запрограммировать
    контроллер прямого доступа к памяти, если вы
    собираетесь использовать режим ПДП. </li>
</ul>

<p>Программирование контроллера прямого доступа
к памяти будет подробно описано во втором томе
книги, сейчас мы приведем только основные
сведения, необходимые для того, чтобы
разобраться в программе, демонстрирующей
использование команд контроллера НГМД. </p>

<p>Контроллер прямого доступа к памяти (КПДП)
имеет несколько каналов и для машин AT состоит из
двух микросхем Intel 8237A. Контроллер НГМД
использует канал <b>2</b>. </p>

<p>Перед началом инициализации КПДП программа
должна послать в порты <b>0Bh</b> и <b>0Ch</b> код
операции, которая будет выполняться КПДП - <b>46h</b>
для операции чтения и <b>4Ah</b> для операции записи. </p>

<p>В процессе инициализации программа должна
сообщить КПДП адрес буфера, куда ему следует
поместить данные или откуда надо взять данные, и
длину передаваемых данных в байтах. </p>

<p>Адрес необходимо представить в виде номера
страницы и смещения. Для КПДП машины AT
используется восьмибитовый номер страницы и
16-битовое смещение. Например, для адреса 23456 номер
страницы - 2, смещение - 3456. </p>

<p>Для программирования канала 2 КПДП программа
должна сначала вывести младший байт смещения в
порт с адресом <b>4</b>, затем вывести в этот же порт
старший байт смещения и, наконец, вывести байт
номера страницы в порт с адресом <b>81h</b>. </p>

<p>Длина передаваемых данных выводится
аналогично в порт с адресом <b>5</b> - сначала
младший байт длины, затем старший. </p>

<p>После определения режима работы канала, адреса
буфера и длины передаваемых данных, программа
должна разрешить работу КПДП, выдав в порт с
адресом <b>0Ch</b> байт <b>2</b>. Теперь канал прямого
доступа готов к работе и будет ждать данных от
контроллера НГМД. </p>

<p>Приведенная ниже демонстрационная программа
использует несколько наиболее характерных
команд контроллера НГМД. Она предназначена для
работы на машине AT. Для того, чтобы она правильно
работала и на машинах PC/XT, ее надо немного
изменить. Изменения касаются программирования
контроллера ПДП и программирования скорости
передачи контроллера НГМД. </p>

<p>Контроллер КПДП PC/XT использует 4-битовый номер
страницы буфера вместо 8-битового. Скорость
передачи контроллера НГМД в машинах PC/XT не
программируется, вам надо убрать
соответствующие строки из программы. Еще надо
обратить внимание на различное быстродействие
машин AT и PC/XT и скорректировать константы в
строках программы, выполняющих задержку. </p>

<p>Программа не проверяет, установлен ли
флоппи-диск в приемный карман дисковода, поэтому
перед запуском не забудьте установить диск. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

#define CYL 0

void main(void);
void fdc_out(unsigned char byte);
int  fdc_inp(void);
void int_wait(void);
void dma_init(char *);

void main(void) {

        unsigned i;
        long l;
        char buffer[512];
        char status[7], main_status;
        DPT _far *fdpt;
        FILE *sect;

        printf(&quot;\n&quot;
                 &quot;\nРабота с контроллером НГМД&quot;
                 &quot;\n  (C)Фролов А., 1991&quot;
                 &quot;\n&quot;);


// Эта программа предназначена только для IBM AT

        if(pc_model() != 0xfc) {
                printf(&quot;Эта программа предназначена только для IBM AT\n&quot;);
                exit(-1);
        }

// Открываем файл, в который будем записывать
// содержимое самого первого сектора на дискете

        sect = fopen(&quot;!sector.dat&quot;,&quot;wb+&quot;);

// Устанавливаем указатель на таблицу
// параметров дискеты

        fdpt = get_dpt();

// Включаем мотор дисковода А:
// Перед этим разрешаем прерывания

     _enable();
        outp(0x3F2, 0x1C);

// Выполняем задержку для разгона двигателя

        for(l=0;l&lt;200000;l++);

// Показываем содержимое регистра основного
// состояния контроллера

        printf(&quot;Мотор включен.\t\t&quot;);
        printf(&quot;Основное состояние: %02.2X\n&quot;,inp(0x3F4));

// Перед чтением сектора необходимо установить
// головку на нужную дорожку, в нашем случае это
// дорожка с номером CYL.

// Выдаем контроллеру команду &quot;Поиск&quot;

        fdc_out(0xf);

// Для команды &quot;Поиск&quot; требуется два байта параметров:
// номер головки/номер накопителя и номер дорожки.
// Мы работаем с нулевой головкой накопителя А:,
// поэтому первый параметр равен 0, второй - CYL

        fdc_out(0);
        fdc_out(CYL);

// Показываем содержимое регистра основного
// состояния контроллера

        printf(&quot;\n&lt;&lt;&lt;Поиск&gt;&gt;&gt; \t\t&quot;);
        printf(&quot;Основное состояние: %02.2X\n&quot;,inp(0x3F4));

// Ожидаем прерывание по завершению операции

        int_wait();

// Задержка для позиционирования головки

        for(l=0;l&lt;20000;l++);

// Для проверки результата выполнения команды
// &quot;Поиск&quot; выдаем контроллеру команду
// &quot;Чтение состояния прерывания&quot;

// Выводим содержимое регистра состояния
// ST0  и номер дорожки после выполнения команды
// &quot;Поиск&quot; PCN

        fdc_out(0x8);
        printf(&quot;Состояние прерывания:\t&quot;);
        printf(&quot; ST0: %02.2X, \t&quot;, fdc_inp());
        printf(&quot;PCN: %02.2X\n&quot;, fdc_inp());

// Для более глубокой диагностики состояния
// контроллера выдаем контроллеру команду
// &quot;Чтение состояния накопителя&quot;, выводим
// содержимое регистра состояния ST3

        fdc_out(4);
        fdc_out(0);
        printf(&quot;Состояние накопителя:\t ST3: %02.2X\n&quot;,fdc_inp());

// Устанавливаем скорость передачи данных 500 Кбайтов/с,
// это значение может различаться для разных типов дискет

        outp(0x3F7, 0);

// Инициализация канала прямого
// доступа к памяти

        dma_init(buffer);

// Выдаем команду &quot;Чтение данных&quot;

        fdc_out(0x66);
        fdc_out(0x0);     // накопитель 0, головка 0

        fdc_out(CYL);     // цилиндр CYL
        fdc_out(0);       // головка 0
        fdc_out(1);       // номер сектора - 1

// Передаем контроллеру технические параметры
// дисковода, берем их из таблицы параметров дискеты.
// Это такие параметры:
//    - размер сектора;
//    - номер последнего сектора на дорожке;
//    - размер промежутка;
//    - число считываемых/записываемых байтов

        fdc_out(fdpt-&gt;sec_size);
        fdc_out(fdpt-&gt;eot);
        fdc_out(fdpt-&gt;gap_rw);
        fdc_out(fdpt-&gt;dtl);

// Ожидаем прерывание по завершению операции

        int_wait();

// Считываем и выводим на экран байты результата
// операции &quot;Чтение данных&quot;

        printf(&quot;\n&lt;&lt;&lt;Чтение сектора&gt;&gt;&gt; \n&quot;);
        printf(&quot;   Байты состояния (ST0,ST1,ST2,C,H,R,N):\n&quot;);

        for(i=0; i&lt;7; i++) printf(&quot;%02.2X\t&quot;, (char) fdc_inp());
        printf(&quot;\n&quot;);

// Выводим содержимое считанного сектора в файл

        for(i=0; i&lt;512; i++) fputc(buffer[i],sect);
        fclose(sect);

// Выключаем мотор

        outp(0x3F2, 0xC);
}


// Вывод байта в контроллер дисковода

void fdc_out(unsigned char parm) {

        _asm {
                mov   dx,3F4h     // Порт основного состояния
loop_fdc_out:

                in    al,dx
                test  al,80h      // Проверяем готовность
                jz loop_fdc_out   //   контроллера

                inc   dx          // Выводим байт в порт данных
                mov   al, parm    //   контроллера
                out   dx, al
        }
}

// Ввод байта из порта данных контроллера дисковода

int fdc_inp(void) {

        _asm {
                mov   dx,3F4h     // Порт основного состояния
loop_fdc_inp:
                in    al,dx
                test  al,80h      // Проверяем готовность
                jz loop_fdc_inp   //   контроллера

                inc   dx          // Введенный байт записываем
                in    al, dx      // в регистр AX
        }
}

// Ожидание прерывания от контроллера

void int_wait(void) {

// Разрешаем прерывания

        _enable();
        _asm {
                mov   ax,40h         // После прихода прерывания
                mov   es,ax          // программа обработки прерывания
                mov   bx,3Eh         // устанавливает в 1 старший бит
wait_loop:                     // байта в области данных BIOS
                mov   dl,es:[bx]     // по адресу 0040:003E.
                test  dl,80h         // Мы ждем, когда этот бит будет
                jz    wait_loop      // установлен в 1, а затем
                                                 // сбрасываем его.
                and   dl,01111111b
                mov   es:[bx],dl
        }
}

// Инициализация канала прямого доступа к памяти

void dma_init(char *buf) {

        unsigned long f_adr;
        unsigned sg, of;

// Вычисляем 24-разрядный адрес буфера для данных

        f_adr = ((unsigned long)_psp &lt;&lt; 4)
                                + (((unsigned long)buf) &amp; 0xffff);

// Расщепляем адрес на номер страницы
// и смещение

        sg = (f_adr &gt;&gt; 16) &amp; 0xff;
        of = f_adr &amp; 0xffff;

// На время программирования контроллера прямого
// доступа запрещаем прерывания

        _disable();

        _asm {
                mov   al,46h   // Команда чтения данных от
                                        // контроллера НГМД.

                out   12,al    // Сброс триггера-указателя байта
                                        // для работы с 16-разрядными портами.
                                        // Следующий байт, выводимый в 16-разрядный
                                        // порт будет интерпретироваться
                                        // как младший.

                out   11,al    // Установка режима контроллера ПДП

                mov   ax,of    // Смещение буфера, младший байт
                out   4,al
                mov   al,ah    // Смещение буфера, старший байт
                out   4,al

                mov   ax,sg    // Номер страницы
                out   81h,al

                mov   ax,511   // Длина передаваемых данных
                out   5,al
                mov   al,ah
                out   5,al

                mov   al,2     // Разблокировка канала 2 контроллера ПДП
                out   10,al
        }

// Инициализация контроллера закончена,
// разрешаем прерывания.

        _enable();
}
</font>
</pre>

<p>Остальные команды вы можете попробовать сами.
Для получения дополнительной информации по
контроллеру НГМД обратитесь к техническому
руководству по IBM PC. Многое можно почерпнуть из
описания микросхем дискового контроллера 765
фирмы NEC и аналогов этой микросхемы - Intel 8272A и
отечественной КР1810ВГ72А. </p>

<h3><a NAME="ch1_5">1.5. Функции BIOS для работы с дисками</a> </h3>

<p>Наилучшим и самым безопасным способом работы с
дисками на физическом уровне является
использование функций BIOS. Эти функции учитывают
все особенности аппаратуры и предоставляют
достаточно широкий набор средств доступа к
дискам на физическом уровне. </p>

<p>Вся дисковая подсистема обслуживается
прерыванием BIOS<b> INT&nbsp;13h</b>. Это прерывание
выполняет множество функций. Для вызова
определенной функции программа должна занести
ее код в регистр <b>AH</b>, другие регистры, как
правило, должны содержать параметры - номера
используемых дисководов, цилиндров, головок,
адреса таблиц параметров дискеты и жесткого
диска и т.д. </p>

<p>Библиотека транслятора Microsoft QC 2.5 содержит
специальную функцию <b>_bios_disk(),</b> сильно
упрощающую работу с дисковыми функциями BIOS. В
примерах программ, приведенных в книге, мы
продемонстрируем как непосредственный вызов
прерывания <b>INT&nbsp;13h,</b> так и использование
функции <b>_bios_disk()</b>. </p>

<p>Мы приведем краткую таблицу функций прерывания
<b>INT&nbsp;13h,</b> после чего займемся детальным
описанием этих функций. В примечании к описанию
функций мы будем указывать типы компьютеров, на
которых данная функция работоспособна. </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">00h</td>
    <td WIDTH="432">Сброс дисковой подсистемы </td>
  </tr>
  <tr>
    <td WIDTH="48">01h</td>
    <td WIDTH="432">Получить состояние дисковой подсистемы </td>
  </tr>
  <tr>
    <td WIDTH="48">02h</td>
    <td WIDTH="432">Чтение сектора</td>
  </tr>
  <tr>
    <td WIDTH="48">03h</td>
    <td WIDTH="432">Запись сектора</td>
  </tr>
  <tr>
    <td WIDTH="48">04h</td>
    <td WIDTH="432">Проверка сектора</td>
  </tr>
  <tr>
    <td WIDTH="48">05h</td>
    <td WIDTH="432">Форматирование дорожки </td>
  </tr>
  <tr>
    <td WIDTH="48">06h</td>
    <td WIDTH="432">Форматирование дорожки (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">07h</td>
    <td WIDTH="432">Форматирование диска (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">08h</td>
    <td WIDTH="432">Получить текущие параметры дисковода
    (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">09h</td>
    <td WIDTH="432">Инициализация таблиц параметров
    жесткого диска </td>
  </tr>
  <tr>
    <td WIDTH="48">0Ah</td>
    <td WIDTH="432">Чтение длинное (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="48">0Bh</td>
    <td WIDTH="432">Запись длинная (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="48">0Ch</td>
    <td WIDTH="432">Поиск цилиндра (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="48">0Dh</td>
    <td WIDTH="432">Альтернативный сброс дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">0Eh</td>
    <td WIDTH="432">Чтение буфера сектора (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">0Fh</td>
    <td WIDTH="432">Запись буфера сектора (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">10h</td>
    <td WIDTH="432">Проверка готовности дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">11h</td>
    <td WIDTH="432">Рекалибровка дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">12h</td>
    <td WIDTH="432">Проверка памяти контроллера (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">13h</td>
    <td WIDTH="432">Проверка дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">14h</td>
    <td WIDTH="432">Проверка контроллера (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">15h</td>
    <td WIDTH="432">Получить тип дисковода </td>
  </tr>
  <tr>
    <td WIDTH="48">16h</td>
    <td WIDTH="432">Проверка замены диска</td>
  </tr>
  <tr>
    <td WIDTH="48">17h</td>
    <td WIDTH="432">Установка типа дискеты </td>
  </tr>
  <tr>
    <td WIDTH="48">18h</td>
    <td WIDTH="432">Установка среды носителя данных для
    форматирования </td>
  </tr>
  <tr>
    <td WIDTH="48">19h</td>
    <td WIDTH="432">Парковка головок (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="48">1Ah</td>
    <td WIDTH="432">Форматирование диска (ESDI НМД) </td>
  </tr>
</table>

<h4><font SIZE="2">1.5.1 Сброс дисковой подсистемы</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="122">На входе:</td>
    <td WIDTH="382">AH = 00h</td>
  </tr>
  <tr>
    <td WIDTH="122">&nbsp;</td>
    <td WIDTH="382">DL = Адрес дисковода (0, 1, ...,80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="122">На выходе:</td>
    <td WIDTH="382">-</td>
  </tr>
  <tr>
    <td WIDTH="122">Примечание:</td>
    <td WIDTH="382">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Эта функция вызывает сброс и рекалибровку
дискового контроллера (головки устанавливаются
на нулевой цилиндр). Если в адресе дисковода
старший бит (бит 7) установлен в 1, выполняется
сброс контроллера НМД. Сброс рекомендуется
выполнять после того, как произошла ошибка при
выполнении других операций, таких как чтение или
запись. После сброса можно попытаться повторить
операцию. </p>

<p>Адрес дисковода 0 соответствует первому
флоппи-диску (A:), 1 - второму (B:) и т.д. Адреса 80, 81
соответствуют первому и второму физическим
накопителям на жестком магнитном диске. </p>

<h4><font SIZE="2">1.5.2 Получить состояние дисковой
подсистемы</font> </h4>

<table BORDER="1">
  <tr>
    <td WIDTH="124">На входе:</td>
    <td WIDTH="380">AH = 01</td>
  </tr>
  <tr>
    <td WIDTH="124">&nbsp;</td>
    <td WIDTH="380">DL = Адрес дисковода (0, 1, ...,80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="124">На выходе:</td>
    <td WIDTH="380">AL = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="124">Примечание:</td>
    <td WIDTH="380">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Эта функция может быть использована для
анализа результата выполнения дисковой операции
и получения кода ошибки. Передаваемый в регистре
AL код ошибки функция берет из области данных BIOS -
из байта с адресом 0000:0441h. </p>

<p>Код ошибки может принимать следующие значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="64">00h</td>
    <td WIDTH="429">Успешное завершение операции </td>
  </tr>
  <tr>
    <td WIDTH="64">01h</td>
    <td WIDTH="429">Неправильная команда</td>
  </tr>
  <tr>
    <td WIDTH="64">02h</td>
    <td WIDTH="429">Не найдена адресная метка </td>
  </tr>
  <tr>
    <td WIDTH="64">03h</td>
    <td WIDTH="429">Попытка записи на диск, защищенный от
    записи </td>
  </tr>
  <tr>
    <td WIDTH="64">04h</td>
    <td WIDTH="429">Сектор не найден</td>
  </tr>
  <tr>
    <td WIDTH="64">05h</td>
    <td WIDTH="429">Ошибка при сбросе (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">06h</td>
    <td WIDTH="429">Произошла замена дискеты </td>
  </tr>
  <tr>
    <td WIDTH="64">07h</td>
    <td WIDTH="429">Неправильные параметры дисковода (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">08h</td>
    <td WIDTH="429">Переполнение канала ПДП (НГМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">09h</td>
    <td WIDTH="429">Переход за границу 64К при работе с ПДП </td>
  </tr>
  <tr>
    <td WIDTH="64">0Ah</td>
    <td WIDTH="429">Обнаружен плохой сектор (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">0Bh</td>
    <td WIDTH="429">Обнаружена плохая дорожка (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">0Ch</td>
    <td WIDTH="429">Неправильный номер дорожки </td>
  </tr>
  <tr>
    <td WIDTH="64">0Dh</td>
    <td WIDTH="429">Неправильный номер сектора при
    форматировании (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">0Eh</td>
    <td WIDTH="429">Обнаружена адресная метка управляющих
    данных (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">0Fh</td>
    <td WIDTH="429">Ошибка ПДП (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="64">10h</td>
    <td WIDTH="429">Обнаружена ошибка в CRC/ECC </td>
  </tr>
  <tr>
    <td WIDTH="64">11h</td>
    <td WIDTH="429">Данные скорректированы с
    использованием ECC (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">20h</td>
    <td WIDTH="429">Сбой контроллера</td>
  </tr>
  <tr>
    <td WIDTH="64">40h</td>
    <td WIDTH="429">Сбой при поиске дорожки </td>
  </tr>
  <tr>
    <td WIDTH="64">80h</td>
    <td WIDTH="429">Таймаут - программа не успевает
    обрабатывать данные </td>
  </tr>
  <tr>
    <td WIDTH="64">AAh</td>
    <td WIDTH="429">Дисковод не готов (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">BBh</td>
    <td WIDTH="429">Неизвестная ошибка (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">CCh</td>
    <td WIDTH="429">Сбой при записи (НМД)</td>
  </tr>
  <tr>
    <td WIDTH="64">E0h</td>
    <td WIDTH="429">Ошибка регистра состояния (НМД) </td>
  </tr>
  <tr>
    <td WIDTH="64">FFh</td>
    <td WIDTH="429">Ошибка операции считывания (НМД) </td>
  </tr>
</table>

<h4><font SIZE="2">1.5.3 Чтение сектора</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="130">На входе:</td>
    <td WIDTH="341">AH = 02h </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">AL = Количество секторов, которые нужно
    прочитать </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">CH = Номер дорожки </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">CL = Номер сектора </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">DH = Номер головки </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">DL = Адрес дисковода (0, 1, ...,80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="130">На выходе:</td>
    <td WIDTH="341">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="130">&nbsp;</td>
    <td WIDTH="341">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="130">Примечание:</td>
    <td WIDTH="341">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Эта функция позволяет прочитать один или
несколько секторов диска в буфер, находящийся в
оперативной памяти. Вам надо задать для
начального сектора номера дорожки, головки и
номер самого сектора. </p>

<p>Для НМД номер дорожки и сектора задаются
следующим образом: биты регистра CX 5...0 задают
номер сектора, а биты 15...6 - номер дорожки. </p>

<p>Перед чтением необходимо подготовить таблицу
параметров дискеты или диска (для операций с НМД).
</p>

<h4><font SIZE="2">1.5.4 Запись сектора</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="135">На входе:</td>
    <td WIDTH="355">AH = 03h</td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">AL = Количество секторов, которые нужно
    прочитать </td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="135">На выходе:</td>
    <td WIDTH="355">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="135">&nbsp;</td>
    <td WIDTH="355">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="135">Примечание:</td>
    <td WIDTH="355">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функция записи секторов аналогична предыдущей,
за исключением направления перемещения данных -
данные записываются из буфера в сектора диска.
Необходимо отметить, что при работе с НГМД не
всякий BIOS будет ожидать разгона двигателя до
рабочей скорости перед выполнением операции
записи. В результате программа может получить
признак ошибки. Прежде чем делать вывод о
причинах ошибки, следует сбросить контроллер
НГМД функцией 00H и повторить операцию записи три
раза. </p>

<h4><font SIZE="2">1.5.5 Проверка сектора</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="137">На входе:</td>
    <td WIDTH="355">AH = 04h</td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">AL = Количество секторов, которые нужно
    проверить </td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="137">На выходе:</td>
    <td WIDTH="355">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">AL = Число проверенных секторов </td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="355">CF = 1, если произошла ошибка, 0, если ошибки
    нет </td>
  </tr>
  <tr>
    <td WIDTH="137">Примечание:</td>
    <td WIDTH="355">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>С помощью этой функции можно убедиться, что
указанные сектора существуют и их можно
прочесть. Данные проверяются по методу
циклического избыточного контроля (CRC). Адрес
буфера не нужен, так как чтения данных в
оперативную память при проверке секторов не
происходит. </p>

<p>Если вы используете компьютер со старой BIOS,
выпущенной ранее 11/15/85, регистры ES:BX должны
указывать на буфер соответствующего размера, как
и при выполнении операции чтения. </p>

<p>Перед использованием этой функции убедитесь,
что мотор НГМД раскрутился до рабочей скорости, в
противном случае вы получите признак ошибки. </p>

<h4><font SIZE="2">1.5.6 Форматирование дорожки</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="126">На входе:</td>
    <td WIDTH="368">AH = 05h</td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">AL = Количество секторов, которые нужно
    создать на дорожке, или <br>
    Фактор чередования для НМД XT </td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">ES:BX = Адрес буфера формата, используется
    для НГМД и НМД машин XT </td>
  </tr>
  <tr>
    <td WIDTH="126">На выходе:</td>
    <td WIDTH="368">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="126">&nbsp;</td>
    <td WIDTH="368">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="126">Примечание:</td>
    <td WIDTH="368">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функция форматирования предназначена для
начального формирования структуры дорожки
диска, она разрушает все имеющиеся на дорожке
данные. С помощью функции 05 вы можете за один раз
отформатировать только одну дорожку с указанным
номером. </p>

<p>Для этой функции необходимо задать два
интересных параметра, на которых мы остановимся
подробнее - фактор чередования и буфер формата. </p>

<p>Что такое фактор чередования (Interleave)? </p>

<p>Этот фактор определяет последовательность
расположения секторов на дорожке. Сектора могут
располагаться в порядке своих номеров, через
один, через два и т.д. Способ размещения секторов
определяется значением фактора чередования. </p>

<p>Фактор 1 означает последовательное
расположение секторов на дорожке в порядке их
номеров, т.е. чередование отсутствует. Фактор 2
задает расположение секторов через один, 3 - через
два и т.д. На рисунке показано использование
фактора чередования при форматировании дорожки: </p>

<p><img SRC="pic7.gif" WIDTH="319" HEIGHT="241"> </p>

<p>Все утилиты, предназначенные для подготовки
жесткого диска к работе, требуют задания
величины фактора чередования при выполнении
низкоуровневого форматирования. </p>

<p>Для чего может понадобиться несмежное
расположение секторов с последовательными
номерами на дорожке диска? </p>

<p>При последовательном расположении секторов
может получиться так, что процессор не будет
успевать обрабатывать смежные сектора за один
проход дорожки. Например, программа считывает
последовательно второй и третий сектор. В момент
времени, когда второй сектор уже считан, при
быстром вращении диска к моменту начала чтения
третьего сектора головки могут оказаться в
середине третьего сектора и диск совершит еще
один оборот, прежде чем головки окажутся в начале
третьего сектора. Поэтому если программа
последовательно обращается к смежным секторам,
может получиться так, что при чтении каждого
сектора диск будет совершать один оборот. </p>

<p>Если же сектора будут расположены через один
или через два, количество оборотов диска, нужных
для обработки последовательности смежных
секторов, будет значительно меньше. </p>

<p>Для подбора оптимального фактора чередования
можно использовать специальные программы или
делать это методом проб и ошибок, задавая каждый
раз новое значение фактора и проверяя
быстродействие диска. </p>

<p>Займемся теперь буфером формата. </p>

<p>Перед вызовом функции форматирования регистры
ES:BX должны содержать полный адрес буфера формата.
Для дискет перед форматированием этот буфер
должен представлять из себя заполненный массив
четырехбайтовых элементов - номера дорожки,
головки, сектора и кода размера сектора. Код
размера сектора может иметь следующие значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="212">128 байтов на сектор</td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="212">256 байтов на сектор</td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="212">512 байтов на сектор</td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="212">1024 байтов на сектор</td>
  </tr>
</table>

<p>Количество элементов в массиве должно быть
равно количеству создаваемых на дорожке
секторов, то есть для каждого сектора буфер
формата должен содержать один описывающий его
четырехбайтовый элемент. </p>

<p>Для жесткого диска буфер формата должен
представлять из себя массив размером 512 байтов. В
начале этого массива для каждого сектора на
дорожке необходимо подготовить двухбайтовые
элементы. Первый байт содержит признак - хороший
это сектор (00) или плохой (80h). Второй байт - это
номер сектора. </p>

<p>Задавая последовательность номеров в буфере
формата соответствующим образом, программа
определяет фактор чередования. </p>

<p>Приведем пример подготовленного буфера
формата для форматирования дорожки на 17 секторов
с фактором чередования, равным 2: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">db 00h,01h,00h,0ah,00h,02h,00h,0bh,00h,03h,00h,0ch
db 00h,04h,00h,0dh,00h,05h,00h,0eh,00h,06h,00h,0fh
db 00h,07h,00h,10h,00h,08h,00h,11h,00h,09h
</font>
</pre>

<p>Отметим, что буфер формата используется только
для машин AT. Машины XT при форматировании НМД не
используют буфер формата, вместо этого значение
фактора чередования указывается при вызове
функции форматирования в регистре AL. </p>

<p>При форматировании флоппи-дисков с помощью
этой функции таблица параметров дискеты должна
содержать правильное значение количества
секторов на дорожке и другие параметры. </p>

<h4><font SIZE="2">1.5.7 Форматирование дорожки (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="123">На входе:</td>
    <td WIDTH="369">AH = 06h</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">AL = Фактор чередования</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">ES:BX = Адрес буфера формата </td>
  </tr>
  <tr>
    <td WIDTH="123">На выходе:</td>
    <td WIDTH="369">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="369">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="123">Примечание:</td>
    <td WIDTH="369">PC, XT</td>
  </tr>
</table>

<p>Функция форматирования дорожки с кодом 6
предназначена только для НМД и устанавливает
флаг плохого сектора. Буфер формата
подготавливается аналогично функции 5. </p>

<h4><font SIZE="2">1.5.8 Форматирование диска (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="140">На входе:</td>
    <td WIDTH="355">AH = 07h</td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">AL = Фактор чередования (только для XT) </td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">ES:BX = Адрес буфера формата </td>
  </tr>
  <tr>
    <td WIDTH="140">На выходе:</td>
    <td WIDTH="355">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="140">&nbsp;</td>
    <td WIDTH="355">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="140">Примечание:</td>
    <td WIDTH="355">PC, XT</td>
  </tr>
</table>

<p>Функция форматирования с кодом 7 предназначена
для форматирования целого диска начиная с
определенной дорожки. Буфер формата
подготавливается аналогично функции 5. </p>

<h4><font SIZE="2">1.5.9 Получить текущие параметры
дисковода (НМД)</font> </h4>

<table BORDER="1">
  <tr>
    <td WIDTH="127">На входе:</td>
    <td WIDTH="363">AH = 08h</td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="127">На выходе:</td>
    <td WIDTH="363">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">BL = тип дисковода (только для AT и PS2) </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">DL = количество НМД, обслуживаемых первым
    контроллером </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">DH = максимальный номер головки </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">CL = максимальный номер сектора </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">CH = максимальный номер цилиндра </td>
  </tr>
  <tr>
    <td WIDTH="127">&nbsp;</td>
    <td WIDTH="363">ES:DI = адрес таблицы параметров дисковода </td>
  </tr>
  <tr>
    <td WIDTH="127">Примечание: </td>
    <td WIDTH="363">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>С помощью этой функции программа может
определить тип дисковода, количество дисководов,
обслуживаемых первым дисковым контроллером и
другие параметры дисковода, которые нужны
программе для организации доступа к диску на
физическом уровне. Тип дисковода, возвращаемый в
регистре BL, может принимать следующие значения:<br>
</p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="256">не используется;</td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="256">360К, 40 дорожек, 5,25 дюймов; </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="256">1,2М, 80 дорожек, 5,25 дюймов; </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="256">720 К, 80 дорожек, 3,5 дюйма; </td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="256">1,44М, 80 дорожек, 3,5 дюйма. </td>
  </tr>
</table>

<h4><font SIZE="2">1.5.10 Инициализация контроллера НМД</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="121">На входе:</td>
    <td WIDTH="361">AH = 09h</td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="361">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="121">На выходе:</td>
    <td WIDTH="361">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="361">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="121">Примечание:</td>
    <td WIDTH="361">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функцию инициализации контроллера НМД
применяют после модификации таблиц параметров
жесткого диска. BIOS BIOSузнает о внесенных в таблицы
изменениях и инициализирует соответствующим
образом контроллер НМД. </p>

<h4><font SIZE="2">1.5.11 Чтение секторов длинное (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="136">На входе:</td>
    <td WIDTH="357">AH = 0Ah</td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">AL = Количество секторов, которые нужно
    прочитать </td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="136">На выходе:</td>
    <td WIDTH="357">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="136">&nbsp;</td>
    <td WIDTH="357">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="136">Примечание:</td>
    <td WIDTH="357">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функция &quot;Чтение секторов длинное&quot;
отличается от обычной функции чтения (код 02h) тем,
что она дополнительно считывает в буфер данных 4
байта кода коррекции ошибки (ECC). </p>

<h4><font SIZE="2">1.5.12 Запись секторов длинная (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="123">На входе:</td>
    <td WIDTH="368">AH = 0Bh</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">AL = Количество секторов, которые нужно
    записать </td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="123">На выходе:</td>
    <td WIDTH="368">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="123">&nbsp;</td>
    <td WIDTH="368">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="123">Примечание:</td>
    <td WIDTH="368">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функция &quot;Запись секторов длинная&quot;
отличается от обычной функции записи (код 03h) тем,
что она дополнительно записывает на диск из
буфера данных 4 байта кода коррекции ошибки (ECC). </p>

<h4><font SIZE="2">1.5.13 Поиск дорожки (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="129">На входе:</td>
    <td WIDTH="337">AH = 0Ch</td>
  </tr>
  <tr>
    <td WIDTH="129">&nbsp;</td>
    <td WIDTH="337">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="129">&nbsp;</td>
    <td WIDTH="337">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="129">&nbsp;</td>
    <td WIDTH="337">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="129">&nbsp;</td>
    <td WIDTH="337">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="129">На выходе:</td>
    <td WIDTH="337">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="129">&nbsp;</td>
    <td WIDTH="337">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="129">Примечание:</td>
    <td WIDTH="337">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>С помощью функции 0Ch программа может подвести
головки к дорожке с заданным номером. Функции
чтения/записи секторов не требуют
предварительного поиска дорожки, они выполняют
поиск сами. </p>

<h4><font SIZE="2">1.5.14 Альтернативный сброс дисковода
(НМД)</font> </h4>

<table BORDER="1">
  <tr>
    <td WIDTH="137">На входе:</td>
    <td WIDTH="333">AH = 0Dh</td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="333">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="137">На выходе:</td>
    <td WIDTH="333">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="137">&nbsp;</td>
    <td WIDTH="333">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="137">Примечание:</td>
    <td WIDTH="333">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Вы можете использовать эту функцию для сброса
контроллера вместо функции с кодом 00h. В отличие
от функции сброса дисковой подсистемы с кодом 00h
эта функция не влияет на контроллер НГМД, она
сбрасывает только контроллер накопителя на
жестком магнитном диске. </p>

<h4><font SIZE="2">1.5.15 Чтение буфера сектора (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="118">На входе:</td>
    <td WIDTH="368">AH = 0Eh</td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">AL = Количество секторов, которые нужно
    прочитать </td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="118">На выходе:</td>
    <td WIDTH="368">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="118">&nbsp;</td>
    <td WIDTH="368">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="118">Примечание:</td>
    <td WIDTH="368">PC, XT</td>
  </tr>
</table>

<p>Контроллеры НМД в компьютерах PC и XT содержат
внутренний буфер данных. С помощью функции 0Eh
программа может прочитать содержимое этого
буфера в оперативную память. Чтения данных с
диска при этом не происходит. В основном функция
чтения буфера используется для диагностики
дискового контроллера. </p>

<h4><font SIZE="2">1.5.16 Запись буфера сектора (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="115">На входе:</td>
    <td WIDTH="377">AH = 0Fh</td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">AL = Количество секторов, которые нужно
    записать </td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">CH = Номер дорожки</td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">CL = Номер сектора</td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">DH = Номер головки</td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">ES:BX = Адрес буфера для данных </td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="115">На выходе:</td>
    <td WIDTH="377">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="115">&nbsp;</td>
    <td WIDTH="377">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="115">Примечание:</td>
    <td WIDTH="377">PC, XT</td>
  </tr>
</table>

<p>Функция полностью аналогична предыдущей, за
исключением того, что происходит не чтение, а
запись данных из оперативной памяти в буфер
контроллера. Она может быть использована для
инициализации содержимого буфера сектора перед
форматированием диска функцией 05h прерывания
INT&nbsp;13h. </p>

<h4><font SIZE="2">1.5.17 Получить состояние дисковода (НМД)</font>
</h4>

<table BORDER="1">
  <tr>
    <td WIDTH="120">На входе:</td>
    <td WIDTH="368">AH = 10h</td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="368">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="120">На выходе:</td>
    <td WIDTH="368">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="368">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="120">Примечание:</td>
    <td WIDTH="368">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>О готовности дисковода можно судить по байту
состояния, передаваемому функцией в регистре AH.
Этот байт аналогичен возвращаемому в регистре AH
функцией 01h. </p>

<h4><font SIZE="2">1.5.18 Рекалибровка дисковода (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="120">На входе:</td>
    <td WIDTH="373">AH = 11h</td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="373">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="120">На выходе:</td>
    <td WIDTH="373">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="373">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="120">Примечание:</td>
    <td WIDTH="373">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Вызов функции приводит к позиционированию
головок выбранного дисковода на нулевую дорожку.
Дополнительно в регистре AH возвращается байт
состояния дисковода. </p>

<h4><font SIZE="2">1.5.19 Проверка памяти контроллера (НМД)</font>
</h4>

<table BORDER="1">
  <tr>
    <td WIDTH="121">На входе:</td>
    <td WIDTH="371">AH = 12h</td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="371">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="121">На выходе:</td>
    <td WIDTH="371">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="371">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="121">Примечание:</td>
    <td WIDTH="371">PC, XT</td>
  </tr>
</table>

<p>Эта функция предназначена для запуска
встроенной диагностики дискового контроллера,
она проверяет внутренний буфер сектора и
возвращает байт состояния. </p>

<h4><font SIZE="2">1.5.20 Проверка дисковода (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="121">На входе:</td>
    <td WIDTH="366">AH = 13h</td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="366">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="121">На выходе:</td>
    <td WIDTH="366">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="121">&nbsp;</td>
    <td WIDTH="366">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="121">Примечание:</td>
    <td WIDTH="366">PC, XT</td>
  </tr>
</table>

<p>Функция используется для запуска внутренней
диагностики контроллера. </p>

<h4><font SIZE="2">1.5.21 Проверка контроллера (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="122">На входе:</td>
    <td WIDTH="366">AH = 14h</td>
  </tr>
  <tr>
    <td WIDTH="122">На выходе:</td>
    <td WIDTH="366">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="122">&nbsp;</td>
    <td WIDTH="366">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="122">Примечание:</td>
    <td WIDTH="366">PC, XT, AT, PS/2 </td>
  </tr>
</table>

<p>Функция запускает внутреннюю диагностику
контроллера. </p>

<h4><font SIZE="2">1.5.22 Получить тип дисковода</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="122">На входе:</td>
    <td WIDTH="364">AH = 15h</td>
  </tr>
  <tr>
    <td WIDTH="122">&nbsp;</td>
    <td WIDTH="364">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="122">На выходе:</td>
    <td WIDTH="364">AH = Тип дисковода </td>
  </tr>
  <tr>
    <td WIDTH="122">&nbsp;</td>
    <td WIDTH="364">CX:DX = количество секторов размером 512
    байтов </td>
  </tr>
  <tr>
    <td WIDTH="122">Примечание:</td>
    <td WIDTH="364">AT, PS/2</td>
  </tr>
</table>

<p>Возвращаемый этой функцией тип дисковода может
принимать следующие значения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="406">диск отсутствует;</td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="406">НГМД без аппаратных средств обнаружения
    замены дискеты; </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="406">НГМД оснащенный средствами обнаружения
    замены дискеты; </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="406">НМД.</td>
  </tr>
</table>

<p>С помощью этой функции программа может
определить тип диска и возможность обнаружения
замены магнитного носителя (дискеты). </p>

<h4><font SIZE="2">1.5.23 Проверка замены диска</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="125">На входе:</td>
    <td WIDTH="357">AH = 16h</td>
  </tr>
  <tr>
    <td WIDTH="125">&nbsp;</td>
    <td WIDTH="357">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="125">На выходе:</td>
    <td WIDTH="357">AH = Признак замены дискеты: <br>
    0 - замены дискеты не было; <br>
    6 - дискета была заменена. </td>
  </tr>
  <tr>
    <td WIDTH="125">Примечание:</td>
    <td WIDTH="357">AT, PS/2</td>
  </tr>
</table>

<p>В некоторых случаях замена дискеты
нежелательна до выполнения определенных
действий (мы говорили об этом при обсуждении
драйверов дисковых устройств). С помощью этой
функции программа может убедиться в том, что в
дисководе установлена все та же дискета, что и в
начале цикла операций. Если дискета была по
ошибке заменена раньше времени, программа может
потребовать установить старую дискету для
завершения работы с ней. </p>

<h4><font SIZE="2">1.5.24 Установка типа дискеты</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="124">На входе:</td>
    <td WIDTH="369">AH = 17h</td>
  </tr>
  <tr>
    <td WIDTH="124">&nbsp;</td>
    <td WIDTH="369">AL = Устанавливаемый тип </td>
  </tr>
  <tr>
    <td WIDTH="124">&nbsp;</td>
    <td WIDTH="369">DL = Адрес дисковода (0, 1, ..., 80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="124">На выходе:</td>
    <td WIDTH="369">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="124">&nbsp;</td>
    <td WIDTH="369">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="124">Примечание:</td>
    <td WIDTH="369">AT, PS/2</td>
  </tr>
</table>

<p>Функцию установки типа дискеты необходимо
использовать перед началом работы с дискетой.
Устанавливаемый тип может принимать следующие
значения: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="328">не используется;</td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="328">диск 360К в дисководе 360К; </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="328">диск 360К в дисководе 1.2М (HD); </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="328">диск 1.2М в дисководе 1.2М; </td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="328">диск 720К в дисководе 720К. </td>
  </tr>
</table>

<p>Если перед вызовом этой функции был установлен
флаг замены дискеты, то он сбрасывается.
Дополнительно BIOS BIOSустанавливает скорость
передачи данных через контроллер НГМД в
зависимости от типа дискеты. </p>

<h4><font SIZE="2">1.5.25 Установка среды для
форматирования (НГМД)</font> </h4>

<table BORDER="1">
  <tr>
    <td WIDTH="120">На входе:</td>
    <td WIDTH="353">AH = 18h</td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">DL = Адрес дисковода (0, 1, ...) </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">CH = Младшие 8 битов количества дорожек </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">CL = Количество секторов на дорожку (биты
    0-5) </td>
  </tr>
  <tr>
    <td WIDTH="120">На выходе:</td>
    <td WIDTH="353">AH = 00h Требуемая комбинация количества
    дорожек и количества секторов на дорожку
    поддерживается операцией форматирования; </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">AH = 01h Функция недоступна; </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">AH = 0Ch Функция не поддерживается или
    неизвестен тип дисковода; </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">AH = 80h Диск не установлен в дисковод. </td>
  </tr>
  <tr>
    <td WIDTH="120">&nbsp;</td>
    <td WIDTH="353">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="120">Примечание:</td>
    <td WIDTH="353">AT, PS/2</td>
  </tr>
</table>

<p>Эта функция должна быть вызвана перед
использованием функции 05h форматирования диска
для установки правильной скорости передачи
данных через дисковый контроллер. Дополнительно
функция сбрасывает флаг замены дискеты (если
этот флаг установлен). </p>

<h4><font SIZE="2">1.5.26 Парковка головок (НМД)</font></h4>

<table BORDER="1">
  <tr>
    <td WIDTH="117">На входе:</td>
    <td WIDTH="371">AH = 19h</td>
  </tr>
  <tr>
    <td WIDTH="117">&nbsp;</td>
    <td WIDTH="371">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="117">На выходе:</td>
    <td WIDTH="371">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="117">&nbsp;</td>
    <td WIDTH="371">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="117">Примечание:</td>
    <td WIDTH="371">PS/2</td>
  </tr>
</table>

<p>Парковка головок - это их установка в нерабочую
область, т.е. на нерабочую дорожку. Эту операцию
обычно выполняют перед транспортировкой
компьютера для исключения повреждения
дисковода. </p>

<h4><font SIZE="2">1.5.27 Форматирование диска (ESDI НМД)</font> </h4>

<table BORDER="1">
  <tr>
    <td WIDTH="132">На входе:</td>
    <td WIDTH="364">AH = 1Ah</td>
  </tr>
  <tr>
    <td WIDTH="132">&nbsp;</td>
    <td WIDTH="364">AL = Количество элементов в таблице
    дефектов </td>
  </tr>
  <tr>
    <td WIDTH="132">&nbsp;</td>
    <td WIDTH="364">DL = Адрес дисковода (80h, 81h, ...) </td>
  </tr>
  <tr>
    <td WIDTH="132">&nbsp;</td>
    <td WIDTH="364">CL = Режим форматирования </td>
  </tr>
  <tr>
    <td WIDTH="132">&nbsp;</td>
    <td WIDTH="364">ES:BX = Адрес таблицы дефектов </td>
  </tr>
  <tr>
    <td WIDTH="132">На выходе:</td>
    <td WIDTH="364">AH = Состояние дисковода после завершения
    последней операции </td>
  </tr>
  <tr>
    <td WIDTH="132">&nbsp;</td>
    <td WIDTH="364">CF = 1, если произошла ошибка, <br>
    0, если ошибки нет </td>
  </tr>
  <tr>
    <td WIDTH="132">Примечание:</td>
    <td WIDTH="364">PS/2</td>
  </tr>
</table>

<p>Эта функция форматирования жесткого диска
предназначена для НМД, используемого совместно с
контроллером ESDI. Она поддерживает таблицу
дефектных дорожек и имеет несколько режимов
форматирования в зависимости от содержимого
регистра CL при вызове: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="81">Бит 0</td>
    <td WIDTH="408">игнорировать первичную таблицу
    дефектов; </td>
  </tr>
  <tr>
    <td WIDTH="81">Бит 1</td>
    <td WIDTH="408">игнорировать вторичную таблицу
    дефектов; </td>
  </tr>
  <tr>
    <td WIDTH="81">Бит 2</td>
    <td WIDTH="408">обновить вторичную таблицу дефектов; </td>
  </tr>
  <tr>
    <td WIDTH="81">Бит 3</td>
    <td WIDTH="408">выполнить анализ поверхности; </td>
  </tr>
  <tr>
    <td WIDTH="81">Бит 4</td>
    <td WIDTH="408">генерация периодических прерываний; </td>
  </tr>
  <tr>
    <td WIDTH="81">Биты 5-7</td>
    <td WIDTH="408">зарезервированы, должны быть равны 0. </td>
  </tr>
</table>

<p>Если при форматировании затребована функция
генерации периодических прерываний, то после
форматирования каждой дорожки вызывается
прерывание INT&nbsp;5h с регистром AH=0Fh. Это прерывание
можно использовать для индикации хода процесса
либо для завершения процесса форматирования по
требованию оператора или программы. </p>

<p>При установке бита 2 регистра CL содержимое
вторичной таблицы дефектов обновляется, в нее
заносятся результаты тестирования диска. Для
углубленного анализа поверхности диска сначала
необходимо выполнить форматирование диска с
битом 3, сброшенным в 0. Затем следует выполнить
анализ поверхности диска, вызвав эту функцию с
битом 3, установленным в 1. </p>

<h3><a NAME="ch1_6">1.6. Использование функций BIOS</a></h3>

<p>Только что мы привели функции BIOS для работы с
диском на физическом уровне. Когда и как ими
пользоваться? </p>

<p>Доступ к диску на физическом уровне может
потребоваться для чтения отдельных секторов
диска, расположенных в фиксированных (или
известных) местах диска - таблицы разделов диска,
каталогов и т.п. С помощью функций BIOS можно
выполнить низкоуровневое форматирование диска,
как стандартное, так и использующее
нестандартный формат дорожки. </p>

<p>В любом случае при записи информации в сектора
следует внимательно анализировать работу
программы - ошибки могут привести к разрушению
логической структуры диска. В результате этого
могут оказаться потеряны каталоги и файлы. Все
&quot;опасные&quot; эксперименты лучше проводить на
дискетах, и только когда вы уверены в
безошибочной работе программы, можно
&quot;допустить&quot; ее к жесткому диску. </p>

<p>Если вы используете дисковод с высокой
плотностью записи (например, 1.2М) для работы с
дискетами, использующими двойную плотность
записи (360 К), перед началом работы вам надо
правильно установить скорость передачи данных
через контроллер НГМД. Лучше всего это сделать
функцией <b>17h</b> прерывания <b>INT&nbsp;3h</b>, указав тип
диска. </p>

<p>Не следует забывать о задержке, необходимой для
разгона двигателя НГМД до рабочей скорости.
Некоторые функции BIOS могут вернуть признак
ошибки, если двигатель не набрал нужной скорости.
Если вы получили признак ошибки, вначале следует
три раза повторить вызов функции, сбрасывая
каждый раз перед этим контроллер НГМД функцией 0
прерывания <b>INT&nbsp;13h</b>. Если и после этого ошибка
не исчезла, следует провести ее углубленный
анализ. </p>

<p>Приведем примеры использования функций
прерывания <b>INT&nbsp;13h</b> для работы с НГМД. </p>

<p>Первый пример - программа, составленная на
языке ассемблера. Она читает самый первый сектор
диска, расположенный на нулевой дорожке, нулевой
стороне (нулевая головка). Этот сектор имеет
номер 1. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                .MODEL  tiny

                .STACK  100h

                .DATA

; Буфер, в который будет прочитан сектор диска

buf   db 512 dup(?)

                .CODE
                .STARTUP


                mov   ch,00h   ; Номер дорожки
                mov   cl,01h   ; Номер сектора

                mov   dh,00h   ; Номер головки (стороны диска)
                mov   dl,00h   ; Номер дисковода - дисковод А:

; Готовим адрес буфера в ES:BX

                mov   ax,cs
                mov   es,ax

                mov   bx,OFFSET buf

; Готовим код функции

                mov   ah,02h   ; Код функции - чтение сектора
                mov   al,01h   ; Количество читаемых секторов - 1

; Вызываем прерывание

                int   13h


                .EXIT   0

                END
</font>
</pre>

<p>Следующая программа - пример использования
аппаратной поддержки проверки замены дискеты.
Эта поддержка реализована в машинах класса AT, PS/2. </p>

<p>Сначала программа устанавливает тип дискеты.
Это нужно для правильного выбора скорости
передачи данных контроллером НГМД. При установке
типа дискеты сбрасывается флаг замены дискеты. </p>

<p>Далее после чтения состояния НГМД программа
делает паузу, во время которой вы можете заменить
дискету или просто открыть и закрыть дверцу
дисковода. Выполнив (или не выполнив) действия по
замене дискеты, нажмите на любую клавишу.
Программа выведет на экран новое состояние флага
замены дискеты. </p>

<p>Попробуйте запустить эту программу без
дискеты, обратите внимание на состояние порта <b>0x3F7</b>.
</p>

<p>Главное, что вы можете взять из приведенной
ниже программы - это техника работы с флагом
замены дискеты. Используя аппаратную поддержку
проверки замены дискеты, ваша программа сможет
более полно контролировать действия оператора
по установке и замене дискет. </p>

<p>Текст программы: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt;

union REGS inregs, outregs;

void main(void);
void main(void) {

// Устанавливаем тип диска и сбрасываем
// флаг замены дискеты

        inregs.h.ah = 0x17;
        inregs.h.al = 3;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);

// Определяем тип диска и наличие аппаратной
// поддержки проверки замены дискеты

        inregs.h.ah = 0x15;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);
        printf(&quot;\nТип диска А: %d&quot;,outregs.h.ah);

// Определяем состояние флага замены дискеты

        inregs.h.ah = 0x16;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);
        printf(&quot;\nСостояние флага замены дискеты: %d&quot;,outregs.h.ah);

// Выводим состояние порта 0x3F7.
// Бит 7 этого порта отображает состояние
// флага замены дискеты

        printf(&quot;\nПорт 0x3F7: %02.2x&quot;,inp(0x3f7));

// Сбрасываем контроллер НГМД

        inregs.h.ah = 0;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);

// Делаем паузу, во время которой можно
// заменить дискету. Запуская программу несколько
// раз, попробуйте во время ожидания нажатия на клавишу
// открыть и затем закрыть дверцу дисковода - это
// приведет к установке флага замена дискеты

        printf(&quot;\nЗамените дискету и нажмите на любую клавишу&quot;);
        getch();

// Определяем заново состояние флага замены дискеты

        inregs.h.ah = 0x16;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);
        printf(&quot;\nСостояние флага замены дискеты: %d&quot;,outregs.h.ah);

// Выводим состояние порта 0x3F7.

        printf(&quot;\nПорт 0x3F7: %02.2x&quot;,inp(0x3f7));

}
</font>
</pre>

<p>Еще один пример - нестандартное форматирование
дорожки флоппи-диска - мы приведем в следующем
разделе. </p>

<h3><a NAME="ch1_7">1.7. Функция _bios_disk()</a></h3>

<p>Стандартная библиотека трансляторов Microsoft
QC&nbsp;.01, QC&nbsp;.5, C&nbsp;.0 содержит специальную функцию,
облегчающую работу с диском на уровне BIOS - <b>_bios_disk()</b>.
Эта функция требует использования файла <b>bios.h</b>
и описана следующим образом: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">unsigned _bios_disk(unsigned funct,
       struct diskinfo_t *diskinfo);
</font>
</pre>

<p>Параметр funct задает выполняемую функцию,
параметр <b>diskinfo</b> - это указатель на структуру,
описывающую необходимые параметры, такие как
номер дорожки, номер головки и т.д.: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">  struct diskinfo_t
  {
        unsigned drive;    // Номер дисковода
        unsigned head;     // Номер головки
        unsigned track;    // Номер дорожки
        unsigned sector;   // Номер первого сектора
        unsigned nsectors; // Количество читаемых,
                           // записываемых
                           // или сравниваемых секторов
        void far *buffer;  // Адрес буфера в памяти
  };
</font>
</pre>

<p>Перед использованием функции <b>_bios_disk() </b>программа
должна заполнить поля структуры <b>diskinfo</b> и
вызвать<b> _bios_disk()</b> с соответствующим параметром <b>funct</b>.
</p>

<p>Файл<b> bios.h</b> содержит константы для следующих
значений параметра <b>funct</b>: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="180">_DISK_FORMAT</td>
    <td WIDTH="323">Форматирование дорожки, описанной
    параметром diskinfo функции _bios_disk(). Для этой функции
    программа должна задать в структуре diskinfo номер
    дисковода, для которого выполняется
    форматирование, номера головки и форматируемой
    дорожки. Указатель buffer программа должна
    установить на подготовленный буфер формата,
    описанный выше. Необходимо выполнить все
    подготовительные действия, связанные с
    настройкой контроллера НГМД и таблицы
    параметров дискеты. </td>
  </tr>
  <tr>
    <td WIDTH="180">_DISK_READ</td>
    <td WIDTH="323">Чтение одного или нескольких секторов
    диска. Эта функция аналогична функции 2
    прерывания INT&nbsp;13h. Если при чтении секторов
    произошла ошибка, ее код будет возвращен
    функцией _bios_disk() в старшем байте. При успешном
    завершении операции функция возвращает 0. </td>
  </tr>
  <tr>
    <td WIDTH="180">_DISK_WRITE</td>
    <td WIDTH="323">Запись одного или нескольких секторов
    на диск. Функция аналогична предыдущей, за
    исключением того, что данные из буфера
    записываются на диск. </td>
  </tr>
  <tr>
    <td WIDTH="180">_DISK_RESET</td>
    <td WIDTH="323">Сброс контроллера НГМД. Для этой функции
    не надо заполнять структуру diskinfo, ее содержимое
    игнорируется. Сброс контроллера выполняют после
    того, как произошла ошибка при выполнении другой
    операции, например, чтения или записи. После
    сброса можно попробовать повторить выполнение
    операции. </td>
  </tr>
  <tr>
    <td WIDTH="180">_DISK_STATUS</td>
    <td WIDTH="323">Получение состояния НГМД после
    выполнения последней операции. Старший байт
    возвращаемого функцией bios_disk() значения содержит
    байт состояния. </td>
  </tr>
  <tr>
    <td WIDTH="180">_DISK_VERIFY</td>
    <td WIDTH="323">Проверка диска. С помощью этой функции
    можно убедиться в том, что указанные сектора
    существуют и могут быть прочитаны в память.
    Дополнительно выполняется циклический
    избыточный тест (CRC). Функция проверки диска
    использует все поля структуры diskinfo. При ошибке
    старшие 8 битов возвращаемого функцией значения
    содержат байт состояния. </td>
  </tr>
</table>

<p>Приведем пример программы, читающей первый
сектор нулевой дорожки (нулевая головка) диска <b>А:</b>.
В случае ошибки программа пытается прочесть
сектор три раза: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;bios.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt;

char _far diskbuf[512];

void main(void);

void main(void) {

         unsigned status = 0, i;
         struct diskinfo_t di;

         di.drive    = 0;
         di.head     = 0;
         di.track    = 0;
         di.sector   = 1;
         di.nsectors = 1;
         di.buffer   = diskbuf;

         for(i = 0; i &lt; 3; i++) {
                  status = _bios_disk(_DISK_READ, &amp;di) &gt;&gt; 8;
                  if( !status ) break;
         }

}
</font>
</pre>

<p>Последний пример, который мы приведем перед
тем, как закончить с работой диска на физическом
уровне, это форматирование дорожки. Сейчас мы
будем использовать стандартное форматирование.
Как отформатировать дорожку нестандартным
образом, вы узнаете в разделе, посвященном защите
информации от несанкционированного копирования.
Там же будет приведен соответствующий пример. </p>

<p>Приведенная ниже программа форматирует 20-ю
дорожку дискеты, установленной в дисковод А:. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;dos.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;bios.h&gt;
#include &quot;sysp.h&quot;

// Номер форматируемой дорожки

#define TRK 20

// Код размера сектора - 512 байт

#define SEC_SIZE 2

union REGS inregs, outregs;
char _far diskbuf[512];

void main(void);
void main(void) {

        struct diskinfo_t di;
        unsigned status;
        unsigned char old_sec_size, old_fill_char, old_eot;
        int i, j;
        DPT  _far *dpt_ptr;

// Получаем адрес таблицы параметров дискеты

        dpt_ptr = get_dpt();

// Сохраняем старые значения из таблицы параметров

        old_sec_size  = dpt_ptr-&gt;sec_size;
        old_fill_char = dpt_ptr-&gt;fill_char;
        old_eot       = dpt_ptr-&gt;eot;

// Устанавливаем в таблице параметров дискеты
// код размера сектора, символ заполнения при
// форматировании, количество секторов на дорожке

        dpt_ptr-&gt;sec_size  = SEC_SIZE;
        dpt_ptr-&gt;fill_char = 0xf8;
        dpt_ptr-&gt;eot       = 15;

// Устанавливаем тип диска

        inregs.h.ah = 0x17;
        inregs.h.al = 3;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);

// Устанавливаем среду для форматирования

        inregs.h.ah = 0x18;
        inregs.h.ch = TRK;
        inregs.h.cl = dpt_ptr-&gt;eot;
        inregs.h.dl = 0;
        int86(0x13, &amp;inregs, &amp;outregs);

// Подготавливаем параметры для функции форматирования

        di.drive    = 0;
        di.head     = 0;
        di.track    = TRK;
        di.sector   = 1;
        di.nsectors = 15;
        di.buffer   = diskbuf;

// Подготавливаем буфер формата для 15-ти секторов

        for(i=0, j=1; j&lt;16; i += 4, j++) {
                diskbuf[i]    = TRK;
                diskbuf[i+1]  = 0;
                diskbuf[i+2]  = j;
                diskbuf[i+3]  = SEC_SIZE;
        }

// Вызываем функцию форматирования дорожки

        status = _bios_disk(_DISK_FORMAT, &amp;di) &gt;&gt; 8;
        printf(&quot;\nФорматирование завершилось с кодом: %d&quot;,status);

// Восстанавливаем старые значения в
// таблице параметров дискеты

        dpt_ptr-&gt;sec_size  = old_sec_size;
        dpt_ptr-&gt;fill_char = old_fill_char;
        dpt_ptr-&gt;eot       = old_eot;

}

</font>
</pre>
</body>
</html>
