<html>

<head>
<title>Внутренняя организация MS-DOS</title>
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
</head>

<body BGCOLOR="#ffffff">

<h1>1. Внутренняя организация MS-DOS</h1>

<ul>
  <li>1.1. <a HREF="ch1.htm#ch1_1">Основные компоненты
    операционной системы</a> </li>
  <li>1.2. <a HREF="ch1.htm#ch1_2">Процесс загрузки операционной
    системы</a> </li>
  <li>1.3. <a HREF="ch1.htm#ch1_3">Общая схема работы DOS</a> </li>
  <li>1.4. <a HREF="ch1.htm#ch1_4">Обзор прерываний BIOS</a> </li>
  <li>1.5. <a HREF="ch1.htm#ch1_5">Обзор прерываний DOS</a> </li>
  <li>1.6. <a HREF="ch1.htm#ch1_6">Обработка ошибок</a> </li>
</ul>

<h2><a NAME="ch1_1">1.1. Основные компоненты операционной
системы</a> </h2>

<p>Дистрибутив операционной системы MS-DOS состоит,
в зависимости от версии, из одной или нескольких
дискет. На них расположены файлы собственно
операционной системы IO.SYS, MSDOS.SYS, командный
процессор COMMAND.COM, файлы внешних команд
операционной системы (FORMAT, FDISK и т.п.), драйверы и
другие файлы. </p>

<p>Файл IO.SYS содержит расширение базовой системы
ввода/вывода и является интерфейсом между
операционной системой и BIOS. Расширение
используется операционной системой для
взаимодействия с аппаратурой компьютера и BIOS. </p>

<p>Файл MSDOS.SYS является в некотором смысле набором
программ обработки прерываний, в частности
прерывания INT&nbsp;21H. Это тело операционной
системы. </p>

<p>Командный процессор COMMAND.COM предназначен для
организации диалога с оператором. Он анализирует
вводимые оператором команды и организует их
выполнение. Так называемые внутренние команды
(DIR, COPY и т.д.) обрабатываются именно командным
процессором. Программист имеет возможность
написать свой собственный командный процессор и
подключить его вместо стандартного. Новый
командный процессор должен выполнять все
функции, которые раньше выполнял стандартный
COMMAND.COM. </p>

<p>Драйверы (обычно это файлы, имеющие расширение
имени .SYS) представляют собой программы,
обслуживающие различную аппаратуру. Эти
программы имеют специальный формат и будут
подробно описаны в книге. Применение драйверов
легко решает проблемы использования новой
аппаратуры - достаточно написать для нового
устройства драйвер и подключить его к
операционной системе. Прикладные программы
взаимодействуют с устройствами через драйвер,
поэтому они не будут меняться при изменениях в
аппаратуре. Например, новое дисковое устройство
может иметь другое количество дорожек и
секторов, другие управляющие команды. Все это
учитывается драйвером, а прикладная программа
будет работать с новым диском как и раньше,
используя прерывания MS-DOS. </p>

<p>Файлы внешних команд операционной системы
содержат программы-утилиты для выполнения
разнообразных операций, таких как
форматирование дисков, сортировка файлов, печати
текстов и других. </p>

<p>Немного об утилитах, предназначенных для
подготовки дисков и дискет. </p>

<p>Файлы операционной системы выделяются своим
особым расположением на диске (кроме COMMAND.COM) - эти
файлы должны находиться в специально отведенном
для них месте. Если вам нужно подготовить дискету
как системную (т.е. такую, с которой можно
загружать операционную систему), для переноса
файлов операционной системы следует
использовать специальные утилиты. </p>

<p>Самый простой способ подготовки системной
дискеты - использовать команду FORMAT с опцией /S,
например: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">FORMAT A: /S</font>
</pre>

<p>В этом случае после форматирования на дискету
будут перенесены файлы операционной системы. При
использовании команды текущим должен быть
корневой каталог системного диска, например,
диска С:. </p>

<p>Если вы собираетесь обновить версию
операционной системы (например, вместо MS-DOS 3.30
установить MS-DOS 4.01), не обязательно заново
переформатировать весь диск. Загрузив новую
версию с дискеты, для переноса новых системных
файлов используйте команду SYS: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">SYS C:</font>
</pre>

<p>Файл COMMAND.COM скопируйте обычным способом. </p>

<p>Если вам надо сделать дискету системной, а ее
форматирование нежелательно (дискета содержит
важную информацию), воспользуйтесь программой
Norton Disk Doctor или аналогичной. Программа освободит
место в начале диска для операционной системы,
переписав располагавшиеся там данные на
свободное место в конце дискеты, затем запишет
системные файлы и даже скопирует файл COMMAND.COM. </p>

<p>Утилита FDISK предназначена для подготовки к
работе жесткого диска. Она разбивает диск на
участки, называемые разделами. </p>

<p>На одном физическом диске могут быть разделы,
принадлежащие разным операционным системам.
Один из разделов - активный, операционная система
загружается из активного раздела. </p>

<p>Для MS-DOS утилита FDISK позволяет создать первичный
и вторичный разделы. В первичном разделе
располагается системный диск C:, с которого
выполняется загрузка операционной системы,
вторичный раздел может быть разделен на
логические диски (D:, E:, F: и т.д.). Диски,
располагающиеся во вторичном разделе, не могут
быть системными. </p>

<p>Заметим, что только MS-DOS версии 4.01, 5.0 и Compaq DOS 3.31
позволяют создавать логические диски размером
более 32 мегабайт. Это связано с тем, что другие
версии DOS используют 16-разрядную адресацию
секторов диска, что недостаточно для дисков
больших размеров. </p>

<p>Очень часто вместо утилиты FDISK для подготовки
жесткого диска используются диск-менеджеры. Это
такие программы, как Advanced Disk Manager, Speed Stor и т.д.
Используя свои собственные форматы разделов и
таблиц разделов (и свои драйверы дисковых
устройств), диск-менеджеры предоставляют такие
дополнительные возможности, как защита
логического диска от записи или организация
парольной защиты данных на диске, создание
логических дисков размером более 32 мегабайт. </p>

<p>Однако не всегда применение диск-менеджеров
может привести к желаемому результату. Защита от
несанкционированного доступа часто легко
преодолевается, мощные ситемы защиты сильно
привязаны к конкретной версии операционной
системы (например, WatchDog, очень мощная система
защиты, требует только DOS версии 3.20). </p>

<p>Кроме того, драйверы, используемые
диск-менеджерами могут замедлить работу
дисковой подсистемы компьютера. </p>

<p>Некоторые программы, особенно защищенные от
копирования, отказываются работать на диске,
подготовленном не утилитой FDISK. Причины этого мы
увидим, когда будем обсуждать проблемы защиты
программ от несанкционированного копирования. </p>

<p>Перейдем к процедуре начальной загрузки
операционной системы. </p>

<h2><a NAME="ch1_2">1.2. Процесс загрузки операционной
системы</a> </h2>

<p>При включении питания компьютера управление
передается базовой системе ввода/вывода, BIOS.Она
выполняет проверку аппаратных узлов компьютера,
формирует начальную часть таблицы векторов
прерываний, инициализирует устройства и
начинает процесс загрузки операционной системы. </p>

<p>Загрузка начинается с того, что BIOS делает
попытку прочитать самый первый сектор дискеты,
вставленной в дисковод А: (на загрузочной дискете
этот сектор содержит загрузчик операционной
системы). Если в дисковод вставлена системная
дискета, с нее считывается загрузчик и ему
передается управление. </p>

<p>Если дискета не системная, т.е. не содержит
загрузочной записи, на экран выдается сообщение
с просьбой заменить дискету. </p>

<p>Если же дискеты в дисководе А: вообще нет, то BIOS
читает основную загрузочную запись диска С: (Master
Boot Record). Обычно это самый первый сектор на диске.
Управление передается загрузчику, который
находится в этом секторе. Загрузчик анализирует
содержимое таблицы разделов (она также находится
в этом секторе), выбирает активный раздел и
читает загрузочную запись этого раздела.
Загрузочная запись активного раздела (Boot Record)
аналогична загрузочной записи, находящейся в
первом секторе системной дискеты. </p>

<p>Загрузочная запись активного раздела
считывает с диска файлы IO.SYS и MSDOS.SYS (именно в этом
порядке). Затем считываются и загружаются
резидентные драйверы. Начинается формирование
связанного списка драйверов устройств.
Анализируется содержимое файла CONFIG.SYS,
загружаются описанные в этом файле драйверы.
Сначала загружаются драйверы, описанные
параметром DEVICE, затем (только в MS-DOS версии 4.х и 5.0)
резидентные программы, указанные операторами
INSTALL. После этого считывается командный
процессор и ему передается управление. </p>

<p>Командный процессор состоит из трех частей -
резидентной, инициализирующей и транзитной.
Первой загружается резидентная часть. Она
обрабатывает прерывания INT&nbsp;22H, INT&nbsp;23H, INT&nbsp;24H,
управляет загрузкой транзитной части. Эта часть
командного процессора обрабатывает ошибки MS-DOS и
выдает запрос пользователю о действиях при
обнаружении ошибок. </p>

<p>Инициализирующая часть используется только в
процессе загрузки операционной системы. Она
определяет начальный адрес, по которому будет
загружаться пользовательская программа и
инициализирует выполнение файла AUTOEXEC.BAT. </p>

<p>Транзитная часть командного процессора
располагается в старших адресах памяти. В этой
части находятся обработчики внутренних команд
MS-DOS и интерпретатор командных файлов с
расширением имени .BAT. Транзитная часть выдает
системное приглашение (например, А:\&gt; ), ожидает
ввода команды оператора с клавиатуры или из
пакетного файла и организует их выполнение. </p>

<p>После загрузки командного процессора и
выполнения начальных процедур, перечисленных в
файле AUTOEXEC.BAT, подготовка системы к работе
завершается. </p>

<h2><a NAME="ch1_3">1.3. Общая схема работы DOS</a></h2>

<p>Для того чтобы правильно работать с системным
программным и аппаратным обеспечением, нужно
четко представлять себе механизм взаимодействия
прикладной программы с компьютером. На рис. 1.1
показаны функциональные связи программы с
программно-аппаратным обеспечением IBM&nbsp;PC. </p>

<p><img SRC="pic1_1.gif" ALT="Рис. 1.1" WIDTH="528" HEIGHT="276"> </p>

<address>
  Рис.1.&nbsp;Функциональные связи программы для MS-DOS с
  программно-аппаратным обеспечением ПЭВМ 
</address>

<p>Как правило, ядро DOS разделяют на несколько
подсистем, каждая из которых отвечает за
выполнение той или иной задачи. Как показано на
рисунке, обычно выделяются следующие подсистемы:

<ul>
  <li>файловая система; </li>
  <li>система управления памятью; </li>
  <li>система управления программами; </li>
  <li>система связи с драйверами устройств; </li>
  <li>система обработки ошибок; </li>
  <li>службу времени; </li>
  <li>систему ввода/вывода консоли оператора. </li>
</ul>

<p>Эти подсистемы общаются с аппаратурой через BIOS,
драйверы или напрямую. Прикладное программное
обеспечение может вызывать подсистемы DOS,
работать с BIOS или непосредственно с аппаратурой.
Обратите, однако, внимание на то, что прикладные
программы могут обращаться к драйверам только
через соответствующую подсистему DOS. </p>

<p>Очевидно также, что чем выше уровень интерфейса
прикладной программы и аппаратуры, тем меньше
программа будет зависеть от особенностей
аппаратуры. </p>

<p>Рассмотрим подсистемы DOS отдельно. </p>

<h3>Файловая система.</h3>

<p>Файловая система является одной из важнейших
подсистем DOS. Она используется как в процессе
загрузки операционной системы, так и в процессе
ее работы. Сама операционная система записана на
системном диске в виде файлов (IO.SYS, MSDOS.SYS, COMMAND.COM,
драйверы, внешние команды и т.д.). Все прикладные
программы и вообще все программы и данные для них
хранятся на дисках в виде файлов, поэтому можно
сказать, что файловая система - ключевая
подсистема DOS. </p>

<p>Для обращения к файловой системе прикладная
программа должна использовать специально
предназначенные для этого функции прерывания DOS.
Эти функции выполняют все файловые операции -
создание, удаление файлов и каталогов,
буферизованная и не буферизованная запись или
чтение, получение справочной информации о
состоянии файловой системы и другие. Файловые
операции будут кратко описаны в обзоре
прерываний DOS, кроме того, файловой системе
полностью посвящена третья книга первого тома. </p>

<p>Файловая система работает с дисками через
драйверы. Драйверы, в свою очередь, пользуются
сервисом BIOS. </p>

<p>На уровне BIOS выполняются элементарные операции
с диском, такие как чтение/запись секторов,
форматирование и т.п. Этот низкий уровень
доступен и прикладной программе, но обычно она
пользуется функциями прерывания DOS, выполняющими
все необходимые действия по обслуживанию
каталогов и таблицы размещения файлов (File Allocation
Table - FAT). Программы защиты от
несанкционированного доступа или копирования
вынуждены обращаться к средствам более низкого
уровня, вызывая прерывания BIOS, или даже работать
с контроллером дисковода через порты
ввода/вывода. </p>

<p>Используя подсистему DOS, отвечающую за связь с
драйверами, прикладные программы могут также
выполнять элементарные операции с диском, такие
как форматирование. </p>

<h3>Система управления памятью.</h3>

<p>Эта подсистема DOS используется для
распределения памяти запускаемым программам. </p>

<p>DOS управляет памятью с помощью блоков MCB (Memory
Control Block). Память разбивается на блоки; каждому
блоку предшествует MCB, в котором записаны
характеристики блока памяти. Для каждой вновь
запускаемой программы DOS создает определенное
количество блоков MCB. При освобождении памяти или
при выполнении запросов на получение
дополнительной памяти DOS также использует блоки
MCB, проверяя при этом правильность их
содержимого. </p>

<p>Все блоки MCB располагаются друг за другом. Адрес
первого блока хранится в векторной таблице
связи, CVT, о которой мы будем говорить в главе 2.
Там же будет описан формат блока управления
памятью. </p>

<p>Прикладная программа может заказать для себя
дополнительные блоки памяти. Для этого она
обращается к системе управления памятью,
используя функции прерывания 21h DOS. </p>

<h3>Система управления программами.</h3>

<p>При запуске программы DOS выполняет несколько
операций. Сначала она обращается к системе
управления памятью, чтобы подготовить блоки
памяти для запускаемой программы. С помощью
файловой системы файл, содержащий программу,
загружается в память, после чего программа (это
относится только к файлам типа .exe) настраивается
на конкретный физический адрес. Только после
этого программе передается управление. </p>

<p>Как известно, в MS-DOS существуют два формата
выполняемых программ - .com и .exe. Способы запуска
этих программ сильно различаются. Система
управления программами автоматически
распознает их и загружает в память по-разному. Мы
еще вернемся к описанию различий между этими
типами программ. </p>

<p>Другая задача, решаемая ситемой управления
программами - запуск программ из программ и
загрузка &quot;программных перекрытий&quot; -
оверлеев. Если не все модули большого
программного комплекса нужны одновременно, вы
можете разбить комплекс на несколько частей. Это
могут быть либо несколько отдельных программ,
либо несколько оверлейных модулей. Каждый из
этих способов имеет свои преимущества и
недостатки; оба они пригодны для экономии памяти.
</p>

<p>И наконец, последняя функция системы
управления программами - работа с резидентными
программами. Если вам надо, чтобы после
завершения своей работы программа осталась
резидентной в памяти, вы, как и в случае
завершения обычной программы, обращаетесь к
системе управления программами через
соответствующую функцию прерывания DOS 21h. </p>

<h3>Система связи с драйверами устройств.</h3>

<p>Эта система скрыта от прикладных программ -
программы не могут обращаться непосредственно к
драйверам устройств ввода/вывода. Программа
вызывает DOS, а DOS обращается при необходимости к
драйверам. </p>

<p>Возможно, что запрет на непосредственный вызов
драйверов введен для обеспечения совместимости
с будущими версиями операционной системы, в
которых механизм вызова драйверов может
измениться. Однако, используя сведения,
приведенные в этой книге, вы сможете обойти этот
запрет и обратиться непосредственно к драйверу.
При этом вам придется использовать некоторые
недокументированные прерывания DOS, что само по
себе нежелательно из-за возможной потери
совместимости с другими версиями операционной
системы. </p>

<p>Для управления состоянием устройства
ввода/вывода или состоянием драйвера
используется специальная функция 44h прерывания
DOS 21h. Эта функция предназначена для обмена
управляющей информацией между прикладной
программой и драйвером. </p>

<h3>Система обработки ошибок.</h3>

<p>Система обработки ошибок DOS проста и удобна. Для
кодирования ошибок как правило используется
флаг переноса (CARRY, CF). Если после обращения к
прерыванию DOS флаг переноса установлен в 1,
произошла ошибка. Для того чтобы
проанализировать ошибку и предпринять какие-то
действия, можно вызвать соответствующую функцию
DOS, которая вернет уточняющую информацию об
ошибке и предоставит соответствующие
рекомендации (разумеется, лишь в виде кодов,
находящихся в регистрах процессора). </p>

<p>Если произошла критическая ошибка ввода/вывода
(например, прочитать дискету невозможно),
вызывается стандартная процедура DOS, выводящая
на экран запрос о дальнейших действиях.
Пользовательская программа может подключить
вместо системной свою программу обработки
критических ошибок. Подробнее об обработке
ошибок будет сказано в разделе 1.6. </p>

<h3>Служба времени.</h3>

<p>Компьютер обычно оборудуется системными
часами. Это могут быть КМОП-часы с питанием от
аккумулятора, содержимое которых не
сбрасывается при выключении питания компьютера,
или таймер, регулярно вырабатывающий прерывания.
В любом случае операционная система ведет
подсчет времени и хранит текущие показания часов
и дату. </p>

<p>Программа может опросить часы, обратившись к DOS
с запросом через одну из функций прерывания 21h,
или установить новое состояние часов. </p>

<p>Операционная система содержит драйвер
устройства CLOCK$. Прикладная программа может
обратиться к этому устройству для чтения
показания часов или для установки часов. В книге 2
первого тома приведен пример программы для
работы с устройством CLOCK$. </p>

<p>Программа может также использовать прерывания
таймера для регулярного выполнения каких-либо
функций. </p>

<h3>Ввод/вывод на консоль оператора.</h3>

<p>Консоль оператора состоит из двух устройств -
клавиатуры и дисплея. Эти два устройства
обслуживаются одним драйвером - драйвером
консоли CON. Т.е. можно считать, что в компьютере
имеется устройство - консоль - с именем CON. </p>

<p>Операционная система обслуживает консоль с
помощью функций прерывания 21h, обеспечивающих
ввод и вывод символов на устройство CON. Для работы
с физической клавиатурой и дисплейным адаптером
этот драйвер использует прерывания BIOS. </p>

<h3>Другие подсистемы DOS.</h3>

<p>DOS имеет набор драйверов для работы с
печатающими устройствами и последовательными
портами, которые обеспечивают прием/передачу
символов и управление режимами работы устройств.
</p>

<p>Кроме того, для печати текста в фоновом режиме в
состав дистрибуции DOS входит программа PRINT.COM. Эта
практически единственная &quot;мультизадачная&quot;
утилита операционной системы является примером
стандартной резидентной программы. Она
позволяет выполнять параллельно с печатью
текста другую работу (например, редактирование
другого текста). </p>

<p>Специально следует отметить драйверы
электронного диска и кэш-памяти. Драйвер
электронного диска называется RAMDRIVE.SYS. Этот
драйвер организует в расширенной или в
дополнительной памяти компьютера быстрый
псевдо-диск. Можно организовать электронный диск
и в основной памяти, но основной памяти всегда
мало! </p>

<p>Операционная система MS-DOS версий 4.01 и 5.0 имеет в
своем составе систему управления дополнительной
и расширенной памятью, которая реализуется
драйвером HIMEM.SYS. Этот драйвер позволяет
программам, составленным специальным образом,
использовать расширенную или дополнительную
память для хранения данных (но не для выполнения
программ). </p>

<p>Если подключен драйвер HIMEM.SYS, то с помощью
драйвера SMARTDRV.SYS можно создать кэш-память для
жесткого диска. Особенно эффективно применение
кэш-памяти для работы с базами данных, когда вам
периодически требуется одна и та же информация. В
следующий раз, когда информация потребуется, она
будет доступна без обращения к диску. </p>

<p>Такое широко распространенное и ставшее
стандартным для любого персонального компьютера
устройство как мышь не поддерживается
операционной системой. Для использования мыши
следует подключить драйвер, который обычно
поставляется вместе с этим устройством. </p>

<p>Другие устройства ввод/вывода (сканеры,
плоттеры, стримеры и т.п.) также не поддерживаются
DOS. Для этих устройств фирмы поставляют драйверы,
которые надо подключить к операционной системе. </p>

<h2><a NAME="ch1_4">1.4. Обзор прерываний BIOS</a></h2>

<p>Как правило, любая программа работает с тем или
иным устройством ввода/вывода. Программы для
первых ЭВМ работали непосредственно с портами и
регистрами этих устройств. Модули, выполняющие
такие стандартные действия, как ввод данных с
перфокарт или печать результатов вычислений,
входили в состав пользовательских программ. </p>

<p>В начале своего развития микропроцессорные
системы имели в своем составе программу,
называемую &quot;монитор&quot;. Эта программа обычно
находилась в постоянном запоминающем устройстве
и обслуживала устройства ввода/вывода:
клавиатуру, дисплей, кассетный накопитель на
магнитной ленте и др. Диалоговая часть монитора
позволяла выполнять некоторые операторские
функции: загрузку и запуск программы, отладку
программы в пошаговом режиме, печать текстов,
просмотр и редактирование содержимого памяти и
т.п. Но самое главное - прикладные программы,
составленные для этих систем, могли пользоваться
модулями монитора для работы с периферийной
аппаратурой и для выполнения других функций. </p>

<p>Программа уже не содержала все необходимые для
ее работы модули, а пользовалась
&quot;стандартными&quot; услугами программы-монитора.
Такая организация программы не только уменьшила
размер ее загрузочного модуля, но и позволила
программистам сосредоточить свои усилия на
решении основной задачи. </p>

<p>Как программа пользовалась услугами монитора?
Механизм взаимодействия программы пользователя
и монитора был реализован по-разному в разных
системах. В худшем случае прикладная программа
пользовалась известными абсолютными адресами
модулей монитора, в лучшем - использовала
специальные таблицы адресов программных
модулей. </p>

<p>К сожалению, разные системы были несовместимы
по составу модулей монитора и механизму их
вызова, что сильно затрудняло, если не совершенно
исключало их программную совместимость. </p>

<p>В первом массовом персональном компьютере IBM PC
модули обслуживания стандартной периферии были
записаны в постоянном запоминающем устройстве.
Совокупность этих модулей (плюс программа
начальной инициализации и тестирования)
называется базовой системой ввода/вывода - Basic
Input/Output System. Общепринятое сокращение - BIOS. </p>

<p>Выпускаемые различными фирмами компьютеры,
совместимые с IBM PC, могут немного отличаться по
типу периферийного оборудования, но для
достижения совместимости с IBM PC модули BIOS
нивелируют эти различия, предоставляя в
распоряжение программы пользователя
стандартный набор модулей для работы с
устройствами ввода/вывода. </p>

<p>Не будет преувеличением сказать, что одна из
причин такого невиданного успеха компьютера IBM PC
на рынке персональных компьютеров - наличие
хорошо продуманного стандартного интерфейса
модулей BIOS и прикладных программ. Именно
благодаря этому интерфейсу достигается почти
стопроцентная совместимость по программному
обеспечению компьютеров этого типа, выпускаемых
разными фирмами. </p>

<p>В этом разделе книги мы расскажем о том, как
прикладные программы, составленные для
компьютера, совместимого с IBM PC, могут
пользоваться модулями BIOS для работы со
стандартной периферией, затем приведем краткий
обзор основных модулей BIOS. </p>

<p>Напомним вам, что такое программные прерывания,
так как именно они используются для вызова
модулей BIOS. </p>

<p>В начале оперативной памяти персонального
компьютера (в пределах первого килобайта)
находится так называемая векторная таблица
прерываний. Она состоит из 256 ячеек, хранящих
адреса программ-обработчиков прерывания. Мы
будем подробно изучать эту таблицу в главе 4, а
сейчас вспомним машинную команду INT&nbsp;&lt;n&gt;. </p>

<p>По этой команде содержимое ячейки векторной
таблицы прерываний с номером n помещается в
адресные регистры процессора, причем в стеке
запоминается текущее содержимое адресных
регистров. Управление передается по адресу,
записанному в ячейке таблицы.
Программа-обработчик прерывания должна
заканчиваться командой IRET, по которой из стека
извлекается старое значение адресных регистров
и управление передается обратно в программу,
вызвавшую прерывание командой INT&nbsp;&lt;n&gt;. </p>

<p>Вообще говоря, процедура вызова и обработки
программного прерывания похожа на процедуру
вызова подпрограммы. Отличие заключается в том,
что вызывающая программа &quot;не знает&quot;
абсолютного адреса модуля обработки прерывания
в памяти. Поэтому работа программ не зависит от
адресов расположения модулей обработчиков
прерывания. </p>

<p>Для вызова модуля BIOS программа использует
команду INT&nbsp;&lt;n&gt; с соответствующим номером n.
Программа передает параметры модулям BIOS через
регистры процессора, результат работы модуля
возвращается также в регистрах. </p>

<p>Не все номера прерываний n используются BIOS.
Часть из них предназначена для аппаратных
прерываний от устройств ввода/вывода, часть
зарезервирована для DOS, часть - для программ
пользователя. </p>

<p>Подробно прерывания BIOS будут изучаться во
втором томе, так как описание этих прерываний
трудно отделить от описания особенностей
аппаратуры. Приводимый здесь обзор предназначен
в основном для иллюстрации основных
возможностей BIOS по обслуживанию периферии,
поэтому в обзор вошли не все прерывания BIOS, а
только самые важные. Остальные прерывания будут
изучаться по мере необходимости при изложении
соответствующего материала. </p>

<h3>Получение информации об оборудовании</h3>

<h4>INT&nbsp;11h - Получить список оборудования.</h4>

<p>Прежде чем пытаться работать с каким-либо
устройством ввода/вывода, следует убедиться в
том, что оно есть в составе оборудования
компьютера. В процессе инициализации тестовые
модули, находящиеся в BIOS, динамически определяют
состав аппаратного обеспечения машины и
записывают конфигурацию системы в специально
отведенную для этого ячейку памяти. </p>

<p>Программа, вызывая прерывание INT&nbsp;11h, получает
в регистре AX содержимое этой ячейки. Каждый бит в
слове конфигурации отвечает за соответствующее
устройство. </p>

<p>Анализируя слово конфигурации, программа может
узнать, входят ли в состав оборудования
компьютера дискеты и если входят, то сколько
дисководов имеется в наличии, присутствует ли
арифметический сопроцессор, какой начальный
режим дисплейного адаптера используется,
сколько в системе принтеров, адаптеров
последовательного интерфейса RS232, подключен ли
игровой адаптер (джойстик)? </p>

<p>Обычно прикладная программа не работает сама с
аппаратурой, а пользуется услугами операционной
системы. При обращении к стандартной аппаратуре
через операционную систему программа
пользователя получит признак ошибки, если
запрашиваемое устройство отсутствует.
Программы, составленные на языке
программирования Си при использовании
библиотеки эмуляции арифметического
сопроцессора, сами определяют, имеется
сопроцессор или нет, и не пытаются пользоваться
отсутствующим устройством. Операции
сопроцессора эмулируются центральным
процессором и программа просто работает
медленнее. </p>

<p>Но если программа обращается непосредственно к
портам ввода/вывода отсутствующего устройства,
это может привести в лучшем случае к зависанию
системы. </p>

<h4>INT&nbsp;12h - Получить размер основной памяти.</h4>

<p>Сказанное выше справедливо и по отношению к
оперативной памяти. Для работы некоторых
программ требуется достаточное количество
памяти. Прерывание INT&nbsp;12h возвращает в регистре
AX количество имеющихся блоков памяти размером в
один килобайт. Анализируя эту величину,
программы могут при нехватке памяти либо вывести
на экран соответствующее сообщение и отказаться
от работы, либо изменить алгоритмы работы,
организовав, например, &quot;виртуальную&quot; память
на диске или просто записывая в файл
промежуточные результаты. </p>

<p>Если Ваш компьютер оборудован расширенной
памятью (адресное пространство этой памяти
находится выше границы в 1 мегабайт), размер этой
памяти в килобайтах можно узнать, вызвав
прерывание INT&nbsp;15h со значением регистра AX,
равным 8800h. </p>

<h3>Работа с дисплейным адаптером.</h3>

<p>Прерывание INT&nbsp;10h выполняет все
многочисленные операции по обслуживанию
дисплейного адаптера. </p>

<p>При вызове прерывания INT&nbsp;10h, как и при вызове
многих других прерываний, регистр AH содержит
номер функции, которую требуется выполнить.
Остальные регистры при вызове прерывания
содержат операнды. </p>

<p>Программирование дисплейного адаптера -
сложная задача. Функции, выполняемые прерыванием
INT&nbsp;10h обширны, полностью они будут описаны во
втором томе книги. Приведем краткий обзор
функций прерывания INT&nbsp;10h. </p>

<h4>00h - Задание видеорежима.</h4>

<p>Эта функция обычно вызывается первой при
начале работы с дисплейным адаптером или при
необходимости изменить текущий режим адаптера.
Что здесь имеется в виду? </p>

<p>Напомним, что дисплейный адаптер может
работать либо в текстовом, либо в графическом
режиме. На самом деле существует несколько
текстовых и несколько графических режимов,
различающихся количеством строк и столбцов,
способом представления цвета и т.д. </p>

<p>В процессе инициализации BIOS задает начальный
режим адаптера исходя из его типа. Если Вашей
программе нужен другой режим, отличный от
исходного, она должна использовать эту функцию.
При этом необходимо учитывать, что дисплейные
адаптеры могут поддерживать не все режимы. </p>

<h4>01h - Установить характеристики курсора.</h4>

<p>С помощью этой функции вы можете установить
размер и форму курсора, сделать курсор мигающим
или убрать его совсем. </p>

<h4>02h - Установить положение курсора.</h4>

<p>Эта функция позволяет управлять расположением
курсора на экране, в частности, один из способов
убрать курсор - расположить его за пределами
экрана, например, на несуществующей 26 строке. </p>

<h4>03h - Получить положение курсора.</h4>

<p>Программа может узнать в любое время, где
расположен курсор. Это может потребоваться ей,
например, для того, чтобы переместить курсор в
следующую позицию (вправо, вверх, вниз, на 10
символов левее текущего положения и т.д.). </p>

<h4>04h - Получить положение светового пера.</h4>

<p>Световое перо используется относительно редко,
однако если оно есть, то функция 04h позволит вам
работать с этим устройством. </p>

<h4>05h - Выбрать активную страницу дисплейной
памяти.</h4>

<p>Компьютер хранит, как правило, не один
отображаемый образ экрана, а несколько. Для этого
видеопамять (память для хранения
видеоизображения, находится на плате
видеоконтроллера) разбивается на так называемые
страницы. Отображается только активная страница
видеопамяти. </p>

<p>Используя механизм страниц, программа может
заранее подготовить изображение в неактивной
странице, затем сделать подготовленную страницу
активной. Изображение новой страницы мгновенно
появится на экране. </p>

<p>Некоторые отладчики программ используют одну
страницу видеопамяти для отлаживаемой
программы, другую - для выдачи своих
диагностических сообщений. </p>

<h4>06h, 07h - Прокрутка (скроллинг) окна вверх/вниз.</h4>

<p>С помощью этих функций вы сможете переместить
выбранную область окна на заданное число строк
вверх или вниз. Освободившееся место будет
заполняться пустыми строками. Одно из применений
этой функции - полная очистка экрана. </p>

<h4>08h, 09h - Прочитать/записать символ и атрибут.</h4>

<p>С помощью этих функций можно прочитать или
записать символ и его атрибут. При записи символа
можно задать число повторений. Функцию записи с
повторением удобно использовать для заполнения
области экрана каким-либо символом. </p>

<p>Запись/чтение символа начинается с текущего
положения курсора. </p>

<h4>0Ah - Записать символ.</h4>

<p>Эта функция предназначена для записи символа в
видеопамять без задания для него
индивидуального значения атрибута. Используется
текущий атрибут. Можно задавать кратность
записи. </p>

<h4>0Bh - Выбрать цветовую палитру.</h4>

<p>Эта функция позволяет управлять цветом рамки
вокруг изображения в текстовом режиме и цветом
фона в графическом режиме (для адаптеров EGA, VGA). </p>

<h4>0Ch, 0Dh - Записать/прочитать графическую точку.</h4>

<p>Можно высветить точку заданного цвета в
заданном месте экрана для выбранной дисплейной
страницы или прочитать значение цвета любой
точки на экране соответственно. </p>

<h4>0Eh - Запись символа на экран в стиле TTY.</h4>

<p>После записи символа на экран курсор
продвигается на следующую позицию, при этом
обрабатываются такие управляющие символы, как BEL
(подача звукового сигнала), возврат на одну
позицию, перевод строки, возврат к началу строки. </p>

<h4>0Fh - Прочитать текущий видеорежим.</h4>

<p>Если Ваша программа изменяет видеорежим, она
может сохранить старый видеорежим, получив его с
помощью этой функции. </p>

<p>Кроме того, функция возвращает количество
столбцов на экране и номер текущей активной
дисплейной страницы. </p>

<h4>10h, 11h, 12h - Обслуживание адаптера EGA.</h4>

<p>Эти функции работают только при использовании
дисплейных адаптеров EGA и VGA. Они позволяют
устанавливать свою цветовую палитру, загружать
знакогенератор (например, шрифтом для русских
букв) и выполнять некоторые другие функции. </p>

<h4>13h - Запись строки.</h4>

<p>Для машин класса AT и выше при наличии
дисплейных адаптеров EGA или VGA эта функция
позволяет вывести на экран произвольную строку
символов заданной длины, с заданным атрибутом и в
заданном месте экрана. Можно также задать номер
дисплейной страницы. </p>

<p>Если вы не можете использовать эту функцию (Ваш
компьютер - XT или дисплейный адаптер - CGA),
единственный способ вывести на экран строку
символов с помощью прерывания INT&nbsp;10h - вызывать в
цикле функции 09h, 0Ah или 0Eh для вывода строки по
одному символу. </p>

<h3>Обслуживание клавиатуры.</h3>

<p>Обработчик прерывания INT&nbsp;16h выполняет
несколько функций, связанных с обслуживанием
клавиатуры. Мы не будем сейчас перечислять эти
функции, они будут подробно описаны в главе,
посвященной клавиатуре. С помощью функций
обслуживания клавиатуры можно выполнить ввод
кода нажатой клавиши как с ожиданием нажатия, так
и без ожидания. В последнем случае функция сразу
после вызова возвращает код нажатой клавиши или
признак того, что никакая клавиша не нажималась. </p>

<p>Заметим, что символы, введенные с клавиатуры,
помещаются в специальный клавиатурный буфер.
Функция ввода символа без ожидания нажатия на
клавишу проверяет состояние буфера - есть в нем
символы, или нет. Если в буфере есть символы,
первый помещенный в буфер символ возвращается
программе. Этот символ затем может быть считан
функцией ввода с ожиданием нажатия - фактически
ожидания при этом не будет. </p>

<p>Для очистки буфера клавиатуры также можно
использовать пару описанных выше функций:
сначала программа проверяет пуст ли буфер, и,
если он не пуст, считывает символ. Считанный
символ никуда не помещается (теряется). После
считывания символа программа опять проверяет
содержимое буфера и так до тех пор, пока
клавиатурный буфер не окажется пустым. </p>

<p>Для машин класса не ниже AT обработчик
прерывания INT&nbsp;16h выполняет и другие функции:
установку задержки, запись символов в буфер
клавиатуры, обслуживание расширенной
клавиатуры. </p>

<h3>Обслуживание дисковой подсистемы.</h3>

<p>Прерывание INT&nbsp;13h предназначено для
обслуживания жестких и флоппи-дисков.
Многочисленные функции прерывания INT&nbsp;13h
выполняют все операции по вводу/выводу на диски.
Мы сделаем обзор только самых важных функций,
остальные будут рассмотрены в книге 3,
посвященной файловой системе. </p>

<h4>00h - Сброс дисковой системы.</h4>

<p>Эта функция выполняет установку в исходное
состояние всей дисковой системы или выбранного
дискового устройства. Используется обычно перед
началом работы с устройством. </p>

<h4>01h - Получить состояние дисковой системы.</h4>

<p>Эта функция позволяет проверить результат
выполнения предыдущей операции. Если операция
завершилась аварийно, при помощи этой функции
можно определить код ошибки. </p>

<h4>02h/03h - Чтение/запись секторов.</h4>

<p>Выполняется чтение секторов в оперативную
память компьютера или запись информации из
памяти в сектора диска. </p>

<p>Сектор задается для выбранных устройства,
дорожки и головки. Программа должна также задать
количество читаемых/записываемых секторов. </p>

<h4>04h - Проверка секторов.</h4>

<p>Функция проверяет сектора на правильность
циклической контрольной суммы, CRC (Cyclic Redundancy Check);
записи содержимого секторов в память не
происходит. </p>

<h4>Другие функции прерывания INT&nbsp;13h.</h4>

<p>Среди других функций прерывания INT&nbsp;13h -
форматирование дорожки, позиционирование
головки на заданную дорожку диска, тестирование
и предварительная установка диска, запуск
диагностики контроллера и многое другое.
Описание этих функций мы отложим до глав,
посвященных файловой системе. </p>

<h3>Вывод на принтер (параллельный порт).</h3>

<p>BIOS содержит простейшую поддержку принтера - три
функции прерывания INT&nbsp;17h. Это функция 01h -
инициализация принтера, 02h - опрос состояния
принтера и 00h - вывод символа на принтер. </p>

<p>Поскольку к персональному компьютеру можно
подключить несколько последовательных портов,
при обращении к принтеру следует указывать номер
порта. </p>

<h3>Обслуживание последовательного порта связи</h3>

<p>Функции прерывания INT&nbsp;14h обслуживают порт
последовательной передачи данных RS232. С помощью
этих функций можно задавать формат и скорость
передачи данных, определять состояние портов и,
конечно, выполнять побайтную передачу данных. </p>

<h3>Работа с системными часами.</h3>

<p>Функции прерывания INT&nbsp;1Ah обслуживают часы,
имеющиеся в каждом компьютере. С их помощью вы
можете установить время и дату, опросить текущее
состояние часов. Вы можете работать с часами
реального времени, которые имеются на машинах
класса не ниже AT. </p>

<p>Для AT можно установить на заданное время
&quot;будильник&quot; - в нужный момент будет вызвано
прерывание &quot;будильника&quot; с номером 4Ah.
Обработчик прерывания INT&nbsp;4Ah может подать
звуковой сигнал или вывести на экран
предупреждающее сообщение. </p>

<h3>Перезагрузка операционной системы.</h3>

<p>Вызов прикладной программой прерывания INT&nbsp;19h
приведет к перезагрузке операционной системы. </p>

<h3>Системный сервис для машин класса AT.</h3>

<p>Прерывание INT&nbsp;15h использовалось в
компьютерах IBM&nbsp;PC и IBM&nbsp;PC&nbsp;Jr для управления
кассетным накопителем на магнитной ленте
(функции 0-3). Для машин класса AT и более высокого
класса прерывание INT&nbsp;15h имеет и другое
назначение. С его помощью обслуживается
расширенная клавиатура, выполняется программная
задержка, задаваемая в микросекундах,
обслуживается расширенная память. Кроме того,
одна из функций прерывания INT&nbsp;15h переводит
процессор 80286 или 80386 в защищенный режим. Заметим,
что вернуть процессор обратно в реальный режим
можно только сигналом начального сброса. Это же
относится и к арифметическому сопроцессору 80287. </p>

<p>Функция C0h прерывания INT&nbsp;15h выдает
дополнительные сведения о конфигурации
аппаратных средств компьютера. </p>

<p>Для PS/2 назначение некоторых функций этого
прерывания другое по сравнению с машиной AT. </p>

<p>На этом мы завершим описание предоставляемых
BIOS функций и перейдем к обзору функций DOS. </p>

<h2><a NAME="ch1_5">1.5. Обзор прерываний DOS</a></h2>

<p>DOS предоставляет программе набор системных
вызовов, реализованных с использованием
механизма программных прерываний. Эти вызовы
открывают прикладной программе доступ к
системной информации, к системе консольного
ввода/вывода, файловой системе, к подсистеме
управления программами и памятью, позволяют
организовать обращение к драйверам устройств
ввода/вывода и т.д. </p>

<p>Все основные функции DOS вызываются с помощью
прерывания INT&nbsp;21h, однако DOS использует и другие
прерывания: </p>

<table>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;20h </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">завершение работы
    программы; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;25h/26h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">чтение/запись на диск с
    абсолютной адресацией секторов; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;27h </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">завершение работы
    программы с оставлением ее резидентной в памяти; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;28h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">прерывание
    зарезервировано для DOS, может быть использовано
    для составления резидентных программ; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;2Eh</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">выполнение команды DOS; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="96">INT&nbsp;2Fh</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="362">прерывание
    мультиплексора, используется для спулера печати
    PRINT.COM. </td>
  </tr>
</table>

<p>Функции прерывания INT&nbsp;21h можно разделить на
следующие группы: 

<ul>
  <li>получение системной информации; </li>
  <li>символьный ввод/вывод; </li>
  <li>работа с файловой системой; </li>
  <li>управление программами; </li>
  <li>управление памятью; </li>
  <li>связь с драйверами устройств; </li>
  <li>прочий системный сервис. </li>
</ul>

<p>В данном обзоре мы кратко рассмотрим эти
группы, делая акцент в основном на составе
функций. Полностью информация об использовании
функций прерывания DOS INT&nbsp;21h (и других прерываний
DOS) будет приводиться в соответствующих разделах
книги. </p>

<p>Номер функции задается при вызове прерывания
INT&nbsp;21h в регистре AH. </p>

<h3>Получение системной информации.</h3>

<p>Функция 30h возвращает в регистре AX номер версии
DOS. Например, для версии MS-DOS 5.00 содержимое
регистра AH равно 00, регистра AL - 05. </p>

<p>Дополнительно через регистр BH функция
возвращает программе серийный номер
фирмы-производителя ОЕМ (IBM - 00, DEC - 16h, 0FFh - Microsoft и
т.п.), а в регистрах BL:CX после вызова функции
находится серийный номер пользователя. </p>

<p>Эта информация может применяться для анализа
возможности использования таких средств
операционной системы, которые поддерживаются не
всеми версиями DOS, или для настройки программы на
конкретный серийный номер пользователя. </p>

<p>Функции 2Ah и 2Ch позволяют программе узнать
системную дату и время. </p>

<p>Есть функции, возвращающие текущий диск и
текущий каталог. Номера этих функций - 19h и 47h. </p>

<p>Функция 2Fh позволяет программе узнать адрес
текущей области DTA (Disk Transfer Area). Эта область
используется, например, при поиске файлов в
каталоге. </p>

<p>Важная информация находится в блоке PSP (Programm
Segment Prefix). Этот блок располагается в памяти
непосредственно перед выполняющейся программой.
В нем находятся, в частности, параметры,
передаваемые программе при запуске. Функция 62h
возвращает адрес текущего блока PSP. </p>

<p>Кратко перечислим некоторые другие функции для
получения системной информации: </p>

<table>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="51">35h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="400">получить значение вектора
    прерывания с заданным номером; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="51">4Dh</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="400">узнать код завершения
    процесса; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="51">59h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="400">получить расширенный код
    ошибки; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="51">54h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="400">узнать, используется ли
    проверка при записи на диск; </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="51">33h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="400">узнать, используется ли
    проверка на CTRL-BREAK. </td>
  </tr>
</table>

<h3>Символьный ввод/вывод.</h3>

<p>Эти функции применяются для работы со всеми
символьными устройствами, такими как консоль,
принтер, последовательный порт, и называются
функциями стандартного ввода/вывода. </p>

<p>Ввод/вывод программы, использующей стандартные
функции, может быть переназначен. </p>

<p>Приведем обзор основных функций стандартного
символьного ввода/вывод в виде таблицы: </p>

<table BORDER="1">
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66"><a NAME="UQHTML4">Код</a> </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Назначение</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Описание </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">01h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Ввод с клавиатуры </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Выполняется ввод символа
    со стандартного ввода и эхо-вывод символа на
    стандартное устройство вывода. Выполняется
    проверка на нажатие комбинации клавиш CTRL/C и
    CTRL-BREAK </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">06h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Ввод с клавиатуры </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Ввод символа со
    стандартного ввода без ожидания и вывод его на
    устройство стандартного вывода. Комбинации CTRL/C и
    CTRL-BREAK не проверяются. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">07h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Прямой ввод </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Ввод символа со
    стандартного с клавиатуры устройства ввода.
    Комбинации клавиш CTRL/C и CTRL-BREAK не проверяются. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">08h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Ввод с клавиатуры </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Аналогично функции 07h, но
    проверяются комбинации клавиш CTRL/C и CTRL-BREAK. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">02h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Отобразить символ </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Отображаемый символ
    посылается на стандартное устройство вывода. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">09h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Отобразить строку </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">На стандартное устройство
    вывода символов посылается строка, закрытая
    символом '$'. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">03h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Ввод из последовательного
    порта </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Вводится символ из
    последовательного порта </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">04h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Вывод в последовательный
    порт </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Выводится символ на
    последовательный порт </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="66">05h</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="159">Вывод на принтер </td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="347">Выводится символ на
    принтер. </td>
  </tr>
</table>

<p>Из таблицы видно, что для ввода с клавиатуры
можно использовать несколько функций. Ввод без
эхо-вывода удобен для такой информации, как
пароли. Если логика работы программы не
допускает прерывания по нажатию комбинаций
клавиш CTRL-C или CTRL-BREAK, нужно использовать функции,
которые не проверяют эти комбинации. </p>

<p>Для вывода строки символов можно использовать
функцию 09h, но выводимая строка не может
содержать символ '$', так как этот символ
используется в качестве признака конца строки. </p>

<h3>Работа с файловой системой.</h3>

<p>DOS предоставляет программам обширный сервис
для работы с файлами и дисками. Практически все
файловые операции можно выполнять с помощью
специально предназначенных для этого функций,
только в некоторых случаях (защита данных от
копирования, например) приходится использовать
прямое обращение к диску. </p>

<p>С помощью файловых функций DOS можно создавать и
удалять файлы и каталоги, открывать и закрывать
файлы, создавать временные файлы. Ввод/вывод
может быть буферизован, можно получить как
последовательный доступ к содержимому файла, так
и произвольный. </p>

<p>Мы не будем приводить сейчас конкретные
примеры или номера функций, отложим это до книги
3, посвященной файловой системе. </p>

<h3>Управление программами.</h3>

<p>DOS предоставляет программам возможность
организовать запуск других программ или
загрузку и выполнение программных оверлеев. Для
этого служит функция 4Bh. </p>

<p>Для завершения работы программа должна также
использовать одну из специальных функций DOS.
Функция 4Ch, завершая работу программы, позволяет
передать операционной системе некоторое число,
называемое кодом завершения программы. Это число
может быть затем проанализировано в пакетном
файле командой IF ERRORLEVEL. Если одна программа
запускает другую, то первая может получить код
завершения второй с помощью функции 4Dh. </p>

<p>Для того чтобы завершающаяся программа
осталась в оперативной памяти (т.е. стала
резидентной), она должна вызвать прерывание
INT&nbsp;27h или воспользоваться функцией 31h. </p>

<p>Мы приведем различные примеры запуска программ
из программ и научимся составлять резидентные
программы. </p>

<h3>Управление памятью.</h3>

<p>DOS управляет распределением памяти с помощью
блоков управления памятью MCB (Memory Control Block). Вся
память разбивается на блоки различного размера,
которым предшествует блок MCB, содержащий
характеристики данного блока памяти (например,
его размер). </p>

<p>Программа может динамически получать и
освобождать области памяти с помощью функций 48h и
49h соответственно. Кроме того, можно изменять
размер блока, выделенного операционной системой
программе. Это делает функция 4Ah. </p>

<p>Детально механизм управления памятью будет
рассмотрен в главе 2 при описании векторной
таблицы связи DOS. </p>

<h3>Связь с драйверами устройств.</h3>

<p>Мы уже обращали Ваше внимание на то, что
программы не могут обращаться непосредственно к
драйверам устройств ввода/вывода. Все обращения
к драйверам имеют либо неявный характер
(ввод/вывод с помощью функций прерывания INT&nbsp;21h),
либо используют специальную функцию DOS с кодом 44h.
Эта функция используется для обмена управляющей
информацией между драйвером и программой. </p>

<h3>Другие функции.</h3>

<p>Существуют функции, позволяющие
переопределять прерывания, работать с
системными часами и календарем, функции для
работы в сети и некоторые другие. Эти функции
будут описаны позже в соответствующих разделах
книги. </p>

<h2><a NAME="ch1_6">1.6. Обработка ошибок</a></h2>

<p>Когда программа обращается к DOS для выполнения
какой-либо операции, она должна вызвать
соответствующее прерывание, загрузив перед
вызовом прерывания все необходимые операнды в
регистры процессора. Если выполнение операции
невозможно по каким-то причинам (неправильные
операнды, устройство неработоспособно,
запрашиваемая операция не поддерживается
текущей версией DOS и т.д.), то для большинства
функций DOS устанавливается признак ошибки - флаг
переноса CARRY. Для DOS версии 2.0 и более поздних
версий регистр AX при этом содержит код ошибки. </p>

<p>Приведем коды ошибок, возвращаемые программе
через регистр AX: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="377">Неправильный код функции </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="377">Файл не найден</td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="377">Путь не найден</td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="377">Слишком много открытых файлов </td>
  </tr>
  <tr>
    <td WIDTH="48">5</td>
    <td WIDTH="377">Доступ запрещен</td>
  </tr>
  <tr>
    <td WIDTH="48">6</td>
    <td WIDTH="377">Неправильный идентификатор файла </td>
  </tr>
  <tr>
    <td WIDTH="48">7</td>
    <td WIDTH="377">Разрушен блок управления памятью </td>
  </tr>
  <tr>
    <td WIDTH="48">8</td>
    <td WIDTH="377">Недостаточно памяти</td>
  </tr>
  <tr>
    <td WIDTH="48">9</td>
    <td WIDTH="377">Неправильный адрес блока памяти </td>
  </tr>
  <tr>
    <td WIDTH="48">10</td>
    <td WIDTH="377">Неправильная среда</td>
  </tr>
  <tr>
    <td WIDTH="48">11</td>
    <td WIDTH="377">Неправильный формат</td>
  </tr>
  <tr>
    <td WIDTH="48">12</td>
    <td WIDTH="377">Неправильный код доступа </td>
  </tr>
  <tr>
    <td WIDTH="48">13</td>
    <td WIDTH="377">Неправильные данные</td>
  </tr>
  <tr>
    <td WIDTH="48">14</td>
    <td WIDTH="377">Зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="48">15</td>
    <td WIDTH="377">Ошибка при указании дисковода </td>
  </tr>
  <tr>
    <td WIDTH="48">16</td>
    <td WIDTH="377">Невозможно удалить текущий каталог </td>
  </tr>
  <tr>
    <td WIDTH="48">17</td>
    <td WIDTH="377">Другое устройство</td>
  </tr>
  <tr>
    <td WIDTH="48">18</td>
    <td WIDTH="377">Больше нет подходящих файлов </td>
  </tr>
</table>

<p>Для DOS версии 3.0 и более поздних версий
обработка ошибок значительно расширена. Введена
функция 59h прерывания INT&nbsp;21h, предназначенная
для получения дополнительной информации об
ошибках. </p>

<p>При вызове этой функции регистр BX должен
содержать индикатор уровня анализа ошибок,
который должен быть равен 0. Кроме расширенного
кода ошибки, возвращаемого в регистре AX,
программа может получить класс ошибки (регистр
BH), код предполагаемых действий (регистр BL),
локализацию ошибки, т.е. место, где произошла
ошибка (регистр CH). </p>

<p>К сожалению, эта функция разрушает содержимое
регистров CL, DX, SI, DI, BP, DS, ES. Программа,
использующая функцию 59h, должна позаботиться о
сохранении содержимого этих регистров. </p>

<p>Расширенный код ошибки, возвращаемый в
регистре AX, может принимать значения, указанные в
приводимой ниже таблице. Коды от 1 до 18
эквивалентны представленным выше и второй раз не
приводятся. </p>

<p>Расширенные коды ошибок: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="66">19</td>
    <td WIDTH="363">Запись на защищенный от записи диск </td>
  </tr>
  <tr>
    <td WIDTH="66">20</td>
    <td WIDTH="363">Задан неизвестный идентификатор
    устройства </td>
  </tr>
  <tr>
    <td WIDTH="66">21</td>
    <td WIDTH="363">Дисковод не готов</td>
  </tr>
  <tr>
    <td WIDTH="66">22</td>
    <td WIDTH="363">Неизвестная команда</td>
  </tr>
  <tr>
    <td WIDTH="66">23</td>
    <td WIDTH="363">Ошибка циклического кода проверки </td>
  </tr>
  <tr>
    <td WIDTH="66">24</td>
    <td WIDTH="363">Неправильная длина структуры запроса </td>
  </tr>
  <tr>
    <td WIDTH="66">25</td>
    <td WIDTH="363">Ошибка поиска</td>
  </tr>
  <tr>
    <td WIDTH="66">26</td>
    <td WIDTH="363">Неизвестен тип среды носителя данных </td>
  </tr>
  <tr>
    <td WIDTH="66">27</td>
    <td WIDTH="363">Сектор не найден</td>
  </tr>
  <tr>
    <td WIDTH="66">28</td>
    <td WIDTH="363">Кончилась бумага в принтере </td>
  </tr>
  <tr>
    <td WIDTH="66">29</td>
    <td WIDTH="363">Ошибка записи</td>
  </tr>
  <tr>
    <td WIDTH="66">30</td>
    <td WIDTH="363">Ошибка чтения</td>
  </tr>
  <tr>
    <td WIDTH="66">31</td>
    <td WIDTH="363">Общая ошибка</td>
  </tr>
  <tr>
    <td WIDTH="66">32</td>
    <td WIDTH="363">Нарушение разделения файла </td>
  </tr>
  <tr>
    <td WIDTH="66">33</td>
    <td WIDTH="363">Нарушение блокировки файла </td>
  </tr>
  <tr>
    <td WIDTH="66">34</td>
    <td WIDTH="363">Неправильная замена диска </td>
  </tr>
  <tr>
    <td WIDTH="66">35</td>
    <td WIDTH="363">FCB недоступен (слишком много блоков FCB) </td>
  </tr>
  <tr>
    <td WIDTH="66">36</td>
    <td WIDTH="363">Переполнился буфер разделения </td>
  </tr>
  <tr>
    <td WIDTH="66">37</td>
    <td WIDTH="363">Зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="66">38</td>
    <td WIDTH="363">Не завершена операция &quot;Конец файла&quot;
    </td>
  </tr>
  <tr>
    <td WIDTH="66">39-49</td>
    <td WIDTH="363">Зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="66">50</td>
    <td WIDTH="363">Сетевая функция не поддерживается </td>
  </tr>
  <tr>
    <td WIDTH="66">51</td>
    <td WIDTH="363">Удаленный компьютер &quot;не слышит&quot; </td>
  </tr>
  <tr>
    <td WIDTH="66">52</td>
    <td WIDTH="363">Дублирование имени в сети </td>
  </tr>
  <tr>
    <td WIDTH="66">53</td>
    <td WIDTH="363">Сетевое имя не найдено</td>
  </tr>
  <tr>
    <td WIDTH="66">54</td>
    <td WIDTH="363">Сеть занята</td>
  </tr>
  <tr>
    <td WIDTH="66">55</td>
    <td WIDTH="363">Сетевое устройство больше не существует
    </td>
  </tr>
  <tr>
    <td WIDTH="66">56</td>
    <td WIDTH="363">Превышен лимит команды сетевой BIOS </td>
  </tr>
  <tr>
    <td WIDTH="66">57</td>
    <td WIDTH="363">Ошибка в аппаратуре сетевого адаптера </td>
  </tr>
  <tr>
    <td WIDTH="66">58</td>
    <td WIDTH="363">Неправильный ответ из сети </td>
  </tr>
  <tr>
    <td WIDTH="66">59</td>
    <td WIDTH="363">Непредусмотренная ошибка сети </td>
  </tr>
  <tr>
    <td WIDTH="66">60</td>
    <td WIDTH="363">Несовместимый удаленный адаптер </td>
  </tr>
  <tr>
    <td WIDTH="66">61</td>
    <td WIDTH="363">Заполнена очередь печати </td>
  </tr>
  <tr>
    <td WIDTH="66">62</td>
    <td WIDTH="363">Для печатаемого файла недостаточно
    места </td>
  </tr>
  <tr>
    <td WIDTH="66">63</td>
    <td WIDTH="363">Печатающийся файл был удален </td>
  </tr>
  <tr>
    <td WIDTH="66">64</td>
    <td WIDTH="363">Сетевое имя было удалено </td>
  </tr>
  <tr>
    <td WIDTH="66">65</td>
    <td WIDTH="363">Доступ запрещен</td>
  </tr>
  <tr>
    <td WIDTH="66">66</td>
    <td WIDTH="363">Неправильный тип сетевого устройства </td>
  </tr>
  <tr>
    <td WIDTH="66">67</td>
    <td WIDTH="363">Сетевое имя не найдено</td>
  </tr>
  <tr>
    <td WIDTH="66">68</td>
    <td WIDTH="363">Превышен лимит сетевого имени </td>
  </tr>
  <tr>
    <td WIDTH="66">69</td>
    <td WIDTH="363">Превышен лимит сеанса сетевой BIOS </td>
  </tr>
  <tr>
    <td WIDTH="66">70</td>
    <td WIDTH="363">Временная пауза</td>
  </tr>
  <tr>
    <td WIDTH="66">71</td>
    <td WIDTH="363">Сетевой запрос отвергнут </td>
  </tr>
  <tr>
    <td WIDTH="66">72</td>
    <td WIDTH="363">Приостановлена печать или
    переадресация диска </td>
  </tr>
  <tr>
    <td WIDTH="66">73-79</td>
    <td WIDTH="363">Зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="66">80</td>
    <td WIDTH="363">Файл уже существует</td>
  </tr>
  <tr>
    <td WIDTH="66">81</td>
    <td WIDTH="363">Зарезервировано</td>
  </tr>
  <tr>
    <td WIDTH="66">82</td>
    <td WIDTH="363">Невозможно создать дескриптор в
    каталоге </td>
  </tr>
  <tr>
    <td WIDTH="66">83</td>
    <td WIDTH="363">Ошибка обработчика критических ошибок
    INT&nbsp;24h </td>
  </tr>
  <tr>
    <td WIDTH="66">84</td>
    <td WIDTH="363">Слишком много переназначений </td>
  </tr>
  <tr>
    <td WIDTH="66">85</td>
    <td WIDTH="363">Двойное переназначение</td>
  </tr>
  <tr>
    <td WIDTH="66">86</td>
    <td WIDTH="363">Неправильный пароль</td>
  </tr>
  <tr>
    <td WIDTH="66">87</td>
    <td WIDTH="363">Неправильный параметр</td>
  </tr>
  <tr>
    <td WIDTH="66">88</td>
    <td WIDTH="363">Ошибка данных в сети</td>
  </tr>
  <tr>
    <td WIDTH="66">89</td>
    <td WIDTH="363">Нет такой функции в сети </td>
  </tr>
  <tr>
    <td WIDTH="66">90</td>
    <td WIDTH="363">Требуемый компонент системы не
    установлен </td>
  </tr>
</table>

<p>Класс ошибки, передаваемый в регистре BH,
содержит информацию, которая поможет вам
обработать данную ошибку: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="39">1</td>
    <td WIDTH="381">Недостаточно ресурсов: блоков FCB, памяти
    и т.д. </td>
  </tr>
  <tr>
    <td WIDTH="39">2</td>
    <td WIDTH="381">Временная ситуация</td>
  </tr>
  <tr>
    <td WIDTH="39">3</td>
    <td WIDTH="381">Нет прав доступа</td>
  </tr>
  <tr>
    <td WIDTH="39">4</td>
    <td WIDTH="381">Внутренняя ошибка DOS</td>
  </tr>
  <tr>
    <td WIDTH="39">5</td>
    <td WIDTH="381">Ошибка аппаратуры</td>
  </tr>
  <tr>
    <td WIDTH="39">6</td>
    <td WIDTH="381">Системная ошибка DOS (нет CONFIG.SYS и т.п.) </td>
  </tr>
  <tr>
    <td WIDTH="39">7</td>
    <td WIDTH="381">Ошибка в прикладной программе </td>
  </tr>
  <tr>
    <td WIDTH="39">8</td>
    <td WIDTH="381">Файл или объект не найден </td>
  </tr>
  <tr>
    <td WIDTH="39">9</td>
    <td WIDTH="381">Неправильный формат файла или объекта </td>
  </tr>
  <tr>
    <td WIDTH="39">10</td>
    <td WIDTH="381">Файл или объект заблокирован </td>
  </tr>
  <tr>
    <td WIDTH="39">11</td>
    <td WIDTH="381">Ошибка носителя данных</td>
  </tr>
  <tr>
    <td WIDTH="39">12</td>
    <td WIDTH="381">Файл или объект уже существует </td>
  </tr>
  <tr>
    <td WIDTH="39">13</td>
    <td WIDTH="381">Прочие ошибки</td>
  </tr>
</table>

<p>Код предполагаемых действий, передаваемый
через регистр BL, поможет Вашей программе
правильно обработать ошибку и избежать
зависания системы. Приведем таблицу кодов
предполагаемых действий: </p>

<table BORDER="1">
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">1</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Повторить операцию позже.
    Можно спросить пользователя, желает он повторить
    операцию или завершить работу программы. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">2</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Повторить предыдущую
    операцию после небольшой паузы. Если ошибка не
    исчезла, следует спросить пользователя, будет он
    ждать и дальше, или следует завершить работу
    программы. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">3</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Если пользователь вводил
    какие-то данные для DOS, следует попросить его
    ввести эти данные еще раз (например, пользователь
    мог указать неправильный идентификатор диска
    или путь доступа к файлу). </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">4</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Аварийно завершить работу
    прикладной программы с выполнением всех обычных
    завершающих действий (закрытие файлов, сброс
    буферов на диск, освобождение блоков памяти и
    т.д.) </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">5</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Немедленный выход из
    программы без выполнения завершающих действий.
    Система находится в непредсказуемом состоянии. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">6</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Следует игнорировать
    ошибку. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">7</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="388">Повторить операцию после
    того, как пользователь выполнит требуемые
    действия (установит дискету и т.п.). </td>
  </tr>
</table>

<p>Сведения о локализации ошибки передаются в
регистре CH. Приведем таблицу кодов локализации: </p>

<table BORDER="1">
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">1</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="375">Локализация ошибки не
    может быть определена (система не знает, где
    произошла ошибка). </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">2</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="375">Ошибка произошла в
    блочном устройстве (диск или магнитная лента). </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">3</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="375">Ошибка связана с сетью. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">4</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="375">Ошибка произошла в
    символьном устройстве, например, в принтере. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="34">5</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="375">Ошибка связана с
    оперативной памятью. </td>
  </tr>
</table>

<p>Если Ваша программа составлена на языке
ассемблера, то после обращения к DOS через
прерывание следует проверить состояние флага
переноса: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">int     21h
jc      error</font>
</pre>

<p>Программы, составленные на языке Си, обращаются
к прерываниям DOS обычно с помощью таких функций,
как intdos, int86, intdosx и т.д. Для передачи параметров
используются структуры REGS, WORDREGS, BYTEREGS, SREGS. Они
описаны в файле dos.h, для использования этих
структур программа должна содержать строку: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">include &lt;dos.h&gt;</font>
</pre>

<p>Значение флага переноса записывается в
переменную cflag, определенную в структуре WORDREGS.
Эта структура входит в объединение REGS: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">union REGS {
        struct WORDREGS x;
        struct BYTEREGS h;
}

struct WORDREGS {
        unsigned int ax;
        unsigned int bx;
        unsigned int cx;
        unsigned int dx;
        unsigned int si;
        unsigned int di;
        unsigned int cflag;
}

struct BYTEREGS {
        unsigned char al, ah;
        unsigned char bl, bh;
        unsigned char cl, ch;
        unsigned char dl, dh;
}</font>
</pre>

<p>Проверка переменной cflag может быть выполнена,
например, таким образом: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">union REGS inregs, outregs;

intdos(&amp;inregs, &amp;outregs);
if( outregs.x.cflaf != 0 ) error();</font>
</pre>

<p>Код ошибки при этом содержится в переменной
outregs.x.ax. </p>

<p>Приведем пример программы, которая стирает
каталог с именем DIR в текущем каталоге и, в случае
ошибки, выводит расширенную информацию об
ошибке, класс ошибки, код предполагаемых
действий и код локализации ошибки: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;

union REGS inregs, outregs;
struct SREGS segregs;

void main(void);

void main(void) {

char _far *dir_name = &quot;DIR&quot;;

// Стираем каталог с именем DIR. Для этого вызываем
// функцию 0x3A прерывания INT 21h.

        inregs.h.ah = 0x3a;
        segregs.ds = FP_SEG(dir_name);
        inregs.x.dx = FP_OFF(dir_name);
        intdosx(&amp;inregs, &amp;outregs, &amp;segregs);

// Если после выполнения прерывания установлен
// флаг переноса, выводим сообщение об ошибке.

        if(outregs.x.cflag != 0) {
           printf( &quot;Ошибка при удалении каталога: %d&quot;,
           outregs.x.ax);

// Получаем расширенную информацию об ошибке
// с помощью функции 0x59 прерывания INT 21h.

           inregs.h.ah = 0x59;
           inregs.x.bx = 0;

// Сохраняем регистры в стеке, т.к. их содержимое
// изменится

        _asm {
              push ds
              push es
              push si
              push di
        }

        intdosx(&amp;inregs, &amp;outregs, &amp;segregs);

        _asm {
               pop di
               pop si
               pop es
               pop ds
        }

// Выводим расширенную информацию об ошибке.

        printf(&quot;\nРасширенный код ошибки:   %d&quot;
               &quot;\nКласс ошибки:             %d&quot;
               &quot;\nПредполагаемые действия:  %d&quot;
               &quot;\nЛокализация ошибки:       %d&quot;,
               outregs.x.ax,
               outregs.h.bh,
               outregs.h.bl,
               outregs.h.ch);
        }
}</font>
</pre>

<p>При составлении программ обработки ошибок
следует учитывать, что для DOS версии 1.0 при
некоторых ошибках функции DOS возвращают в
регистре AX значение 0FFh. Начиная с версии DOS 2.0, при
ошибке устанавливается флаг переноса, код ошибки
записывается в регистр AX. Однако для более полной
диагностики причины ошибки следует использовать
функцию 59h прерывания INT&nbsp;21h. </p>

<p>Если Ваша программа, составленная на языке Си,
вызывает функции DOS неявным образом (через
функции стандартной библиотеки транслятора,
такие как fprintf, puts и т.д.), то можно воспользоваться
средствами обработки ошибок, входящими в состав
стандартной библиотеки. </p>

<p>Когда при обращении к функциям DOS средствами
стандартной библиотеки транслятора Си возникает
ошибка, то в глобальную переменную errno
записывается код ошибки. </p>

<p>Возможны следующие коды ошибок (они описаны в
файле errno.h и stdlib.h): </p>

<table BORDER="1">
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ECHILD</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Нет порожденных
    процессов. Задача, не имеющая подзадач, выдала
    команду ожидания, или была выдана команда
    ожидания для подзадачи, имеющей признак NO-WAIT. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EAGAIN</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Больше нет процессов.
    Попытка создать новый процесс окончилась
    неудачно, т.к. либо больше нет резервов для
    создания процессов, либо недостаточно
    оперативной памяти, либо превышен максимальный
    уровень вложенности процессов. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">E2BIG</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Слишком велик список
    аргументов. Либо размер списка аргументов
    превышает 128 байт, либо требуемый размер памяти
    для среды превышает 32К. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EACCES</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Доступ запрещен.
    Затребованный вид доступа к файлу запрещен или
    несовместим с установленными атрибутами файла
    (или каталога). Этот код ошибки передается при
    попытке чтения из неоткрытого файла, при попытке
    записи в файл, защищенный от записи, или при
    попытке открыть каталог как файл. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EBADF</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Плохой номер файла. Номер
    файла, использованный при вызове функции, имеет
    неверное значение или не относится к открытому
    файлу, или сделана попытка записи в открытый
    только для чтения файл или устройство. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EDEADLOCK</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Произошла блокировка
    ресурсов. Произведено 10 неудачных попыток
    заблокировать файл. Этот код ошибки используется
    только DOS версии 3.0 и более поздних версий. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EDOM</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Ошибка в аргументе
    математической функции. Аргумент математической
    функции вышел за пределы области определения
    этой функции. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EEXIST</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Файл уже существует.
    Сделана попытка создать файл с именем, которое
    уже используется существующим файлом. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EINVAL</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Неверный аргумент. Для
    одного из аргументов функции было задано
    неверное значение. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EMFILE</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Открыто слишком много
    файлов. Исчерпан запас номеров файлов , нельзя
    больше открыть ни одного файла. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ENOENT</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Нет такого файла или
    каталога. Запрошенный файл или каталог
    отсутствует или не может быть найден. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ENOEXEC</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Сделана попытка выполнить
    загрузочный файл, имеющий неправильный формат. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ENOMEM</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Недостаточно памяти. Эта
    ошибка появляется, когда недостаточно памяти для
    запуска процесса или для удовлетворения запроса
    программы на выделение блока памяти. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ENOSPC</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Нет свободного места на
    устройстве. На устройстве нет места для записи
    информации (например, переполнился диск). </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">ERANGE</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Слишком большой
    результат. Слишком большой по величине аргумент
    математической функции привел к частичной или
    полной потере значимости результата. </td>
  </tr>
  <tr>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="130">EXDEV</td>
    <td ALIGN="LEFT" VALIGN="TOP" WIDTH="420">Связь различных
    устройств. Сделана попытка переслать файл на
    другое устройство, используя функцию
    переименования. </td>
  </tr>
</table>

<p>Из приведенного выше списка кодов ошибок видно,
что средствами стандартной библиотеки
транслятора обрабатываются не только ошибки,
возникающие при обращении к функциям DOS, но и
ошибки, появляющиеся при работе с математическим
функциями. </p>

<p>Для диагностической выдачи сообщения об ошибке
можно использовать функции perror и strerror. Первая
функция выводит в stderr соответствующее сообщение
об ошибке, вторая только формирует строку
сообщения. Функции perror и strerror имеют операнд -
указатель на строку. Эта строка добавляется в
начало стандартного сообщения об ошибке. Если к
стандартному сообщению ничего добавлять не надо,
операнд должен иметь значение NULL. </p>

<p>Следует заметить, что значение переменной errno
отражает последнюю ошибку. Успешный вызов
функции не приводит к автоматическому сбросу
переменной errno. </p>

<p>Поэтому функции perror и strerror необходимо вызывать
сразу после того, как вызываемая функция
возвратит признак ошибки. </p>

<p>Приведем пример программы, обрабатывающей
ошибки с использованием переменной errno: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

void main(int argc, char *argv[]) {

FILE *stream;

// Открываем файл только для чтения

        stream = fopen(argv[1], &quot;r&quot;);

// Если произошла ошибка, выводим сообщение

        if( (stream == NULL) || (ferror(stream)) ) {
           perror(&quot;Не могу открыть файл&quot;);
           exit(errno);
        }

// Пытаемся произвести запись в файл, который
// открыт только для чтения. Это приведет к ошибке.

        fprintf(stream, &quot;Пишем в файл\n&quot;);

        if( (stream == NULL) || (ferror(stream)) ) {

// Выводим сообщение об ошибке двумя способами -
// с помощью функции perror и strerror

                perror(&quot;Запись в защищенный файл&quot;);
                printf(&quot;Запись в защищенный файл: %s\n&quot;,
                strerror(errno));

                exit(errno);
        }
        exit( 0 );
}</font>
</pre>

<p>DOS имеет еще одно средство для обработки ошибок
- обработчик критических ошибок (Critical Error Handler).
Этот модуль вызывается DOS, когда она получает
сообщение об ошибке от драйвера устройства. </p>

<p>Модуль выдает на экран хорошо известное вам
сообщение: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Abort, Retry, Ignore?</font>
</pre>

<p>Это сообщение обычно появляется тогда, когда вы
забываете вставить дискету или начинаете
печатать при отключенном принтере. </p>

<p>Прикладные программы могут подключать свой
модуль обработки критических ошибок вместо
стандартного. Мы научимся обрабатывать
критические ошибки в книге 3. Там же будет
приведен соответствующий пример. </p>
</body>
</html>
