<html>

<head>
<title>Прерывания</title>
</head>

<body BGCOLOR="#ffffff">

<h1>4. Прерывания</h1>

<ul>
  <li>4.1. <a HREF="ch4.htm#ch4_1">Механизм прерываний</a> </li>
  <li>4.2. <a HREF="ch4.htm#ch4_2">Таблица векторов прерываний</a> </li>
  <li>4.3. <a HREF="ch4.htm#ch4_3">Маскирование прерываний</a> </li>
  <li>4.4. <a HREF="ch4.htm#ch4_4">Изменение таблицы векторов
    прерываний</a> </li>
  <li>4.5. <a HREF="ch4.htm#ch4_5">Особенности обработки
    аппаратных прерываний</a> </li>
</ul>

<h2><a NAME="ch4_1">4.1. Механизм прерываний</a></h2>

<p>Для обработки событий, происходящих асинхронно
по отношению к выполнению программы, лучше всего
подходит механизм прерываний. Прерывание можно
рассматривать как некоторое особое событие в
системе, требующее моментальной реакции.
Например, хорошо спроектированные системы
повышенной надежности используют прерывание по
аварии в питающей сети для выполнения процедур
записи содержимого регистров и оперативной
памяти на магнитный носитель с тем, чтобы после
восстановления питания можно было продолжить
работу с того же места. </p>

<p>Кажется очевидным, что возможны самые
разнообразные прерывания по самым различным
причинам. Поэтому прерывание рассматривается не
просто как таковое: с ним связывают число,
называемое номером типа прерывания или просто
номером прерывания. С каждым номером прерывания
связывается то или иное событие. Система умеет
распознавать, какое прерывание, с каким номером
оно произошло, и запускает соответствующую этому
номеру процедуру. </p>

<p>Программы могут сами вызывать прерывания с
заданным номером. Для этого они используют
команду INT. Это так называемые программные
прерывания. Программные прерывания не являются
асинхронными, так как вызываются из программы (а
она-то знает, когда она вызывает прерывание!). </p>

<p>Программные прерывания удобно использовать
для организации доступа к отдельным, общим для
всех программ модулям. Например, программные
модули операционной системы доступны прикладным
программам именно через прерывания, и нет
необходимости при вызове этих модулей знать их
текущий адрес в памяти. Прикладные программы
могут сами устанавливать свои обработчики
прерываний для их последующего использования
другими программами. Для этого встраиваемые
обработчики прерываний должны быть резидентными
в памяти. Мы научимся создавать свои программы
обработки прерываний и будем говорить об этом
при обсуждении резидентных программ. </p>

<p>Аппаратные прерывания вызываются физическими
устройствами и приходят асинхронно. Эти
прерывания информируют систему о событиях,
связанных с работой устройств, например о том,
что наконец-то завершилась печать символа на
принтере и неплохо было бы выдать следующий
символ, или о том, что требуемый сектор диска уже
прочитан, его содержимое доступно программе. </p>

<p>Использование прерываний при работе с
медленными внешними устройствами позволяют
совместить ввод/вывод с обработкой данных в
центральном процессоре и в результате повышает
общую производительность системы. </p>

<p>Некоторые прерывания (первые пять в порядке
номеров) зарезервированы для использования
самим центральным процессором на случай
каких-либо особых событий вроде попытки деления
на ноль, переполнения и т.п. </p>

<p>Иногда желательно сделать систему
нечувствительной ко всем или отдельным
прерываниям. Для этого используют так называемое
маскирование прерываний, о котором мы еще будем
подробно говорить. Но некоторые прерывания
замаскировать нельзя, это немаскируемые
прерывания. </p>

<p>Заметим еще, что обработчики прерываний могут
сами вызывать программные прерывания, например,
для получения доступа к сервису BIOS или DOS (сервис
BIOS также доступен через механизм программных
прерываний). </p>

<p>Составление собственных программ обработки
прерываний и замена стандартных обработчиков DOS
и BIOS является ответственной и сложной работой.
Необходимо учитывать все тонкости работы
аппаратуры и взаимодействия программного и
аппаратного обеспечения. При отладке возможно
разрушение операционной системы с
непредсказуемыми последствиями, поэтому надо
очень внимательно следить за тем, что делает Ваша
программа. </p>

<h2><a NAME="ch4_2">4.2. Таблица векторов прерываний</a></h2>

<p>Для того чтобы связать адрес обработчика
прерывания с номером прерывания, используется
таблица векторов прерываний, занимающая первый
килобайт оперативной памяти - адреса от 0000:0000 до
0000:03FF. Таблица состоит из 256 элементов - FAR-адресов
обработчиков прерываний. Эти элементы
называются векторами прерываний. В первом слове
элемента таблицы записано смещение, а во втором -
адрес сегмента обработчика прерывания. </p>

<p>Прерыванию с номером 0 соответствует адрес
0000:0000, прерыванию с номером 1 - 0000:0004 и т.д. Для
программиста, использующего язык Си, таблицу
можно описать следующим образом: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void (* interrupt_table[256])();</font>
</pre>

<p>Инициализация таблицы происходит частично
BIOSпосле тестирования аппаратуры и перед началом
загрузки операционной системой, частично при
загрузке DOS. DOS может переключить на себя
некоторые прерывания BIOS. </p>

<p>Займемся теперь содержимым таблицы векторов
прерываний. Приведем назначение некоторых
наиболее важных векторов: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="78">Номер </td>
    <td VALIGN="TOP" WIDTH="445">Описание </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">0</td>
    <td VALIGN="TOP" WIDTH="445">Ошибка деления. Вызывается
    автоматически после выполнения команд DIV или IDIV,
    если в результате деления происходит
    переполнение (например, при делении на 0). DOS
    обычно при обработке этого прерывания выводит
    сообщение об ошибке и останавливает выполнение
    программы. Для процессора 8086 при этом адрес
    возврата указывает на следующую после команды
    деления команду, а в процессоре 80286 - на первый
    байт команды, вызвавшей прерывание. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1</td>
    <td VALIGN="TOP" WIDTH="445">Прерывание пошагового режима.
    Вырабатывается после выполнения каждой машинной
    команды, если в слове флагов установлен бит
    пошаговой трассировки TF. Используется для
    отладки программ. Это прерывание не
    вырабатывается после выполнения команды MOV в
    сегментные регистры или после загрузки
    сегментных регистров командой POP. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">2</td>
    <td VALIGN="TOP" WIDTH="445">Аппаратное немаскируемое
    прерывание. Это прерывание может использоваться
    по-разному в разных машинах. Обычно
    вырабатывается при ошибке четности в
    оперативной памяти и при запросе прерывания от
    сопроцессора. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">3</td>
    <td VALIGN="TOP" WIDTH="445">Прерывание для трассировки. Это
    прерывание генерируется при выполнении
    однобайтовой машинной команды с кодом CCh и обычно
    используется отладчиками для установки точки
    прерывания. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">4</td>
    <td VALIGN="TOP" WIDTH="445">Переполнение. Генерируется
    машинной командой INTO, если установлен флаг OF.
    Если флаг не установлен, то команда INTO
    выполняется как NOP. Это прерывание используется
    для обработки ошибок при выполнении
    арифметических операций. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">5</td>
    <td VALIGN="TOP" WIDTH="445">Печать копии экрана.
    Генерируется при нажатии на клавиатуре клавиши
    PrtScr. Обычно используется для печати образа
    экрана. Для процессора 80286 генерируется при
    выполнении машинной команды BOUND, если
    проверяемое значение вышло за пределы заданного
    диапазона. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">6</td>
    <td VALIGN="TOP" WIDTH="445">Неопределенный код операции или
    длина команды больше 10 байт (для процессора 80286). </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">7</td>
    <td VALIGN="TOP" WIDTH="445">Особый случай отсутствия
    математического сопроцессора (процессор 80286). </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">8</td>
    <td VALIGN="TOP" WIDTH="445">IRQ0 - прерывание интервального
    таймера, возникает 18,2 раза в секунду. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">9</td>
    <td VALIGN="TOP" WIDTH="445">IRQ1 - прерывание от клавиатуры.
    Генерируется при нажатии и при отжатии клавиши.
    Используется для чтения данных от клавиатуры. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">A</td>
    <td VALIGN="TOP" WIDTH="445">IRQ2 - используется для
    каскадирования аппаратных прерываний в машинах
    класса AT. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">B</td>
    <td VALIGN="TOP" WIDTH="445">IRQ3 - прерывание асинхронного
    порта COM2. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">C</td>
    <td VALIGN="TOP" WIDTH="445">IRQ4 - прерывание асинхронного
    порта COM1. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">D</td>
    <td VALIGN="TOP" WIDTH="445">IRQ5 - прерывание от контроллера
    жесткого диска для XT. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">E</td>
    <td VALIGN="TOP" WIDTH="445">IRQ6 - прерывание генерируется
    контроллером флоппи-диска после завершения
    операции. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">F</td>
    <td VALIGN="TOP" WIDTH="445">IRQ7 - прерывание принтера.
    Генерируется принтером, когда он готов к
    выполнению очередной операции. Многие адаптеры
    принтера не используют это прерывание. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">10</td>
    <td VALIGN="TOP" WIDTH="445">Обслуживание видеоадаптера. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">11</td>
    <td VALIGN="TOP" WIDTH="445">Определение конфигурации
    устройств в системе. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">12</td>
    <td VALIGN="TOP" WIDTH="445">Определение размера оперативной
    памяти в системе. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">13</td>
    <td VALIGN="TOP" WIDTH="445">Обслуживание дисковой системы. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">14</td>
    <td VALIGN="TOP" WIDTH="445">Последовательный ввод/вывод. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">15</td>
    <td VALIGN="TOP" WIDTH="445">Расширенный сервис для
    AT-компьютеров. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">16</td>
    <td VALIGN="TOP" WIDTH="445">Обслуживание клавиатуры. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">17</td>
    <td VALIGN="TOP" WIDTH="445">Обслуживание принтера. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">18</td>
    <td VALIGN="TOP" WIDTH="445">Запуск BASIC в ПЗУ, если он есть. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">19</td>
    <td VALIGN="TOP" WIDTH="445">Загрузка операционной системы. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1A</td>
    <td VALIGN="TOP" WIDTH="445">Обслуживание часов. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1B</td>
    <td VALIGN="TOP" WIDTH="445">Обработчик прерывания Ctrl-Break. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1C</td>
    <td VALIGN="TOP" WIDTH="445">Прерывание возникает 18.2 раза в
    секунду, вызывается программно обработчиком
    прерывания таймера. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1D</td>
    <td VALIGN="TOP" WIDTH="445">Адрес видеотаблицы для
    контроллера видеоадаптера 6845. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1E</td>
    <td VALIGN="TOP" WIDTH="445">Указатель на таблицу параметров
    дискеты. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">1F</td>
    <td VALIGN="TOP" WIDTH="445">Указатель на графическую таблицу
    для символов с кодами ASCII 128-255. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">20-5F</td>
    <td VALIGN="TOP" WIDTH="445">Используется DOS или
    зарезервировано для DOS. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">60-67</td>
    <td VALIGN="TOP" WIDTH="445">Прерывания, зарезервированные
    для пользователя. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">68-6F</td>
    <td VALIGN="TOP" WIDTH="445">Не используются. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">70</td>
    <td VALIGN="TOP" WIDTH="445">IRQ8 - прерывание от часов
    реального времени. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">71</td>
    <td VALIGN="TOP" WIDTH="445">IRQ9 - прерывание от контроллера EGA. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">72</td>
    <td VALIGN="TOP" WIDTH="445">IRQ10 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">73</td>
    <td VALIGN="TOP" WIDTH="445">IRQ11 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">74</td>
    <td VALIGN="TOP" WIDTH="445">IRQ12 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">75</td>
    <td VALIGN="TOP" WIDTH="445">IRQ13 - прерывание от
    математического сопроцессора. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">76</td>
    <td VALIGN="TOP" WIDTH="445">IRQ14 - прерывание от контроллера
    жесткого диска. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">77</td>
    <td VALIGN="TOP" WIDTH="445">IRQ15 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">78 - 7F</td>
    <td VALIGN="TOP" WIDTH="445">Не используются. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">80-85</td>
    <td VALIGN="TOP" WIDTH="445">Зарезервированы для BASIC. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">86-F0</td>
    <td VALIGN="TOP" WIDTH="445">Используются интерпретатором
    BASIC. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="78">F1-FF</td>
    <td VALIGN="TOP" WIDTH="445">Не используются. </td>
  </tr>
</table>

<p>IRQ0 - IRQ15 - это аппаратные прерывания, о них будет
рассказано позже. </p>

<h2><a NAME="ch4_3">4.3. Маскирование прерываний</a></h2>

<p>Часто при выполнении критических участков
программ, для того чтобы гарантировать
выполнение определенной последовательности
команд целиком, приходится запрещать прерывания.
Это можно сделать командой CLI. Ее нужно поместить
в начало критической последовательности команд,
а в конце расположить команду STI, разрешающую
процессору воспринимать прерывания. Команда CLI
запрещает только маскируемые прерывания,
немаскируемые всегда обрабатываются
процессором. </p>

<p>Если вы используете запрет прерываний с
помощью команды CLI, следите за тем, чтобы
прерывания не отключались на длительный период
времени, так как это может привести к
нежелательным последствиям. Например, будут
отставать часы. </p>

<p>Если вам надо запретить не все прерывания, а
только некоторые, например, от клавиатуры, то для
этого надо воспользоваться услугами контроллера
прерываний. Подробно об этом немного ниже, сейчас
отметим только, что выдачей в этот контроллер
определенной управляющей информации можно
замаскировать прерывания от отдельных
устройств. </p>

<h2><a NAME="ch4_4">4.4. Изменение таблицы векторов
прерываний</a> </h2>

<p>Вашей программе может потребоваться
организовать обработку некоторых прерываний.
Для этого программа должна переназначить вектор
на свой обработчик. Это можно сделать, изменив
содержимое соответствующего элемента таблицы
векторов прерываний. </p>

<p>Очень важно не забыть перед завершением работы
восстановить содержимое измененных векторов в
таблице прерываний, т.к. после завершения работы
программы память, которая была ей распределена,
считается свободной и может быть использована
для загрузки другой программы. Если вы забыли
восстановить вектор и пришло прерывание, то
система может разрушиться - вектор теперь
указывает на область, которая может содержать
что угодно. </p>

<p>Поэтому последовательность действий для
нерезидентных программ, желающих обрабатывать
прерывания, должна быть такой: 

<ul>
  <li>прочитать содержимое элемента таблицы векторов
    прерываний для вектора с нужным вам номером; </li>
  <li>запомнить это содержимое (адрес старого
    обработчика прерывания) в области данных
    программы; </li>
  <li>установить новый адрес в таблице векторов
    прерываний так, чтобы он соответствовал началу
    Вашей программы обработки прерывания; </li>
  <li>перед завершением работы программы прочитать
    из области данных адрес старого обработчика
    прерывания и записать его в таблицу векторов
    прерываний. </li>
</ul>

<p>Кроме того, операция изменения вектора
прерывания должна быть непрерывной в том смысле,
что во время изменения не должно произойти
прерывание с номером, для которого производится
замена программы обработки. Если вы, например,
запишете новое значение смещения, а сегментный
адрес обновить не успеете, то по какому адресу
будет передано управление в случае прерывания и
что при этом произойдет? Об этом можно только
догадываться. </p>

<p>Для облегчения работы по замене прерывания DOS
предоставляет в Ваше распоряжение специальные
функции для чтения элемента таблицы векторов
прерывания и для записи в нее нового адреса. Если
вы будете использовать эти функции, DOS
гарантирует, что операция по замене вектора
будет выполнена правильно. Вам не надо
заботиться о непрерывности процесса замены
вектора прерывания. </p>

<p>Для чтения вектора используйте функцию 35h
прерывания 21h. Перед ее вызовом регистр AL должен
содержать номер вектора в таблице. После
выполнения функции в регистрах ES:BX будет искомый
адрес обработчика прерывания. </p>

<p>Функция 25h прерывания 21h устанавливает для
вектора с номером, находящимся в AL, обработчик
прерывания DS:DX. </p>

<p>Разумеется, вы можете непосредственно
обращаться к таблице векторов прерываний, но
тогда при записи необходимо замаскировать
прерывания командой CLI, не забыв разрешить их
после записи командой STI. </p>

<p>Для пользователей языка Си библиотека Quick C
содержит функции _dos_getvec(), _dos_setvect(). Первая функция
получает адрес из таблицы векторов прерываний,
вторая устанавливает новый адрес. </p>

<p>Если вам надо добавить какие-либо собственные
действия к тем, что выполняет стандартный
обработчик прерывания, то можно организовать
цепочку прерываний. </p>

<p>Для организации цепочки прерываний вы
записываете в векторную таблицу адрес своего
обработчика, не забыв сохранить прежнее
содержимое таблицы. Ваш обработчик получает
управление по прерыванию, выполняет какие-либо
действия, затем передает управление
стандартному обработчику. Можно сделать и
по-другому: ваш обработчик вызывает стандартный
обработчик как подпрограмму, после возврата из
стандартного обработчика выполняет
дополнительные действия. То есть вы можете
вставить дополнительную обработку как до вызова
стандартного обработчика, так и после его вызова.
</p>

<p>В библиотеке Quick C имеется функция для
организации цепочки прерываний - _chain_intr(). </p>

<p>Рассмотрим более подробно возможности
библиотеки интегрированной среды Quick C,
предназначенные для работы с прерываниями. </p>

<p>Модификатор interrupt (_interrupt для Quick C 2.5 и C 6.0)
описывает функцию, которая является
обработчиком прерывания. Такая функция
завершается командой возврата из обработки
прерывания IRET, и для нее автоматически
генерируются команды сохранения регистров на
входе и их восстановления при выходе из
обработчика прерывания. Пример использования
модификатора для описания функции обработки
прерывания: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void interrupt far int_funct(void) {
        // Тело обработчика прерывания
}</font>
</pre>

<p>Функция обработки прерывания должна быть
FAR-функцией, т.к. таблица векторов прерываний
содержит полные адреса в виде сегмент:смещение. </p>

<p>Ключевое слово interrupt используется также для
описания переменных, предназначенных для
хранения векторов прерываний: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">void (_interrupt _far *oldvect)(void);</font>
</pre>

<p>Модификаторы _interrupt и _far для Quick C 2.5 и C 6.0
являются синонимами соответственно interrupt и far. </p>

<p>Какие требования предъявляются к программе
обработки прерывания? </p>

<p>Если прерывания происходят часто, то их
обработка может сильно замедлить работу
прикладной программы. Поэтому обработчик
прерывания должен быть короткой, быстро
работающей программой, которая выполняет только
самые необходимые действия. Например, считать
очередной символ из порта принтера и поместить
его в буфер, увеличить значение какого-либо
глобального счетчика прерываний и т.п. </p>

<p>Для установки своего обработчика прерываний
используйте функцию _dos_setvec. Эта функция имеет два
параметра - номер прерывания и указатель на новую
функцию обработки прерывания. Например: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">_dos_setvect(0x16, my_key_intr);</font>
</pre>

<p>В этом примере для клавиатурного прерывания с
номером 16h устанавливается новый обработчик
прерывания my_key_intr. </p>

<p>Если вам надо узнать адрес старого обработчика
прерывания по его номеру, лучше всего
воспользоваться функцией _dos_getvect, которая
принимает в качесте параметра номер прерывания и
возвращает указатель на соответствующий этому
номеру в таблице векторов прерываний обработчик.
Например: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">old_vector = _dos_getvect(0x16);</font>
</pre>

<p>Для организации цепочки прерываний
используйте функцию _chain_intr. В качестве параметра
эта функция принимает адрес старого обработчика
прерываний. </p>

<p>Следующий простой пример иллюстрирует
применение всех трех функций, предназначенных
для работы с прерываниями. Эта программа
встраивает собственный обработчик прерывания
таймера, который будет вызываться примерно 18,2
раза в секунду. Встраиваемый обработчик
прерывания считает тики таймера и, если значение
счетчика кратно 20, на динамик компьютера
выдается звуковой сигнал. В конце работы новая
программа обработки прерывания таймера вызывает
старый обработчик с помощью функции _chain_intr. </p>

<p>После установки нового обработчика прерывания
таймера основная программа ждет нажатия на
клавиатуре любой клавиши, затем она
восстанавливает старое содержимое вектора
прерывания. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;dos.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


// Выключаем проверку стека и указателей

#pragma check_stack( off )
#pragma check_pointer( off )

// Это макро используется для выдачи
//   сигнала на внутренний динамик
//   компьютера. Используется вывод
//   в формате TTY символа BELL (7)
//   через прерывание BIOS 10h

#define BEEP() _asm { \
                _asm mov bx,0      \
                _asm mov ax, 0E07h \
                _asm int 10h       \
                          }

void main(void);


// Объявление программы обработки прерывания

void _interrupt _far timer(void);

// Эта переменная предназначена для хранения
//   старого значения вектора прерывания
//   таймера. Она должна быть глобальной.

void (_interrupt _far *oldvect)(void);

// Переменная для подсчета тиков таймера

volatile long ticks;


void main(void) {

        ticks=0L;  // Сбрасываем счетчик тиков таймера

        oldvect = _dos_getvect(0x1c); // Запоминаем адрес
                                      // старого обработчика
                                      // прерывания

        _dos_setvect(0x1c, timer);    // Устанавливаем свой
                                      // обработчик

        printf(&quot;\nТаймер установлен. Нажмите любую&quot;
                        &quot;клавишу...\n&quot;);

        getch(); // Ожидаем нажатия на любую клавишу

        _dos_setvect(0x1c,oldvect);   // Восстанавливаем старый
                                      // обработчик прерывания
                                      // таймера
        exit(0);

}

// Функция обрабатывает прерывания таймера

void _interrupt _far timer(void) {

        ticks++; // Увеличиваем счетчик тиков таймера

        // Если значение счетчика тиков кратно 20,
        // выдаем сигнал на динамик компьютера
        if((ticks % 20) == 0) BEEP();

        // Вызываем старый обработчик прерывания
        _chain_intr(oldvect);

}</font>
</pre>

<h2><a NAME="ch4_5">4.5. Особенности обработки аппаратных
прерываний</a> </h2>

<p>Аппаратные прерывания вырабатываются
устройствами компьютера, когда возникает
необходимость их обслуживания. Например, по
прерыванию таймера соответствующий обработчик
прерывания увеличивает содержимое ячеек памяти,
используемых для хранения времени. В отличие от
программных прерываний, вызываемых
запланировано самой прикладной программой,
аппаратные прерывания всегда происходят
асинхронно по отношению к выполняющимся
программам. Кроме того, может возникнуть
одновременно сразу несколько прерываний! </p>

<p>Для того, чтобы система &quot;не растерялась&quot;,
решая какое прерывание обслуживать в первую
очередь, существует специальная схема
приоритетов. Каждому прерыванию назначается
свой уникальный приоритет. Если происходит
одновременно несколько прерываний, то система
отдает предпочтение самому высокоприоритетному,
откладывая на время обработку остальных
прерываний. </p>

<p>Система приоритетов реализована на двух
микросхемах Intel 8259 (для машин класса XT - на одной
такой микросхеме). Каждая микросхема обслуживает
до восьми приоритетов. Микросхемы можно
объединять (каскадировать) для увеличения
количества уровней приоритетов в системе. </p>

<p>Уровни приоритетов обозначаются сокращенно IRQ0
- IRQ15 (для машин класса XT существуют только уровни
IRQ0 - IRQ7). </p>

<p>Для машин XT приоритеты линейно зависели от
номера уровня прерывания. IRQ0 соответствовало
самому высокому приоритету, за ним шли IRQ1, IRQ2, IRQ3 и
так далее. Уровень IRQ2 в машинах класса XT был
зарезервирован для дальнейшего расширения
системы и, начиная с машин класса AT, IRQ2 стал
использоваться для каскадирования контроллеров
прерывания 8259. Добавленные приоритетные уровни
IRQ8 - IRQ15 в этих машинах располагаются по
приоритету между IRQ1 и IRQ3. </p>

<p>Приведем таблицу аппаратных прерываний,
расположенных в порядке приоритета: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="84">Номер</td>
    <td VALIGN="TOP" WIDTH="415">Описание </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">8</td>
    <td VALIGN="TOP" WIDTH="415">IRQ0 - прерывание интервального
    таймера, возникает 18,2 раза в секунду. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">9</td>
    <td VALIGN="TOP" WIDTH="415">IRQ1 - прерывание от клавиатуры.
    Генерируется при нажатии и при отжатии клавиши.
    Используется для чтения данных с клавиатуры. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">A</td>
    <td VALIGN="TOP" WIDTH="415">IRQ2 - используется для
    каскадирования аппаратных прерываний в машинах
    класса AT. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">70</td>
    <td VALIGN="TOP" WIDTH="415">IRQ8 - прерывание от часов
    реального времени. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">71</td>
    <td VALIGN="TOP" WIDTH="415">IRQ9 - прерывание от контроллера EGA. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">72</td>
    <td VALIGN="TOP" WIDTH="415">IRQ10 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">73</td>
    <td VALIGN="TOP" WIDTH="415">IRQ11 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">74</td>
    <td VALIGN="TOP" WIDTH="415">IRQ12 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">75</td>
    <td VALIGN="TOP" WIDTH="415">IRQ13 - прерывание от
    математического сопроцессора. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">76</td>
    <td VALIGN="TOP" WIDTH="415">IRQ14 - прерывание от контроллера
    жесткого диска. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">77</td>
    <td VALIGN="TOP" WIDTH="415">IRQ15 - зарезервировано. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">B</td>
    <td VALIGN="TOP" WIDTH="415">IRQ3 - прерывание асинхронного
    порта COM2. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">C</td>
    <td VALIGN="TOP" WIDTH="415">IRQ4 - прерывание асинхронного
    порта COM1. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">D</td>
    <td VALIGN="TOP" WIDTH="415">IRQ5 - прерывание от контроллера
    жесткого диска для XT. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">E</td>
    <td VALIGN="TOP" WIDTH="415">IRQ6 - прерывание генерируется
    контроллером флоппи-диска после завершения
    операции. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="84">F</td>
    <td VALIGN="TOP" WIDTH="415">IRQ7 - прерывание принтера.
    Генерируется принтером, когда он готов к
    выполнению очередной операции. Многие адаптеры
    принтера не используют это прерывание. </td>
  </tr>
</table>

<p>Из таблицы видно, что самый высокий приоритет у
прерываний от интервального таймера, затем идет
прерывание от клавиатуры. </p>

<p>Для управления схемами приоритетов необходимо
знать внутреннее устройство контроллера
прерываний 8259. Поступающие прерывания
запоминаются в регистре запроса на прерывание IRR.
Каждый бит из восьми в этом регистре
соответствует прерыванию. После проверки на
обработку в настоящий момент другого прерывания
запрашивается информация из регистра
обслуживания ISR. Перед выдачей запроса на
прерывание в процессор проверяется содержимое
восьмибитового регистра маски прерываний IMR.
Если прерывание данного уровня не замаскировано,
то выдается запрос на прерывание. </p>

<p>Наиболее интересными с точки зрения
программирования контроллера прерываний
являются регистры маски прерываний IMR и
управляющий регистр прерываний. </p>

<p>В машинах класса XT регистр маски прерываний
имеет адрес 21h, управляющий регистр прерываний -
20h. Для машин AT первый контроллер 8259 имеет такие
же адреса, что и в машинах XT, регистр маски
прерываний второго контроллера имеет адрес A1h,
управляющий регистр прерываний - A0h. </p>

<p>Разряды регистра маски прерываний
соответствуют номерам IRQ. Для того чтобы
замаскировать аппаратное прерывание какого-либо
уровня, надо заслать в регистр маски байт, в
котором бит, соответствующий этому уровню,
установлен в 1. Например, для маскирования
прерываний от НГМД в порт 21h надо заслать
двоичное число 01000000. </p>

<p>Приведем пример программы, маскирующей
прерывание от флоппи-диска: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

void main(void);

void main(void) {

        outp(0x21,0x40);
        printf(&quot;\nПрерывания от флоппи-диска запрещены.\n&quot;);

        exit(0);
}</font>
</pre>

<p>Эта программа есть на дискете, прилагающейся к
книге. Запустите ее (с жесткого диска) и
попробуйте поработать, например, с дисководом А:.
У вас ничего не получится! </p>

<p>Чтобы &quot;оживить&quot; флоппи-диски, запустите
программу, которая размаскирует все прерывания
(в том числе и от флоппи): </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;conio.h&gt;

void main(void);

void main(void) {

        outp(0x21,0);
        printf(&quot;\nПрерывания от флоппи-диска разрешены.\n&quot;);

        exit(0);
}</font>
</pre>

<p>Заметьте, что мы только что замаскировали
прерывание именно от флоппи-диска, все остальные
устройства продолжали нормально работать. Если
бы мы выдали машинную команду CLI, то отключились
бы все аппаратные прерывания. Это привело бы,
например, к тому, что клавиатура была бы
заблокирована. </p>

<p>Еще одно замечание, касающееся обработки
аппаратных прерываний. Если вы полностью
заменяете стандартный обработчик аппаратного
прерывания, не забудьте в конце программы выдать
байт 20h в порт с адресом 20h (A0h для второго
контроллера 8259). Эти действия необходимы для
очистки регистра обслуживания прерывания ISR. При
этом разрешается обработка прерываний с более
низким приоритетом чем то, которое только что
обрабатывалось. </p>

<p>Если вы обрабатываете прерывание 1Ch, то добавка
в конце программы не нужна, так как это
прерывание является расширением другого
прерывания (прерывания таймера). </p>

<p>Перед тем, как завершить изучение прерываний,
зададимся вопросом - можно ли замаскировать
немаскируемое прерывание? Оказывается можно! </p>

<p>Конечно, если сигнал прерывания пришел на вход
немаскируемого прерывания процессора, ничего
сделать нельзя - прерывание произойдет
неизбежно. Но в компьютерах XT и AT предусмотрены
схемы, блокирующие вход немаскируемого
прерывания процессора NMI. </p>

<p>Для XT маскированием немаскируемого прерывания
управляет порт с адресом 0A0h. Если записать в него
0, немаскируемое прерывание будет запрещено, если
80h - разрешено. </p>

<p>Аналогично для AT маскированием немаскируемого
прерывания управляет бит 7 порта 70h. Запись байта
0ADh в порт 70h запретит немаскируемое прерывание, а
байта 2Dh - разрешит прохождение прерывания. </p>

<p>Заметим, что мы не запрещаем немаскируемое
прерывание &quot;внутри&quot; процессора - это
невозможно по определению, мы &quot;не пускаем&quot;
сигнал прерывания на вход NMI. </p>
</body>
</html>
