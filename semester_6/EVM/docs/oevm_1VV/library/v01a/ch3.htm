<html>

<head>
<title>Управление программами</title>
</head>

<body BGCOLOR="#ffffff">

<h1>3. Управление программами</h1>

<ul>
  <li>3.1. <a HREF="ch3.htm#ch3_1">Форматы программных файлов</a> </li>
  <li>3.2. <a HREF="ch3.htm#ch3_2">Процесс загрузки программ в
    память</a> </li>
  <li>3.3. <a HREF="ch3.htm#ch3_3">Префикс программного сегмента</a>
  </li>
  <li>3.4. <a HREF="ch3.htm#ch3_4">Запуск программ из программ</a> </li>
  <li>3.5. <a HREF="ch3.htm#ch3_5">Завершение работы программ</a> </li>
</ul>

<h2><a NAME="ch3_1">3.1. Форматы программных файлов</a></h2>

<p>Теперь, когда мы знаем структуру памяти на
момент завершения загрузки операционной
системы, можно посмотреть, а что же происходит
дальше, когда оператор запускает какую-нибудь
программу. </p>

<p>Оператор может запустить два типа программ
(если не считать командных файлов, которые,
вообще говоря, не являются программами,
состоящими из машинных кодов) - программы,
имеющие расширение имени .COM и .EXE. Эти файлы имеют
различный формат и загружаются по-разному,
однако, когда загрузка завершена, в памяти
компьютера эти два типа программ выглядят
совершенно одинаково. </p>

<p>COM-файл - это двоичный образ Вашей программы,
состоящий из кода и данных. То есть это файл,
содержащий программу в &quot;чистом&quot; виде. Такая
программа (как и EXE-программа) может загружаться в
любое место памяти. DOS выполняет ее привязку к
физическим адресам при загрузке с помощью
установки сегментных регистров. Существенным
ограничением COM-программы является то, что она не
может занимать больше одного сегмента
(соответственно, файл .COM не может быть по длине
больше 64К). </p>

<p>Программа в формате EXE может иметь любой размер.
В самом начале файла программы содержится
заголовок (у COM-файла заголовка нет). Этот
заголовок используется операционной системой в
процессе загрузки программы в память для
правильной установки сегментных регистров.
Заголовок EXE-файла нужен только при загрузке;
когда программа загружена и готова к работе,
самого заголовка уже нет в памяти. </p>

<p>Заголовок EXE-файла состоит из форматированной
зоны и таблицы расположения сегментов (Relocation Table).
Форматированная зона выглядит следующим
образом: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="92"><font SIZE="2">(0) 2 </font></td>
    <td VALIGN="TOP" WIDTH="95">signature </td>
    <td VALIGN="TOP" WIDTH="313">два байта 'MZ' (4Dh, 5Ah),
    индентифицирующие файл в формате EXE </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+2) 2</td>
    <td VALIGN="TOP" WIDTH="95">part_pag </td>
    <td VALIGN="TOP" WIDTH="313">длина последней страницы
    программы в байтах (страница содержит 512 байт) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+4) 2</td>
    <td VALIGN="TOP" WIDTH="95">file_size </td>
    <td VALIGN="TOP" WIDTH="313">размер программы в страницах по
    512 байт </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+6) 2</td>
    <td VALIGN="TOP" WIDTH="95">rel_item </td>
    <td VALIGN="TOP" WIDTH="313">число элементов в таблице
    расположения сегментов </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+8) 2</td>
    <td VALIGN="TOP" WIDTH="95">hdr_size </td>
    <td VALIGN="TOP" WIDTH="313">размер заголовка файла в
    параграфах (длина параграфа - 16 байт) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+10) 2</td>
    <td VALIGN="TOP" WIDTH="95">min_mem </td>
    <td VALIGN="TOP" WIDTH="313">минимальное количество памяти в
    параграфах, которое нужно зарезервировать в
    памяти за концом загруженной программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+12) 2</td>
    <td VALIGN="TOP" WIDTH="95">max_mem </td>
    <td VALIGN="TOP" WIDTH="313">максимальное количество памяти в
    параграфах, которое нужно зарезервировать в
    памяти за концом загруженной программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+14) 2</td>
    <td VALIGN="TOP" WIDTH="95">ss_reg </td>
    <td VALIGN="TOP" WIDTH="313">величина смещения от начала
    программы, которая используется для загрузки
    сегментного регистра стека SS </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+16) 2</td>
    <td VALIGN="TOP" WIDTH="95">sp_reg </td>
    <td VALIGN="TOP" WIDTH="313">величина смещения от начала
    программы, которая используется для загрузки
    регистра SP </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+18) 2</td>
    <td VALIGN="TOP" WIDTH="95">chk_summ </td>
    <td VALIGN="TOP" WIDTH="313">контрольная сумма всех слов в
    файле </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+20) 2</td>
    <td VALIGN="TOP" WIDTH="95">ip_reg </td>
    <td VALIGN="TOP" WIDTH="313">значение для регистра IP, которое
    будет использовано при начальном запуске
    программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+22) 2</td>
    <td VALIGN="TOP" WIDTH="95">cs_reg </td>
    <td VALIGN="TOP" WIDTH="313">смещение от начала программы для
    установки сегментного регистра кода CS </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+24) 2</td>
    <td VALIGN="TOP" WIDTH="95">relt_off </td>
    <td VALIGN="TOP" WIDTH="313">смещение от начала файла таблицы
    расположения сегментов программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="92">(+26) 2</td>
    <td VALIGN="TOP" WIDTH="95">overlay </td>
    <td VALIGN="TOP" WIDTH="313">номер оверлея, равен 0 для
    основного модуля </td>
  </tr>
</table>

<p>Таблица расположения сегментов программы
начинается сразу после форматированной области
и состоит из четырехбайтовых значений в формате
&quot;смещение:сегмент&quot;. </p>

<p>Область файла после таблицы расположения
сегментов выравнивается на границу параграфа с
помощью байта-заполнителя, и дальше начинается
сама программа. </p>

<p>В файле sysp.h есть описание заголовка файла и
таблицы расположения сегментов, которые вы
можете использовать при обработке заголовка
EXE-файла: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">typedef struct _EXE_HDR_ {
        unsigned signature;
        unsigned part_pag;
        unsigned file_size;
        unsigned rel_item;
        unsigned hdr_size;
        unsigned min_mem;
        unsigned max_mem;
        unsigned ss_reg;
        unsigned sp_reg;
        unsigned chk_summ;
        unsigned ip_reg;
        unsigned cs_reg;
        unsigned relt_off;
        unsigned overlay;
} EXE_HDR;

typedef struct _RELOC_TAB_ {
        unsigned offset;
        unsigned segment;
} RELOC_TAB;</font>
</pre>

<p>В качестве примера приведем программу, которая
считывает форматированную часть заголовка
EXE-файла, проверяет наличие в его первых двух
байтах признака EXE-формата ('MZ'). Если признак
имеется, программа выводит на экран
расшифрованное содержимое заголовка и таблицу
перемещений, если такая таблица присутствует. В
качестве параметра программе надо при запуске
передать имя исследуемого EXE-файла. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;sysp.h&quot;

void main(int, char *[]);

void main(int argc, char *argv[]) {

        printf(&quot;Распечатка заголовка EXE-файла\n&quot;
                  &quot;Copyright (C)Frolov A., 1990\n\n&quot;);

        if( argc != 2 ) {
           printf( &quot;  Задайте путь EXE-файла в качестве&quot;
                      &quot;параметра\n&quot; );
           exit(0);
        }

        if( gethdr( argv[1]) != 0) {
                printf( &quot;Ошибка в формате файла или нет такого&quot;
                           &quot;файла\n&quot; );
                exit(0);
        }
        exit(0);
}

int gethdr( char *path) {

        EXE_HDR     header;
        RELOC_TAB   *reloc;
        FILE        *inpfile;
        int         i;

        if((inpfile = fopen(path,&quot;rb&quot;)) == 0) return(-1);

        if(get_exeh(&amp;header,&amp;reloc,inpfile) != 0) {
                fclose(inpfile);
                return(-1);
        }
        printf(&quot;Магическое число:                   %04X\n&quot;
          &quot;Длина последней страницы файла:      %d\n&quot;
          &quot;Количество страниц в файле:          %d\n&quot;
          &quot;Кол. элементов табл. перемещений:    %d\n&quot;
          &quot;Размер заголовка в параграфах:       %d\n&quot;
          &quot;Минимальная память для программы:    %04X\n&quot;
          &quot;Максимальная память для программы:   %04X\n&quot;
          &quot;Значение адреса стека SS:SP:         04X:%04X\n&quot;
          &quot;Контрольная сумма:                   %04X\n&quot;
          &quot;Значения для регистров CS:IP:        %04X:%04X\n&quot;
          &quot;Смещение табл. перемещений:          %02X\n&quot;
          &quot;Номер оверлея:                       %d\n&quot;,
                         header.signature,
                         header.part_pag,
                         header.file_size,
                         header.rel_item,
                         header.hdr_size,
                         header.min_mem,
                         header.max_mem,
                         header.ss_reg,
                         header.sp_reg,
                         header.chk_summ,
                         header.cs_reg,
                         header.ip_reg,
                         header.relt_off,
                         header.overlay);

        if(reloc != 0) {
                printf(&quot;\nСодержимое таблицы перемещений:\n\n&quot;);

                for(i=0;i &lt; header.rel_item; i++) {
                        printf(&quot;%04X:%04X\n&quot;,
                        (reloc+i)-&gt;segment,
                        (reloc+i)-&gt;offset);

                }
                free(reloc);
        }
        fclose(inpfile);
        return(0);
}</font>
</pre>

<p>Приведенная выше программа для чтения
заголовка EXE-файла пользуется функцией get-exeh: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">/**
*.Name      get_exeh
*
*.Title     Прочитать заголовок EXE-файла
*
*.Descr     Функция читает заголовок EXE-файла в
*           структуру типа EXE_HDR, заказывает память
*           для таблицы размещений сегментов и считывает
*           таблицу в эту область. Адрес заказанной области
*           помещается по адресу, передаваемому в rtb.
*           Если таблица размещений отсутствует, память для
*           нее не заказывается.
*
*.Params    int get_exeh(EXE_HDR *exeh,RELOC_TAB **rtb,
*                                       FILE *exe_file)
*
*              exeh -  указатель на структуру, которая
*                      должна быть заполнена информацией
*                      из заголовка EXE-файла
*
*              rtb  -  указатель на указатель на таблицу
*                      размещений сегментов программы
*
*              exe_file - указатель на открытый EXE-файл
*                      (до вызова функции нельзя обращаться
*                      к этому файлу, т.к. считается, что
*                      указатель текущего смещения
*                                  установлен на начало файла)
*
*.Return    0 при успешном считывании заголовка;
*           -1 в случае неправильного формата заголовка
**/

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &quot;sysp.h&quot;

int get_exeh(EXE_HDR *exeh,RELOC_TAB **rtb,FILE *exe_file) {

        int i,j,k;

        // считываем форматированную часть заголовка

        for(i=0; i &lt; sizeof(EXE_HDR); i++) {
                *(((char*)exeh) + i) = fgetc(exe_file);
                if(feof(exe_file)) break;
        }

        // это EXE-файл?

     if(exeh-&gt;signature != 0x5a4d) return(-1);

        if((i=exeh-&gt;rel_item) != 0) {

// если есть таблица перемещений, заказываем для нее память

                *rtb = (RELOC_TAB*)malloc(i*sizeof(RELOC_TAB)+16);

                // считываем таблицу перемещений

                for(k=0; k&lt;i; k++) {
                        for(j=0;j &lt; sizeof(RELOC_TAB);j++) {

                                *((char*)(*rtb)+j+k*sizeof(RELOC_TAB))=
                                        fgetc(exe_file);

                                if(feof(exe_file)) break;
                        }
                }
        }
        else *rtb = (RELOC_TAB *)0;

        return(0);}</font>
</pre>

<h2><a NAME="ch3_2">3.2. Процесс загрузки программ в память</a>
</h2>

<p>Загрузка COM- и EXE-программ происходит по-разному,
однако есть некоторые действия, которые
операционная система выполняет в обоих случаях
одинаково. 

<ul>
  <li>Определяется наименьший сегментный адрес
    свободного участка памяти для загрузки
    программы (обычно DOS загружает программу в
    младшие адреса памяти, если при редактировании
    не указана загрузка в старшие адреса). </li>
  <li>Создаются два блока памяти (и, следовательно,
    два блока MCB, описанные ранее) - блок памяти для
    переменных среды и блок памяти для PSP и программы.
  </li>
  <li>Для DOS версии 3.х и старше в блок памяти
    переменных среды помещается путь файла
    программы. </li>
  <li>Заполняются поля префикса сегмента программы PSP
    в соответствии с характеристиками программы
    (количество памяти, доступное программе, адрес
    сегмента блока памяти, содержащего переменные
    среды и т.д.) </li>
  <li>Устанавливается адрес области Disk Transfer Area (DTA) на
    вторую половину PSP (PSP:0080). </li>
  <li>Анализируются параметры запуска программы на
    предмет наличия в первых двух параметрах
    идентификаторов дисковых устройств. По
    результатам анализа устанавливается содержимое
    регистра AX при входе в программу. Если первый или
    второй параметры не содержат правильного
    идентификатора дискового устройства, то
    соответственно в регистры AL и AH записывается
    значение FF. </li>
</ul>

<p>А дальше действия системы по загрузке программ
форматов COM и EXE будут различаться. </p>

<p>Для COM-программ, которые представляют собой
двоичный образ односегментной программы,
выполняется чтение файла программы с диска и
запись его в память по адресу PSP:0100. Вообще говоря,
программы типа COM могут состоять из нескольких
сегментов, но в этом случае они должны сами
управлять содержимым сегментных регистров,
используя в качестве базового адреса адрес PSP. </p>

<p>После загрузки файла операционная система для
COM-программ выполняет следующие действия: 

<ul>
  <li>сегментные регистры CS, DS, ES, SS устанавливаются на
    начало PSP; </li>
  <li>регистр SP устанавливается на конец сегмента PSP; </li>
  <li>вся область памяти после PSP распределяется
    программе; </li>
  <li>в стек записывается слово 0000; </li>
</ul>

<p>указатель команд IP устанавливается на 100h
(начало программы) с помощью команды JMP по адресу
PSP:100. </p>

<p>Загрузка EXE-программ происходит значительно
сложнее, так как связана с настройкой сегментных
адресов: 

<ul>
  <li>Считывается во внутренний буфер DOS
    форматированная часть заголовка файла. </li>
  <li>Определяется размер загрузочного модуля по
    формуле: </li>
</ul>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">size=((file_size*512)-(hdr_size*16)-part_pag</font>
</pre>

<ul>
  <li>Определяется смещение начала загрузочного
    модуля в EXE-файле как hdr_size*16. </li>
  <li>Вычисляется сегментный адрес для загрузки
    START_SEG, обычно используется значение PSP+10h. </li>
  <li>Загрузочный модуль считывается в память по
    адресу START_SEG:0000. </li>
  <li>Сканируются элементы таблицы перемещений,
    располагающейся в EXE-файле со смещением relt_off. </li>
  <li>Для каждого элемента таблицы: </li>
</ul>

<p>1. Считывается содержимое элемента таблицы как
два двухбайтных слова (OFF,SEG). </p>

<p>2. Вычисляется сегментный адрес ссылки
перемещения </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">REL_SEG = (START_SEG + SEG)</font>
</pre>

<p>3. Выбирается слово по адресу REL_SEG:OFF, к этому
слову прибавляется значение START_SEG, затем сумма
записывается обратно по тому же адресу. 

<ul>
  <li>Заказывается память для программы, исходя из
    значений min_mem и max_mem. </li>
  <li>Инициализируются регистры, и программа
    запускается на выполнение. </li>
</ul>

<p>При инициализации регистры ES и DS
устанавливаются на PSP, регистр AX устанавливается
так же, как и для COM-программ, в сегментный регистр
стека SS записывается значение START_SEG + ss_reg, а в SP
записывается sp_reg. </p>

<p>Для запуска программы в CS записывается
START_SEG+cs_reg, а в IP - ip_reg. Такая запись невозможна
напрямую, поэтому операционная система сначала
записывает в свой стек значение для CS, затем
значение для IP и после этого выполняет команду
дальнего возврата RETF (команда возврата из
дальней процедуры). </p>

<h2><a NAME="ch3_3">3.3. Префикс программного сегмента</a></h2>

<p>Теперь займемся вплотную префиксом
программного сегмента PSP. Формат PSP уже был описан
ранее, для удобства приведем его еще раз вместе
со структурой из файла sysp.h: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="114"><font SIZE="2">(0) 2 </font></td>
    <td VALIGN="TOP" WIDTH="130">int&nbsp;20h </td>
    <td VALIGN="TOP" WIDTH="334">двоичный код команды int&nbsp;20h
    (программы могут использовать эту команду для
    завершения своей работы) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+2) 2</td>
    <td VALIGN="TOP" WIDTH="130">mem_top </td>
    <td VALIGN="TOP" WIDTH="334">нижняя граница доступной памяти
    в системе в параграфах </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+4) 1</td>
    <td VALIGN="TOP" WIDTH="130">reserv1 </td>
    <td VALIGN="TOP" WIDTH="334">зарезервировано</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+5) 5</td>
    <td VALIGN="TOP" WIDTH="130">call_dsp </td>
    <td VALIGN="TOP" WIDTH="334">команда вызова FAR&nbsp;CALL
    диспетчера MS-DOS </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+10) 4</td>
    <td VALIGN="TOP" WIDTH="130">term_adr </td>
    <td VALIGN="TOP" WIDTH="334">адрес завершения (Terminate Address) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+14) 4</td>
    <td VALIGN="TOP" WIDTH="130">cbrk_adr </td>
    <td VALIGN="TOP" WIDTH="334">адрес обработчика Ctrl-Break</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+18) 4</td>
    <td VALIGN="TOP" WIDTH="130">crit_err </td>
    <td VALIGN="TOP" WIDTH="334">адрес обработчика критической
    ошибки </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+22) 2</td>
    <td VALIGN="TOP" WIDTH="130">parn_psp </td>
    <td VALIGN="TOP" WIDTH="334">сегмент PSP программы, запустившей
    данную программу (программы-родителя) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+24) 20</td>
    <td VALIGN="TOP" WIDTH="130">file_tab </td>
    <td VALIGN="TOP" WIDTH="334">таблица открытых файлов, если
    здесь находятся байты 0FFH, то таблица не
    используется </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+44) 2</td>
    <td VALIGN="TOP" WIDTH="130">env_seg </td>
    <td VALIGN="TOP" WIDTH="334">сегмент блока памяти,
    содержащего переменные среды </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+46) 4</td>
    <td VALIGN="TOP" WIDTH="130">ss_sp </td>
    <td VALIGN="TOP" WIDTH="334">адрес стека SS:SP программы</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+50) 2</td>
    <td VALIGN="TOP" WIDTH="130">max_open </td>
    <td VALIGN="TOP" WIDTH="334">максимальное число открытых
    файлов </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+52) 4</td>
    <td VALIGN="TOP" WIDTH="130">file_tba </td>
    <td VALIGN="TOP" WIDTH="334">адрес таблицы открытых файлов </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+56) 24</td>
    <td VALIGN="TOP" WIDTH="130">reserv2 </td>
    <td VALIGN="TOP" WIDTH="334">зарезервировано</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+80) 3</td>
    <td VALIGN="TOP" WIDTH="130">disp </td>
    <td VALIGN="TOP" WIDTH="334">диспетчер функций DOS</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+83) 9</td>
    <td VALIGN="TOP" WIDTH="130">reserv3 </td>
    <td VALIGN="TOP" WIDTH="334">зарезервировано</td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+92) 16</td>
    <td VALIGN="TOP" WIDTH="130">fcb1 </td>
    <td VALIGN="TOP" WIDTH="334">форматируется как стандартный FCB,
    если первый аргумент командной строки содержит
    правильное имя файла </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+108) 20</td>
    <td VALIGN="TOP" WIDTH="130">fcb2 </td>
    <td VALIGN="TOP" WIDTH="334">заполняется для второго
    аргумента командной строки аналогично fcb1 </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+128) 1</td>
    <td VALIGN="TOP" WIDTH="130">p_size </td>
    <td VALIGN="TOP" WIDTH="334">число значащих символов в
    неформатированной области параметров, либо
    буфер обмена с диском DTA, назначенный по
    умолчанию </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="114">(+129) 127 </td>
    <td VALIGN="TOP" WIDTH="130">parm </td>
    <td VALIGN="TOP" WIDTH="334">неформатированная область
    параметров, заполняется при запуске программы из
    командной строки </td>
  </tr>
</table>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#pragma pack(1)

typedef struct _PSP_ {
        unsigned char int20h[2];
        unsigned mem_top;
        unsigned char reserv1;
        unsigned char call_dsp[5];
        void far *term_adr;
        void far *cbrk_adr;
        void far *crit_err;
        unsigned parn_psp;
        unsigned char file_tab[20];
        unsigned env_seg;
        void far *ss_sp;
        unsigned max_open;
        void far *file_tba;
        unsigned char reserv2[24];
        unsigned char disp[3];
        unsigned char reserv3[9];
        unsigned char fcb1[16];
        unsigned char fcb2[20];
        unsigned char p_size;
        unsigned char parm[127];
} PSP;

#pragma pack()</font>
</pre>

<p>Программы могут получить из PSP такую
информацию, как параметры командной строки при
запуске, размер доступной памяти, найти сегмент
области переменных среды и т.д. </p>

<p>Как программе узнать адрес своего PSP? Очень
просто сделать это для программ, написанных на
языке ассемблера: при запуске программы этот
адрес передается ей через регистры DS и ES. То есть
этот адрес равен DS:0000 или ES:0000 (для COM-программ на
PSP указывают также регистры CS и SS). </p>

<p>Для программ, составленных на языке Си,
доступна глобальная переменная _psp типа unsigned. Эта
переменная содержит сегментный адрес PSP. </p>

<p>В качестве примера приведем текст программы на
языке ассемблера, которая выводит на экран
передаваемые ей через PSP параметры запуска: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                  .MODEL  tiny
                  DOSSEG

                  .STACK  100h

                  .DATA

parm_msg  DB &quot;Укажите параметры&quot;, 13, 10, &quot;$&quot;

                  .CODE
                  .STARTUP

                  mov    cl,ds:80h     ; количество символов
                                       ;   в командной строке
                  cmp    cl,0
                  je     ask_parm      ; нет параметров - просим
                                       ;   задать параметры

                  mov    si,81h        ; со смещением 81h
                                       ;   начинается область
                                       ;   параметров
                  cld

get_parm:

                  lods   BYTE PTR es:[si]  ; загружаем в al
                                           ;   очередной
                                           ;   символ строки
                                           ;   параметров

                  mov    ah,2              ; выводим его на экран
                  mov    dl,al
                  int    21h

                  loop get_parm
                  jmp  end_progr

ask_parm:

                  mov     ah, 9h
                  mov     dx, OFFSET parm_msg
                  int     21h

end_progr:
                  .EXIT   0

                  END</font>
</pre>

<p>Приведенная ниже программа, составленная на
языке Си, определяет адрес своего PSP, затем
показывает содержимое некоторых полей из PSP: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dos.h&gt;
#include &quot;sysp.h&quot;

void main(void);

void main(void) {

  PSP far *psp_ptr;


  psp_ptr = FP_MAKE(_psp,0);  // Конструируем указатель
                                                //  на PSP
  printf(&quot;PSP расположено по адресу:    %Fp\n&quot;
                        &quot;Доступно памяти, байт:       %ld\n&quot;
                        &quot;PSP родительской программы:  %Fp\n&quot;
                        &quot;\n&quot;,
                        psp_ptr,
                        (long)(psp_ptr-&gt;mem_top)*16L,
                        FP_MAKE(psp_ptr-&gt;parn_psp,0));
  exit(0);
}</font>
</pre>

<p>Используя поле parn_psp, можно определить адрес PSP
родительской программы, то есть программы,
запустившей Вашу программу. </p>

<p>Немного о назначении полей term_adr, cbrk_adr, crit_err. </p>

<p>Поле term_adr содержит значение, полученное из
таблицы векторов прерываний для вектора 22h. Это
адрес программы, которая получает управление,
когда текущая программа завершает свою работу.
Это может быть, например, COMMAND.COM. Программа может
создать свою собственную подпрограмму, которая
будет получать управление при завершении работы
основной программы. Она может записать свой
собственный адрес в вектор 22h, затем запустить
другую программу. В таком случае в запущенной
программе это поле в ее PSP будет содержать адрес
родительской программы. Когда основная
программа завершает свою работу, DOS
восстанавливает адрес программы завершения в
векторе 22h из поля term_adr PSP. </p>

<p>Поле cbrk_adr содержит адрес программы обработки
прерывания по нажатию Ctrl-Break из вектора 23h таблицы
векторов прерываний. Так как программа может
устанавливать свою собственную программу
обработки прерывания по Ctrl-Break, DOS при завершении
работы программы восстанавливает оригинальное
значение из поля cbrk_adr. </p>

<p>Аналогично поле crit_err предназначено для
восстановления содержимого вектора 24h - адреса
обработчика критических ошибок. </p>

<p>Способы переназначения векторов будут
приведены в разделе, посвященном прерываниям. </p>

<p>Конечно, программы, составленные на языке Си, не
обязательно должны использовать PSP для доступа к
параметрам командной строки и переменным среды.
Для этого есть параметры функции main и набор
функций типа getenv, putenv и т.п., предназначенных для
работы со средой. Но ведь PSP содержит и другую
информацию! </p>

<h2><a NAME="ch3_4">3.4. Запуск программ из программ</a></h2>

<p>Ваша программа может при необходимости
запустить другую программу формата EXE или COM. Для
ассемблерных программ существует функция 4Bh
прерывания INT&nbsp;21h, для программ, составленных на
языке Си - разнообразные функции, входящие в
состав стандартной библиотеки. Сначала
рассмотрим запуск программ при помощи функции 4Bh
прерывания INT&nbsp;21h. </p>

<p>Содержимое регистров перед вызовом прерывания:
</p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">AH = 4BH
AL - код подфункции (0, 1, 2, 3)
DS:DX - указатель на путь к запускаемой программе
ES:BX - указатель на блок параметров EPB</font>
</pre>

<p>После возврата из прерывания флаг CF
устанавливается в 0, если ошибок не было, и в 1 при
обнаружении ошибок. Регистр AX в случае наличия
ошибок содержит код ошибки: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48"><font SIZE="2">1</font></td>
    <td WIDTH="367">неверный код подфункции; </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="367">файл запускаемой программы не найден; </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="367">путь не найден;</td>
  </tr>
  <tr>
    <td WIDTH="48">4</td>
    <td WIDTH="367">слишком много открытых файлов; </td>
  </tr>
  <tr>
    <td WIDTH="48">5</td>
    <td WIDTH="367">нет доступа;</td>
  </tr>
  <tr>
    <td WIDTH="48">8</td>
    <td WIDTH="367">нет памяти для загрузки программы; </td>
  </tr>
  <tr>
    <td WIDTH="48">10</td>
    <td WIDTH="367">длина блока среды больше 32 килобайт; </td>
  </tr>
  <tr>
    <td WIDTH="48">11</td>
    <td WIDTH="367">плохой формат запускаемого EXE-файла. </td>
  </tr>
</table>

<p>Функция 4Bh прерывания 21h имеет четыре
подфункции с номерами от 0 до 3: </p>

<table BORDER="1">
  <tr>
    <td WIDTH="48">0</td>
    <td WIDTH="367">загрузить и выполнить программу; </td>
  </tr>
  <tr>
    <td WIDTH="48">1</td>
    <td WIDTH="367">загрузить, но не выполнять программу
    (внутренняя подфункция для DOS 3.х); </td>
  </tr>
  <tr>
    <td WIDTH="48">2</td>
    <td WIDTH="367">загрузить, но не выполнять программу
    (внутренняя подфункция для DOS 2.х); </td>
  </tr>
  <tr>
    <td WIDTH="48">3</td>
    <td WIDTH="367">загрузить программу как оверлей (не
    создавать PSP). </td>
  </tr>
</table>

<p>Для функции 0 регистры DS:DX должны указывать на
полный путь запускаемой программы в формате ASCIIZ (
т.е. текстовая строка, закрытая двоичным нулем).
Блок параметров EPB (Exec Parameter Block) в этом случае
имеет следующий формат: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="79">(0) 2</td>
    <td VALIGN="TOP" WIDTH="91">seg_env </td>
    <td VALIGN="TOP" WIDTH="315">сегментный адрес среды, которая
    создается родительской программой для
    запускаемой программы. Если в этом поле
    находится 0, то для запускаемой программы
    копируется среда родительской программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="79">(+2) 4</td>
    <td VALIGN="TOP" WIDTH="91">cmd </td>
    <td VALIGN="TOP" WIDTH="315">FAR-адрес строки параметров для
    запускаемой программы. Эта строка должна иметь
    такой же формат, как и в PSP, т.е. вначале идет байт
    со значением, равным количеству символов в
    строке параметров, а затем - сама строка
    параметров </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="79">(+6) 4</td>
    <td VALIGN="TOP" WIDTH="91">fcb1 </td>
    <td VALIGN="TOP" WIDTH="315">адрес блока FCB, который будет
    помещен в PSP со смещением 5Ch (в PSP помещается блок,
    а не адрес!) </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="79">(+10) 4</td>
    <td VALIGN="TOP" WIDTH="91">fcb2 </td>
    <td VALIGN="TOP" WIDTH="315">адрес блока FCB, который будет
    помещен в PSP со смещением 6Ch. </td>
  </tr>
</table>

<p>Запущенной программе доступны все файлы,
открытые родительской программой. </p>

<p>Если родительская программа сама формирует
среду для дочерней программы, она должна
подготовить новую среду на границе параграфа и
поместить значение сегментного адреса в поле
seg_env блока EPB. </p>

<p>Приведем простую программу, которая запускает
программу с именем PARM.COM из текущего каталога.
Программу PARM.COM мы только что рассматривали, эта
программа выводит на экран полученные ей в
командной строке параметры. </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                  .MODEL  small
                  DOSSEG

                  .STACK  100h

                  .DATA

path         db &quot;PARM.COM&quot;,0
command_line db 8,&quot;Parm Str&quot;

epb      dw 0
cmd_off  dw ?
cmd_seg  dw ?
fcb1     dd ?
fcb2     dd ?

                  .CODE
                  .STARTUP

                  mov     bx,OFFSET command_line ; адрес командной
                  mov     cmd_off,bx       ; строки для блока EPB
                  mov     cmd_seg,ds

                  mov     ax,ds
                  mov     es,ax

                  mov     bx,OFFSET epb  ; ES:BX указывают на EPB
                  mov     dx,OFFSET path ; DS:DX указывают на путь
                                         ; запускаемой программы

                  mov     ax, 4B00h ; AH = 4Bh
                                             ; AL = 0 загрузить и выполнить
                  int     21h

                  .EXIT   0

                  END</font>
</pre>

<p>Эта программа использует модель памяти SMALL, и ее
загрузочный модуль имеет формат EXE. При
редактировании был указан стандартный для Quick C
2.01 размер памяти, требуемый для программы. Если
попытаться использовать формат COM в модели TINY, то
окажется, что вся память распределена
COM-программе и для дочерней программы не осталось
места. </p>

<p>Следующая программа освобождает всю
неиспользуемую ей память, после чего на
освободившееся место загружает программу PARM.COM: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                  .MODEL  tiny
                  DOSSEG

                  .STACK  100h

                  .DATA

path         db &quot;PARM.COM&quot;,0
command_line db 8,&quot;Parm Str&quot;

epb      dw 0
cmd_off  dw ?
cmd_seg  dw ?
fcb1     dd ?
fcb2     dd ?

                  .CODE
                  .STARTUP
;
; Освобождаем лишнюю память за концом программы
;
                  mov     bx,OFFSET last ; смещение конца
                                         ; программы

                  mov     cl,4           ; вычисляем длину в
                                         ; параграфах
                  shr     bx,cl

                  add     bx,17        ; добавляем 1 параграф для
                                       ; выравнивания и 256 байт
                                       ; для стека

                  mov     ah, 4Ah    ; изменяем размер выделенного
                  int     21h        ; блока памяти

                  mov     ax,bx      ; установка нового значения
                  shl     ax,cl      ;  указателя стека
                  dec     ax
                  mov     sp,ax

                  mov     bx,OFFSET command_line ; адрес командной
                  mov     cmd_off,bx             ; строки для
              </font><font
COLOR="#000080" FACE="Courier New"> </font><font COLOR="#000080" FACE="Courier New Cyr">                                  ; блока EPB
                  mov     cmd_seg,ds

                  mov     ax,ds
                  mov     es,ax

                  mov     bx,OFFSET epb  ; ES:BX указывают на EPB
                  mov     dx,OFFSET path ; DS:DX указывают на путь
</font><font
COLOR="#000080" FACE="Courier New"> </font><font COLOR="#000080" FACE="Courier New Cyr">                                        ; запускаемой программы

                  mov     ax, 4B00h      ; AH = 4Bh
                                         ; AL = 0 загрузить и
                                         ; выполнить
                  int     21h

                  .EXIT   0
last:   db ?
                  END</font>
</pre>

<p>Для изменения размера выделенного программе
блока памяти мы использовали функцию 4Ah
прерывания 21h. </p>

<p>Подфункции 1 и 2 прерывания 4Bh используются DOS
(это внутренние подфункции DOS). Мы приведем
недокументированный формат блока EBP для этих
функций. </p>

<p>Для подфункнкции 1: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="76"><font SIZE="2">(0) 2</font></td>
    <td VALIGN="TOP" WIDTH="90">seg_env </td>
    <td VALIGN="TOP" WIDTH="311">сегментный адрес среды, которая
    создается родительской программой для
    запускаемой программы. Если в этом поле
    находится 0, то для запускаемой программы
    копируется среда родительской программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="76">(+2) 4</td>
    <td VALIGN="TOP" WIDTH="90">cmd </td>
    <td VALIGN="TOP" WIDTH="311">FAR-адрес строки параметров для
    запускаемой программы. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="76">(+6) 4</td>
    <td VALIGN="TOP" WIDTH="90">fcb1 </td>
    <td VALIGN="TOP" WIDTH="311">адрес блока FCB, который будет
    помещен в PSP со смещением 5Ch </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="76">(+10) 4</td>
    <td VALIGN="TOP" WIDTH="90">fcb2 </td>
    <td VALIGN="TOP" WIDTH="311">адрес блока FCB, который будет
    помещен в PSP со смещением 6Ch. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="76">(+14) 4</td>
    <td VALIGN="TOP" WIDTH="90">ss_sp </td>
    <td VALIGN="TOP" WIDTH="311">это поле будет содержать
    значение SS:SP после возврата </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="76">(+18) 4</td>
    <td VALIGN="TOP" WIDTH="90">entry_p </td>
    <td VALIGN="TOP" WIDTH="311">адрес точки входа в загруженную
    программу (CS:IP) </td>
  </tr>
</table>

<p>Для подфункции 2: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="75">(0) 2</td>
    <td VALIGN="TOP" WIDTH="92">seg_env </td>
    <td VALIGN="TOP" WIDTH="315">сегментный адрес среды, которая
    создается родительской программой для
    запускаемой программы. Если в этом поле
    находится 0, то для запускаемой программы
    копируется среда родительской программы </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="75">(+2) 4</td>
    <td VALIGN="TOP" WIDTH="92">cmd </td>
    <td VALIGN="TOP" WIDTH="315">FAR-адрес строки параметров для
    запускаемой программы. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="75">(+6) 4</td>
    <td VALIGN="TOP" WIDTH="92">fcb1 </td>
    <td VALIGN="TOP" WIDTH="315">адрес блока FCB, который будет
    помещен в PSP со смещением 5Ch </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="75">(+10) 4</td>
    <td VALIGN="TOP" WIDTH="92">fcb2 </td>
    <td VALIGN="TOP" WIDTH="315">адрес блока FCB, который будет
    помещен в PSP со смещением 6Ch. </td>
  </tr>
</table>

<p>Подфункция 3 используется для загрузки
программных оверлеев. Оверлей загружается в
адресное пространство родительской программы,
поэтому DOS не заказывает дополнительной памяти и
не строит PSP. Формат EPB для этой подфункции: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="77">(0) 2</td>
    <td VALIGN="TOP" WIDTH="92">seg_env </td>
    <td VALIGN="TOP" WIDTH="315">сегментный адрес, по которому
    загружается программа </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="77">(+2) 4</td>
    <td VALIGN="TOP" WIDTH="92">reloc </td>
    <td VALIGN="TOP" WIDTH="315">фактор перемещения, аналогичен
    элементу таблицы перемещений в заголовке
    EXE-файла </td>
  </tr>
</table>

<p>Следующая демонстрационная программа
загружает программу PARM.COM_как оверлей без
передачи ей управления: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">                  .MODEL  small
                  DOSSEG

                  .STACK  100h

          .DATA

path    db &quot;PARM.COM&quot;,0

epb     dw 0
reloc   dd 0

          .CODE
          .STARTUP


          mov     ax,ds
          mov     es,ax

          mov     bx,SEG buff
          mov     epb,bx

          mov     bx,OFFSET epb  ; ES:BX указывают на EPB
          mov     dx,OFFSET path ; DS:DX указывают на путь
                                 ; загружаемой программы

          mov     ax, 4B03h ; AH = 4Bh
                            ; AL = 0 загрузить оверлей
          int     21h

          .EXIT   0

buff:   dd 100 dup(?)

          END</font>
</pre>

<p>Программа загружается в буфер buff. </p>

<p>Пользователи языка Си имеют в своем
распоряжении три возможности запустить
программу. </p>

<p>Самый простой способ - использовать функцию
system(). Эта функция может выполнить любую команду
DOS или любую программу, пакетный файл. Например: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">system(&quot;FORMAT A:&quot;);</font>
</pre>

<p>При использовании этой функции должен быть
доступен COMMAND.COM. К сожалению, хотя system и
возвращает код завершения, по нему нельзя
сделать вывод о том, как была выполнена
запускаемая программа. Если в качестве аргумента
функции будет передано неправильное имя, на
экране появится сообщение: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">Bad command or file name</font>
</pre>

<p>Код возврата в этом случае будет 0 - как будто
все нормально! </p>

<p>Другие две возможности запустить программу -
использовать функции spawn и exec. Функция spawn и ее
разновидности запускают программу как дочерний
процесс. Функция exec загружает новую программу
как оверлей на место старой и передает ей
управление без возврата. После завершения
дочерней программе управление будет передано
COMMAND.COM или программе, которая запустила
родительскую программу. </p>

<p>Семейство функций spawn обеспечивает запуск
дочерней программы с родительской или со
специально сформированной средой. Кроме того, в
файле process.h описаны параметры, которые можно
передать функции spawn: </p>

<table BORDER="1">
  <tr>
    <td VALIGN="TOP" WIDTH="132"><font SIZE="2">P_WAIT</font></td>
    <td VALIGN="TOP" WIDTH="371">выполнение родительской
    программы задерживается до завершения дочерней
    программы. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="132">P_NOWAIT</td>
    <td VALIGN="TOP" WIDTH="371">родительская программа
    продолжает выполнение сразу после запуска
    дочерней. Этот параметр имеет смысл только для
    операционных систем OS/2, UNIX, в которых
    поддерживается мультизадачность. </td>
  </tr>
  <tr>
    <td VALIGN="TOP" WIDTH="132">P_OVERLAY</td>
    <td VALIGN="TOP" WIDTH="371">загружает программу как оверлей
    и передает ей управление. Этот режим
    соответствует функции exec в том смысле, что
    родительская программа не получит управления
    после завершения дочерней. </td>
  </tr>
</table>

<p>В качестве примера использования функций
запуска программы рассмотрим возможное решение
проблемы создания HELP-системы для прикладной
программы. </p>

<p>С помощью текстового редактора можно создать
справочную базу данных в формате утилиты Microsoft
HELPMAKE, затем, запуская в нужный момент диалоговую
утилиту работы с базой данных Microsoft Quick Help QH.EXE,
можно получить нужную справку. </p>

<p>Утилита QH использует базы данных, описанные в
переменной среды HELPFILES. Мы будем использовать
либо родительскую среду, где находится значение
переменной HELPFILES по умолчанию, либо указывать
новое значение для этой переменной. </p>

<p>Приведенная ниже программа используется для
получения справки о функции стандартной
библиотеки printf, поиск производится в HELP-базе QuickC: </p>

<pre>
<font COLOR="#000080" FACE="Courier New Cyr">#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;process.h&gt;

main()
{
         int r;

         // Получаем справку о функции printf,
         //  справочная база данных расположена
         //  в каталоге d:\qc2\bin

         r = help(&quot;HELPFILES=d:\\qc2\\bin;&quot;,&quot;printf&quot;);

         if( r == -1 )
                  printf( &quot;Невозможно запустить процесс&quot; );
         else
                  printf( &quot;\nПроцесс завершен&quot; );
         exit(r);
}


/**
*.Name      help
*
*.Title     Получить справку по заданному контексту
*
*.Descr     Функция получает в качестве параметров
*           переменную среды, указывающую на путь
*           к справочной базе данных и указатель
*           на строку контекста для поиска в базе.
*           Затем запускается как дочерний процесс
*           утилита Microsoft Quick Help QH.EXE, для
*           которой формируются среда и параметры.
*
*.Params    int help(char *help_file, char *help_topic);
*
*              help_file  - переменная среды, указывающая
*                           на путь к справочной базе
*
*              help_topic - контекст для поиска в базе
*
*
*.Return    0 при успешном запуске процесса
*           -1 не удалось запустить процесс
**/


int help(char *help_file, char *help_topic) {

         char *env[] = { &quot;&quot;, NULL }; // Среда, которую
                                                    // получит QH при запуске

         if(*help_file != 0) {
                env[0] = help_file; // Формируем среду для QH

                // Запускаем утилиту

                return(spawnlpe(P_WAIT,&quot;QH&quot;,&quot;QH&quot;,
                         &quot;-u&quot;,help_topic,NULL,env));
         }
         else {

                // Если переменная среды не задана,
                //   используем родительскую среду

                return(spawnlp(P_WAIT,&quot;QH&quot;,&quot;QH&quot;,
                         &quot;-u&quot;,help_topic,NULL));
         
        }
}</font>
</pre>

<p>Подробная информация об использовании утилит
HELPMAKE и QH приводится в документации на Microsoft C 6.0. </p>

<h2><a NAME="ch3_5">3.5. Завершение работы программы</a></h2>

<p>Старые версии DOS (до 2.0) требовали выполнения
достаточно сложной процедуры для завершения
программы. В начале работы программы необходимо
было сохранить адрес PSP, затем, перед завершением
работы поместить этот адрес в стек, поместить
туда же слово 0000 и выполнить команду дальнего
возврата. Управление при этом передается в
начало PSP, где находится команда INT&nbsp;20h. </p>

<p>Для версий DOS, начиная с 2.0, существуют более
удобные способы - использование напрямую команды
INT&nbsp;20h или функции 0 прерывания 21h (CS при этом
должен указывать на PSP, поэтому этот способ хорош
для COM-программ), или функции 4Ch прерывания 21h в
любое время и с любым содержимым регистров. </p>

<p>Последний способ рекомендуется для
использования и имеет еще то преимущество, что
позволяет передать родительской программе
(например, COMMAND.COM) код завершения. Этот код
доступен для анализа в пакетных файлах командой
IF&nbsp;ERRORLEVEL. </p>

<p>Приведенные в книге примеры программ на языке
ассемблера содержат директиву .EXIT. Эта директива
завершает выполнение программы с помощью
функции 4Ch и позволяет передать код завершения. </p>

<p>Если Ваша программа запустила дочернюю
программу и та завершилась с передачей кода
возврата, то родительская программа может
определить этот код с помощью функции 4Dh
прерывания 21h. Эта функция возвращает код в
регистре AX. </p>

<p>Программа, написанная на языке Си, может
завершаться с помощью return в функции main или с
помощью exit в любом месте программы. При этом
также возможна передача кода возврата. </p>

<p>Существуют еще способы завершения работы
программы, при которых программа (или ее часть)
остается резидентной в памяти. Это вызов
прерывания INT&nbsp;27H или функции 31h прерывания
INT&nbsp;21h. Об этом будет подробно рассказано в
разделе, посвященном резидентным программам. </p>
</body>
</html>
