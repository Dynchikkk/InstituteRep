stseg   segment para stack
    ; Стек (100h слов)
    dw 100h dup (?)
stseg   ends

dseg    segment para
    ; Объявление переменной – строка с завершающим нулём
    msg      db 'Belyaev Demin Sergunov', 0
    ; Координаты для вывода текста
    text_row db 12    ; Номер строки
    text_col db 30    ; Номер колонки
dseg    ends

cseg    segment para
lab62   proc far
    assume cs:cseg, ds:dseg, ss:stseg

    ; Инициализация сегментов данных
    mov ax, dseg
    mov ds, ax
    mov es, ax

    ; Установка видеорежима 03h (текстовый 80x25)
    mov ax, 0003h
    int 10h

    ; Заполнение экрана триколором:
    ; Верхняя белая полоса (8 строк)
    mov ax, 0608h       ; Функция 06h: заполнение/прокрутка, AL = 8 строк
    mov bh, 70h         ; Атрибут: белый фон (7<<4 = 70h)
    xor cx, cx          ; Координаты: верхний левый угол (0,0)
    mov dx, 074Fh       ; Координаты: нижний правый угол (7,79)
    int 10h

    ; Средняя синяя полоса (9 строк)
    mov ax, 0609h       ; AL = 9 строк
    mov bh, 10h         ; Атрибут: синий фон (1<<4 = 10h)
    mov cx, 0800h       ; Координаты: (8,0)
    mov dx, 104Fh       ; Координаты: (16,79)
    int 10h

    ; Нижняя красная полоса (8 строк)
    mov ax, 0608h       ; AL = 8 строк
    mov bh, 40h         ; Атрибут: красный фон (4<<4 = 40h)
    mov cx, 1100h       ; Координаты: (17,0)
    mov dx, 184Fh       ; Координаты: (24,79)
    int 10h

    ; Настройка позиции вывода текста с использованием переменных
    mov dh, [text_row]  ; Номер строки
    mov dl, [text_col]  ; Номер колонки
    mov si, offset msg  ; Указатель на строку

print_loop:
    ; Установка курсора в текущую позицию
    mov ah, 02h
    mov bh, 0
    int 10h

    ; Загрузка символа из строки и автоматическое увеличение SI
    lodsb               ; AL := [SI], SI++
    test al, al
    jz end_print

    ; Сохраняем исходный символ (он останется в BL)
    mov bl, al
    ; Сохраняем регистр DX, так как в нём находятся координаты курсора (DH = строка, DL = столбец)
    push dx

    ; Чтение текущего атрибута экрана (функция 08h)
    mov ah, 08h
    int 10h           ; После вызова: AH содержит атрибут текущей ячейки
    ; Сохраняем полученный атрибут в, например, BH (для вычислений не затрагивая BL, где символ)
    mov bh, ah

    ; Восстанавливаем координаты курсора
    pop dx

    ; Вычисление «противоположного» цвета текста:
    ; Извлекаем фон из атрибута (старшие 4 бита в BH)
    mov al, bh
    and al, 0F0h      ; AL = фон в виде 0x?0
    mov cl, 4
    shr al, cl        ; теперь AL = значение фона (число 0..F)
    ; Вычисляем противоположный цвет: 0Fh - фон
    mov cl, 0Fh
    sub cl, al       ; CL теперь содержит противоположный цвет для текста
    ; Восстанавливаем фон из исходного атрибута
    mov al, bh
    and al, 0F0h     ; AL = фон (высокий полубайт)
    or al, cl        ; AL = новый атрибут (фон + противоположный цвет текста)

    ; Подготовка к вызову функции 09h:
    ; Функция 09h ожидает: AL – символ, BL – атрибут.
    ; Сейчас AL содержит вычисленный атрибут, а BL – исходный символ.
    xchg al, bl     ; меняем местами: теперь AL = символ, BL = новый атрибут
    mov ah, 09h
    mov cx, 1       ; Вывод одного символа
    mov bh, 0       ; Страница 0
    int 10h

    ; Переход к следующему символу – увеличиваем столбец (DL)
    inc dl
    jmp print_loop

end_print:
    ; Ожидание нажатия клавиши
    mov ah, 00h
    int 16h

    ; Завершение программы
    mov ax, 4C00h
    int 21h

lab62   endp
cseg    ends
end lab62
