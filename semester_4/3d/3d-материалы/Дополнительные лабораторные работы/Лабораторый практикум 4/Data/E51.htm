<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Пример программы</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style type="text/css">
<!--
body {
	background-image: url(Fon.jpg);
}
.style1 {
	color: #009900;
	font-weight: bold;
	font-style: italic;
}
-->
</style>
</head>
<body>
<h2 align="center" class="style1">Пример программы</h2>
<blockquote>
  <p align="left"><em> Program Rotate_Rect;  <br>
    { Демонстрация композиции двухмерных аффинных преобразований }  <br>
    { на примере перемещения и вращения прямоугольника }  <br>
    { Моделирование объекта и аффинные преобразования }  <br>
    { задаются в матричном виде в однородных координатах }  <br>
    Uses Crt, Graph;  <br>
    Const  <br>
    { размер матрицы фигуры }  <br>
    l = 4; { количество точек }  <br>
    n = 3; { количество координат }  <br>
    alpha = 10/180; { угол поворота в радианах }  <br>
    { перемещение по координате X и Y }  <br>
    Dx = 2.87;  <br>
    Dy = 0.5;  <br>
    { Шаблон &quot;кисти&quot; для закрашивания прямоугольника } <br>
    Pattern : FillPatternType = (134,  <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;134 ); <br>
    Type  <br>
    { тип матрицы фигуры в однородных мировых координатах }  <br>
    TKoord_World = array[1..l, 1..n] of real;  <br>
    { тип матрицы аффинного преобразования в однородных координатах }  <br>
    TMatrix = array[1..n, 1..n] of real;  <br>
    Const  <br>
    { мировые однородные координаты фигуры }  <br>
    K_W : TKoord_World = ((175, 175, 1),  <br>
    (250, 175, 1),  <br>
    (250, 100, 1),  <br>
    (175, 100, 1)  <br>
    );  <br>
    { определение матрицы перемещения }  <br>
    M_Trans : TMatrix = ((1, 0, 0), { Matrix Transform }  <br>
    (0, 1, 0),  <br>
    (Dx, Dy, 1)  <br>
    );  <br>
    { размеры двухмерной области видимости }  <br>
    { в мировых координатах }  <br>
    Xw_max = 700.55;  <br>
    Yw_max = 500.7;  <br>
    Var  <br>
    { матрица поворота в однородных координатах }  <br>
    M_Rotate : TMatrix;  <br>
    { координаты центра поворота }  <br>
    x0, y0 : real;  <br>
    { коэффициенты преобразования мировых координат в экранные }  <br>
    hx, hy : real;  <br>
    { переменные для инициализации графического режима }  <br>
    grDriver, grMode : integer;  <br>
    ErrCode : byte;  <br>
    { Процедура умножения матриц }  <br>
    procedure MultMatrix(f:TKoord_World; { исходная матрица фигуры }  <br>
    m:TMatrix; { матрица аффинного преобразования }  <br>
    Var r:TKoord_World);{ результирующая матрица фигуры }  <br>
    var  <br>
    i,j,k : byte;  <br>
    t : TKoord_World;  <br>
    begin  <br>
    for i := 1 to l do  <br>
    for j := 1 to n do  <br>
    begin  <br>
    t[i,j] := 0;  <br>
    for k := 1 to n do  <br>
    t[i,j] := t[i,j] + f[i,k]*m[k,j];  <br>
    end;  <br>
    r := t;  <br>
    end;  <br>
    { функции преобразования мировых координат в экранные }  <br>
    { преобразование координаты X }  <br>
    function IX(x : real; hx : real) : integer;  <br>
    begin  <br>
    IX := Round(x*hx);  <br>
    end;  <br>
    { преобразование координаты Y }  <br>
    function IY(y : real; hy : real) : integer;  <br>
    begin  <br>
    IY := GetMaxY - Round(y*hy);  <br>
    end;  <br>
    Begin  <br>
    { Инициализация графического режима }  <br>
    grDriver := Detect;  <br>
    InitGraph(grDriver, grMode, '');  <br>
    ErrCode := GraphResult;  <br>
    if ErrCode = grOk then  <br>
    begin  <br>
    { Вычисление коэффициентов преобразования координат }  <br>
    hx := GetmaxX/Xw_max;  <br>
    hy := GetmaxY/Yw_max;  <br>
    { Определение матрицы поворота }  <br>
    { Определяются все элементы матрицы }  <br>
    { Кроме элементов последней строки }  <br>
    { Элементы последеней строки формируются с учетом }  <br>
    { координат центра поворота }  <br>
    M_Rotate[1,1] := Cos(alpha);  <br>
    M_Rotate[1,2] := Sin(alpha);  <br>
    M_Rotate[1,3] := 0;  <br>
    M_Rotate[2,1] := -Sin(alpha);  <br>
    M_Rotate[2,2] := Cos(alpha);  <br>
    M_Rotate[2,3] := 0;  <br>
    M_Rotate[3,3] := 1;  <br>
    { Вычисление координат центра поворота }  <br>
    { в качестве центра выбирается середина отрезка}  <br>
    x0 := K_W[1,1]+(K_W[2,1]-K_W[1,1])/2; { X }  <br>
    y0 := K_W[1,2]+(K_W[3,2]-K_W[1,2])/2; { Y }  <br>
    { Вывод текста }  <br>
    settextstyle(gothicFont, Horizdir, 3);  <br>
    setcolor(Yellow);  <br>
    OutTextXY(25, getmaxy - 40, ' Example 2-D Rotate&amp;Transform'); <br>
    repeat  <br>
    { Отображение прямоугольника }  <br>
    SetColor(Red);  <br>
    Line(IX(K_W[1,1],hx),IY(K_W[1,2],hy),IX(K_W[2,1],hx),IY(K_W[2,2],hy));  <br>
    Line(IX(K_W[2,1],hx),IY(K_W[2,2],hy),IX(K_W[3,1],hx),IY(K_W[3,2],hy));  <br>
    Line(IX(K_W[3,1],hx),IY(K_W[3,2],hy),IX(K_W[4,1],hx),IY(K_W[4,2],hy));  <br>
    Line(IX(K_W[4,1],hx),IY(K_W[4,2],hy),IX(K_W[1,1],hx),IY(K_W[1,2],hy));  <br>
    { Закраска прямоугольника }  <br>
    { Задание пользовательского типа кисти }  <br>
    SetFillPattern(Pattern, Magenta);  <br>
    FloodFill(IX(x0,hx), IY(y0,hy), Red);  <br>
    Delay(1500);  <br>
    { Стирание прямоугольника }  <br>
    { Закраска прямоугольника цветом фона }  <br>
    { Задание пользовательского типа кисти }  <br>
    SetFillPattern(Pattern, GetBkColor);  <br>
    FloodFill(IX(x0,hx), IY(y0,hy), Red);  <br>
    { Отрисовка прямоугольника цветом фона }  <br>
    SetColor(GetBkColor);  <br>
    Line(IX(K_W[1,1],hx),IY(K_W[1,2],hy),IX(K_W[2,1],hx),IY(K_W[2,2],hy));  <br>
    Line(IX(K_W[2,1],hx),IY(K_W[2,2],hy),IX(K_W[3,1],hx),IY(K_W[3,2],hy));  <br>
    Line(IX(K_W[3,1],hx),IY(K_W[3,2],hy),IX(K_W[4,1],hx),IY(K_W[4,2],hy));  <br>
    Line(IX(K_W[4,1],hx),IY(K_W[4,2],hy),IX(K_W[1,1],hx),IY(K_W[1,2],hy));  <br>
    { Применение операции перемещения фигуры }  <br>
    { реализуется умножением матрицы фигуры }  <br>
    { на матрицу перемещения }  <br>
    MultMatrix(K_W, M_Trans, K_W);  <br>
    { Перемещение центра поворота - центра прямоугольника }  <br>
    x0 := x0 + Dx; { X }  <br>
    y0 := y0 + Dy; { Y }  <br>
    { Определение элементов последеней строки }  <br>
    { матрицы поворота, исходя из координат центра поворота }  <br>
    M_Rotate[3,1] := -x0*Cos(alpha)+y0*Sin(alpha)+x0;  <br>
    M_Rotate[3,2] := -x0*Sin(alpha)-y0*Cos(alpha)+y0;  <br>
    { Применение операции поворота фигуры }  <br>
    { реализуется умножением матрицы фигуры }  <br>
    { на матрицу поворота }  <br>
    MultMatrix(K_W, M_Rotate, K_W);  <br>
    until KeyPressed;  <br>
    CloseGraph;  <br>
    end  <br>
    else Writeln('Graphics error:', GraphErrorMsg(ErrCode));  <br>
    End. <br>
  </em></p>
</blockquote>

</body>
</html>
