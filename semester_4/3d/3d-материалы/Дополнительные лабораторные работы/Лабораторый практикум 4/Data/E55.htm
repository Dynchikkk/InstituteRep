<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Пример программы</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style type="text/css">
<!--
body {
	background-image: url(Fon.jpg);
}
.style1 {
	color: #009900;
	font-weight: bold;
	font-style: italic;
}
-->
</style>
</head>
<body>
<h2 align="center" class="style1">Пример программы</h2>
 <blockquote>
   <p align="justify"><em>Program Delete_No_Visual_Line;  <br>
    { Демонстрация алгоритма удаления невидимых линий }  <br>
    { методом определения нормали на примере пиpамиды }  <br>
    { Моделирование объекта и аффинные преобразования }  <br>
    { задаются в матричном виде в однородных координатах }  <br>
    { Пpоекция - оpтогpафическая: наблюдатель находится }  <br>
    { в бесконечности на положительном напpавлении оси z }  <br>
    Uses Crt, Graph;  <br>
 
    Const  <br>
    { константы для удобного обращения к соответствующим координатам }  <br>
    { вершин пирамиды в матрицы объекта }  <br>
    x = 1;  <br>
    y = 2;  <br>
    z = 3;  <br>
    { размер матрицы фигуры }  <br>
    l = 4; { количество точек }  <br>
    n = 4; { количество координат }  <br>
    alpha = 10/180; { угол поворота в радианах }  <br>
    { перемещение по координате X, Y и Z }  <br>
    Dx = 0.87;  <br>
    Dy = 0.5;  <br>
    Dz = 0.5;  <br>
 
    Type  <br>
    { тип матрицы объекта в однородных мировых координатах }  <br>
    TKoord_World = array[1..l, 1..n] of real;  <br>
    { тип матрицы аффинного преобразования в однородных координатах }  <br>
    TMatrix = array[1..n, 1..n] of real;  <br>
    { тип матрицы граней объекта }  <br>
    TPoligon = array[1..l, 1..3] of integer;  <br>
    Const  <br>
    { мировые однородные координаты объекта }  <br>
    K_W : TKoord_World = ((220, 100, 0, 1),  <br>
    (400, 100, 0, 1),  <br>
    (450, 50, 150, 1),  <br>
    (350, 300, 50, 1));  <br>
    { определение матрицы перемещения }  <br>
    M_Trans : TMatrix = ((1, 0, 0, 0),  <br>
    (0, 1, 0, 0),  <br>
    (0, 0, 1, 0),  <br>
    (Dx, Dy, Dz, 1)  <br>
    );  <br>
    { матрица граней, задающая номера вершин }  <br>
    { из матрицы мировых однородных координат объекта, }  <br>
    { образующих соответствующие граней }  <br>
    Poligon : TPoligon = ((1, 2, 3),  <br>
    (1, 2, 4),  <br>
    (1, 3, 4),  <br>
    (2, 3, 4)  <br>
    );  <br>
    { размеры двухмерной области видимости }  <br>
    { в мировых координатах }  <br>
    Xw_max = 700.55;  <br>
    Yw_max = 500.7;  <br>
    Var  <br>
    { матрица поворота в однородных координатах }  <br>
    M_Rotate : TMatrix;  <br>
    { координаты центра поворота }  <br>
    x0, y0, z0 : real;  <br>
    { коэффициенты преобразования мировых координат в экранные }  <br>
    hx, hy : real;  <br>
    { переменные для инициализации графического режима }  <br>
    grDriver, grMode : integer;  <br>
    ErrCode : byte;  <br>
    { Процедура умножения матриц }  <br>
    procedure MultMatrix(f:TKoord_World; { исходная матрица объекта }  <br>
    m:TMatrix; { матрица аффинного преобразования }  <br>
    Var r:TKoord_World);{ результирующая матрица объекта }  <br>
    var  <br>
    i,j,k : byte;  <br>
    t : TKoord_World;  <br>
    begin  <br>
    for i := 1 to l do  <br>
    for j := 1 to n do  <br>
    begin  <br>
    t[i,j] := 0;  <br>
    for k := 1 to n do  <br>
    t[i,j] := t[i,j] + f[i,k]*m[k,j];  <br>
    end;  <br>
    r := t;  <br>
    end;  <br>
    { функции преобразования мировых координат в экранные }  <br>
    { преобразование координаты X }  <br>
    function IX(x : real; hx : real) : integer;  <br>
    begin  <br>
    IX := Round(x*hx);  <br>
    end;  <br>
    { преобразование координаты Y }  <br>
    function IY(y : real; hy : real) : integer;  <br>
    begin  <br>
    IY := GetMaxY - Round(y*hy);  <br>
    end;  <br>
    { отображение пирамиды на экран с удалением невидимых линий }  <br>
    procedure Show;  <br>
    Const  <br>
    { вектор направления наблюдения }  <br>
    Ez : array[1..n-1] of real = (0, 0, -1);  <br>
    Var  <br>
    { вектор нормали к текущей грани для определения видимости грани }  <br>
    normal : array[1..n-1] of real;  <br>
    { координаты внутренней точки пирамиды, }  <br>
    { в качестве которой выбран барицентр }  <br>
    p : array[1..n-1] of real;  <br>
    { рабочие переменные, задающие номера вершин в матрице граней }  <br>
    v1, v2, v3 : integer;  <br>
    { свободный член в уравнении плоскости, проходящей через грань }  <br>
    d,  <br>
    { скалярное произведение вектора нормали и вектора направления взгляда }  <br>
    Lf : real;  <br>
    i,j : integer;  <br>
    begin  <br>
    { определение координат внутренней точки }  <br>
    p[x] := 0; p[y] := 0; p[z] := 0;  <br>
    for i := 1 to l do  <br>
    begin  <br>
    p[x] := p[x] + K_W[i, x];  <br>
    p[y] := p[y] + K_W[i, y];  <br>
    p[z] := p[z] + K_W[i, z];  <br>
    end;  <br>
    p[x] := p[x]/l; p[y] := p[y]/l; p[z] := p[z]/l;  <br>
    { определение вектора нормали }  <br>
    for i := 1 to l do  <br>
    begin  <br>
    v1 := Poligon[i,1];  <br>
    v2 := Poligon[i,2];  <br>
    v3 := Poligon[i,3];  <br>
    normal[x] := (K_W[v1,y]-K_W[v2,y])*(K_W[v2,z]-K_W[v3,z])-  <br>
    (K_W[v1,z]-K_W[v2,z])*(K_W[v2,y]-K_W[v3,y]);  <br>
    normal[y] := (K_W[v1,z]-K_W[v2,z])*(K_W[v2,x]-K_W[v3,x])-  <br>
    (K_W[v1,x]-K_W[v2,x])*(K_W[v2,z]-K_W[v3,z]);  <br>
    normal[z] := (K_W[v1,x]-K_W[v2,x])*(K_W[v2,y]-K_W[v3,y])-  <br>
    (K_W[v1,y]-K_W[v2,y])*(K_W[v2,x]-K_W[v3,x]);  <br>
    { определение верного направления вектора нормали }  <br>
    { определение свободного члена уравнения плоскости, проходящей через грань }  <br>
    d := -(normal[x]*K_W[v1,x]+normal[y]*K_W[v1,y]+normal[z]*K_W[v1,z]);  <br>
    { вычисление скалярного произведения вектора нормали и вектора направления взгляда }  <br>
    Lf := normal[x]*p[x]+normal[y]*p[y]+normal[z]*p[z]+d;  <br>
    { определение знака скалярного произведения и, в случае необходимости }  <br>
    { изменение направления нормали }  <br>
    if Lf &gt; 0 then <br>
    normal[z] := -normal[z];  <br>
    { отрисовка ребер грани, если вектор нормали направлен на наблюдателя }  <br>
    if -normal[z] &lt; 0 then <br>
    begin  <br>
    setcolor(Red);  <br>
    Line(IX(K_W[v1,x],hx),IY(K_W[v1,y],hy),IX(K_W[v2,x],hx),IY(K_W[v2,y],hy));  <br>
    Line(IX(K_W[v1,x],hx),IY(K_W[v1,y],hy),IX(K_W[v3,x],hx),IY(K_W[v3,y],hy));  <br>
    Line(IX(K_W[v3,x],hx),IY(K_W[v3,y],hy),IX(K_W[v2,x],hx),IY(K_W[v2,y],hy));  <br>
    end;  <br>
    end;  <br>
    end;  <br>
    { Удаление изображения пирамиды }  <br>
    { отображение пирамиды на экран цветом фона }  <br>
    procedure Hidden;  <br>
    Var  <br>
    v1, v2, v3 : integer;  <br>
    i : integer;  <br>
    begin  <br>
    for i := 1 to l do  <br>
    begin  <br>
    v1 := Poligon[i,1];  <br>
    v2 := Poligon[i,2];  <br>
    v3 := Poligon[i,3];  <br>
    setcolor(GetBkColor);  <br>
    Line(IX(K_W[v1,x],hx),IY(K_W[v1,y],hy),IX(K_W[v2,x],hx),IY(K_W[v2,y],hy));  <br>
    Line(IX(K_W[v1,x],hx),IY(K_W[v1,y],hy),IX(K_W[v3,x],hx),IY(K_W[v3,y],hy));  <br>
    Line(IX(K_W[v3,x],hx),IY(K_W[v3,y],hy),IX(K_W[v2,x],hx),IY(K_W[v2,y],hy));  <br>
    end;  <br>
    end;  <br>
    Begin  <br>
    { Инициализация графического режима }  <br>
    grDriver := Detect;  <br>
    InitGraph(grDriver, grMode, '');  <br>
    ErrCode := GraphResult;  <br>
    if ErrCode = grOk then  <br>
    begin  <br>
    { Вычисление коэффициентов преобразования координат }  <br>
    hx := GetmaxX/Xw_max;  <br>
    hy := GetmaxY/Yw_max;  <br>
    { Определение матрицы поворота }  <br>
    { Определяются все элементы матрицы }  <br>
    { Кроме элементов последней строки }  <br>
    { Элементы последеней строки формируются с учетом }  <br>
    { координат пpямой, вокpуг котоpой осуществляется поворот }  <br>
    M_Rotate[1,1] := Cos(alpha);  <br>
    M_Rotate[1,2] := 0;  <br>
    M_Rotate[1,3] := -Sin(alpha);  <br>
    M_Rotate[1,4] := 0;  <br>
    M_Rotate[2,1] := 0;  <br>
    M_Rotate[2,2] := 1;  <br>
    M_Rotate[2,3] := 0;  <br>
    M_Rotate[2,4] := 0;  <br>
    M_Rotate[3,1] := Sin(alpha);  <br>
    M_Rotate[3,2] := 0;  <br>
    M_Rotate[3,3] := Cos(alpha);  <br>
    M_Rotate[3,4] := 0;  <br>
    M_Rotate[4,2] := 0;  <br>
    M_Rotate[4,4] := 1;  <br>
    { Вычисление координат точки, чеpез котоpую пpоходит пpямая, }  <br>
    { вокpуг котоpой осуществляется повоpот }  <br>
    X0 := 250;  <br>
    Y0 := 200;  <br>
    z0 := 50;  <br>
    { Задание типа линии }  <br>
    setlinestyle(SolidLn, 0, 3);  <br>
    { Вывод текста }  <br>
    settextstyle(gothicFont, Horizdir, 3);  <br>
    setcolor(Yellow);  <br>
    OutTextXY(25, getmaxy - 40, ' Example 3-D Rotate&amp;Transform&amp;Delete_Line'); <br>
    repeat  <br>
    { Отображение пирамиды }  <br>
    Show;  <br>
    Delay(1500);  <br>
    {Стирание пирамиды }  <br>
    Hidden;  <br>
    { Применение операции перемещения фигуры }  <br>
    { реализуется умножением матрицы фигуры }  <br>
    { на матрицу перемещения }  <br>
    MultMatrix(K_W, M_Trans, K_W);  <br>
    { Вычисление координат точки, чеpез котоpую пpоходит пpямая, }  <br>
    { вокpуг котоpой осуществляется повоpот }  <br>
    { в качестве такой точки выбирается одна из веpшин пиpамиды }  <br>
    x0 := x0 + Dx; { X }  <br>
    y0 := y0 + Dy; { Y }  <br>
    z0 := z0 + Dz; { Z }  <br>
    { Определение элементов последеней строки }  <br>
    { матрицы поворота, исходя из координат точки,  <br>
    { чеpез котоpую пpоходит ось поворота }  <br>
    M_Rotate[4,1] := x0-x0*Cos(alpha)-z0*Sin(alpha);  <br>
    M_Rotate[4,3] := z0+x0*Sin(alpha)-z0*Cos(alpha);  <br>
    { Применение операции поворота фигуры }  <br>
    { реализуется умножением матрицы фигуры }  <br>
    { на матрицу поворота }  <br>
    MultMatrix(K_W, M_Rotate, K_W);  <br>
    until KeyPressed;  <br>
    CloseGraph;  <br>
    end  <br>
    else Writeln('Graphics error:', GraphErrorMsg(ErrCode));  <br>
    End. <br>
      </em></p>
 </blockquote>

</body>
</html>
