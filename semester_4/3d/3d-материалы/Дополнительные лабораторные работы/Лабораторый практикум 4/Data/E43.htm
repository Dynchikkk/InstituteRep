<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Картинные алгоритмы удаления невидимых линий и поверхностей</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style type="text/css">
<!--
body {
	background-image: url(Fon.jpg);
}
.style1 {
	color: #009900;
	font-weight: bold;
	font-style: italic;
}
-->
</style>
</head>
<body>
<h2 align="center" class="style1">Картинные алгоритмы удаления невидимых линий и поверхностей</h2>
<p align="justify">Задача удаления невидимых граней является более сложной, чем задача удаления невидимых линий. Практически все методы удаления невидимых линий работают в объектном пространстве и дают точные результаты, а большинство методов удаления невидимых граней и поверхностей работают в картинной плоскости или являются смешанными. </p>
<p align="justify"><strong>Алгоритм </strong><strong>z - буфера. </strong>Одним из самых простых является метод <em>z </em>-буфера (метод глубины), в котором для каждого пикселя картинной плоскости находится грань, ближняя к наблюдателю вдоль направления проецирования. Данный метод относится к так называемым алгоритмам &quot;грубой силы&quot;, т. к. в нем используется простой перебор. Временные характеристики этого метода линейно зависят количества точек растра и &quot;глубинной сложности сцены&quot;, т.е. среднего числа граней, взаимно закрывающих друг друга. Время работы не зависит от числа граней поверхности многогранника. Часто используется для аппаратной реализации. </p>
<p align="justify">Как правило, метод привлекается для изображения сложных сцен с применением ортогонального проецирования на картинную плоскость. Для его реализации используются две области памяти: <strong>буфер глубины (</strong><strong><em>z </em>- буфер), </strong>хранящий координату <em>z </em> для каждого пиксела, и <strong>буфер кадра</strong>, хранящий информацию о состоянии пикселов экрана компьютера. </p>
<p align="justify"><strong>Буфер глубины </strong> используется для хранения координаты <strong><em>z </em></strong> (глубины) каждого видимого на данной стадии анализа изображения пиксела картинной плоскости. <strong>В буфере кадра </strong> запоминаются атрибуты соответствующего пиксела (интенсивность и цвет пиксела). </p>
<p align="justify">Работа метода происходит следующим образом: </p>
<ul>
  <li>
    <div align="justify"> В начальный момент буфер глубины инициализируется значением глубины фона, а буфер кадра – атрибутом цвета фона. </div>
  </li>
  <li>
    <div align="justify"> Проекция очередной грани объекта переводится в растровое представление на картинной плоскости и затем для каждого пиксела этой грани находится его глубина. </div>
  </li>
  <li>
    <div align="justify"> После этого анализируется глубина каждого нового пиксела изображения путем сравнения ее с глубиной того пиксела, который имеет ту же проекцию на картинную плоскость и уже занесен в буфер глубин. </div>
  </li>
  <li>
    <div align="justify"> Если значение <strong><em>z </em></strong> нового пиксела проекции меньше значения глубины соответствующего пиксела в <strong><em>z </em></strong>-буфере, то рассматриваемый элемент изображения находится ближе к картинной плоскости, чем часть уже построенной сцены. В этом случае атрибуты нового пиксела заносятся в буфер кадра, и производится корректировка координаты <strong><em>z </em></strong> соответствующего элемента буфера глубины. Если же сравнение дает противоположный результат, то никаких действий не производится, а буфер кадра и глубины остаются неизменными. </div>
  </li>
</ul>
<p align="justify">Грань рисуется последовательно строка за строкой. Для нахождения значений может использоваться линейная интерполяция. </p>
<p align="justify">Одним из недостатков метода является большой объем требуемой памяти. Для экономии памяти можно отрисовывать не все изображения сразу, а рисовать по частям. Для этого картинная плоскость разбивается на части (обычно горизонтальные полосы) и каждая из этих частей обрабатывается независимо. Размер памяти под буфер определяется размером наибольшей из этих частей. </p>
<p align="justify">Другим недостатком данного метода является избыточность вычислений. Осуществляется расчет для всех граней, независимо от того видны они или нет. Например, если некоторый пиксел картинной плоскости накрывается несколькими лицевыми гранями, то для каждого соответствующего пиксела каждой из этих граней необходимо провести расчет цвета. При использовании сложных моделей освещенности (например, модели Фонга) и текстур эти вычисления могут потребовать слишком больших временных затрат. </p>
<p align="justify">Существует несколько модификаций метода, позволяющих сократить количество выводимых граней. Чаще всего используется <strong>метод иерархического </strong><strong>z -буфера. <em></em></strong></p>
<p align="justify"><strong>Алгоритмы упорядочивания граней. </strong>Методы упорядочивания граней являются смешанными методами, осуществляющими сравнение и разбиение граней в объектном пространстве, а непосредственное наложение одной грани на другую – растровое пространство экрана. </p>
<p align="justify">Существуют различные методы упорядочивания граней, однако, возможны случаи, когда заданные грани упорядочить нельзя. </p>
<p align="justify"><strong>Метод сортировки по глубине. Алгоритм художника. </strong>Самый простой алгоритм упорядочивания, который сначала упорядочивает грани по мере приближения их к наблюдателю, а затем выводит их в этом порядке. </p>
<p align="justify">Метод основывается на следующей идее: если для двух граней <em>А </em> и <em>В </em> самая дальняя точка грани <em>А </em> ближе к наблюдателю, чем самая ближняя точка грани <em>В</em>, то грань <em>В </em> никогда не сможет закрыть грань <em>А </em>. </p>
<p align="justify">Однако на практике не всегда такое возможно. Как правило, множество всех лицевых граней сортируется по ближайшему расстоянию до наблюдателя и потом выводится в порядке приближения к наблюдателю. </p>
<p align="justify"><strong>Метод разбиения картинной плоскости. Алгоритм Варнака. </strong>Это еще один метод упорядочивания граней. В основе данного метода лежит разбиение картинной плоскости на прямоугольные участки (окна). Первоначально окно совпадает с размером экрана. Анализируется взаимное расположение изображения объекта и активного окна. Возможны следующие случаи: </p>
<ul>
  <li> 
    <div align="justify"><strong>Окно пусто (в него не попала проекция ни одного элемента сцены). </strong> Окно закрашивается цветом фона. </div>
  </li>
  <li> 
    <div align="justify"><strong>Окно охватывается проекцией ближайшего к нему по глубине многоугольника. </strong> Окно закрашивается цветом этого многоугольника. </div>
  </li>
  <li> 
    <div align="justify"><strong>Размеры окна меньше или равны размеру пиксела картинной плоскости. </strong>Принимается решение о закраске. </div>
  </li>
  <li> 
    <div align="justify"><strong>Не выполнено ни одно из предыдущих условий. </strong> Окно разбивается на четыре части и анализ повторяется для каждой из частей. </div>
  </li>
</ul>
<p align="justify">Для реализации метода необходимо выбрать эффективный способ анализа взаимного расположения окна и многоугольника (проекции грани на картинную плоскость). Метод позволяет применить для анализа изображения параллельные вычисления. </p>
<p align="justify"><strong>Алгоритм плавающего горизонта. </strong>Этот <strong></strong>алгоритм является <strong> х </strong>арактерным примером алгоритма, работающего в пространстве изображений. Данный алгоритм чаще всего используется для удаления невидимых линий трехмерного представления функций, описывающих поверхность в аналитическом виде <strong><em>F (</em></strong><strong><em>x, </em></strong><strong><em>y, </em></strong><strong><em>z) = 0</em></strong>. </p>
<p align="justify">Основная идея алгоритма состоит в сведении трехмерной задачи к двухмерной модели изображения путем сечения исходной поверхности параллельными плоскостями, имеющими постоянной значение <strong><em>x</em></strong>, <strong><em>y </em></strong> или <strong><em>z</em></strong>. <strong><em></em></strong></p>
<p align="justify">Функция <strong><em>F (</em></strong><strong><em>x, </em></strong><strong><em>y, </em></strong><strong><em>z) = 0 </em></strong>сводится к последовательности кривых, лежащих в этих плоскостях, т.е. к множеству функций вида <strong><em>y = </em></strong><strong><em>f (</em></strong><strong><em>x, </em></strong><strong><em>z) </em></strong> или <strong><em>x = </em></strong><strong><em>g (</em></strong><strong><em>y, </em></strong><strong><em>z)</em></strong>. Предполагается, что полученные таким образом кривые, являются однозначными функциями независимых переменных. </p>
<p align="justify">Алгоритм выглядит следующим образом: </p>
<ul>
  <li>
    <div align="justify"> Линии, соответствующие кривым, рисуются в порядке удаления (возрастания) и при рисовании очередной линии выводится только та ее часть, которая ранее нарисованными линиями не закрывалась. Для определения частей кривой, которые не закрываются ранее нарисованными кривыми, вводятся линии горизонта (контурные линии). Изначально линии горизонта не инициализированы, поэтому первая линия выводится полностью. После этого линии горизонта инициализируются так, что в выводимых точках они совпадают с линией, выведенной первой. </div>
  </li>
  <li>
    <div align="justify"> При выводе каждой следующей кривой, выводятся только те точки, проекция которых лежит вне области, задаваемой линиями верхнего и нижнего горизонтов. </div>
  </li>
</ul>
<p align="justify">Наиболее эффективной является растровая реализация данного метода, при которой каждая линия горизонта представляется набором значений <strong><em>Y </em></strong> с шагом 1 пиксел.</p>

</body>
</html>
