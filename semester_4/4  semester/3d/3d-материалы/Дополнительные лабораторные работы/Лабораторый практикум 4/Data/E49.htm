<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Пример программы</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style type="text/css">
<!--
body {
	background-image: url(Fon.jpg);
}
.style1 {
	color: #009900;
	font-weight: bold;
	font-style: italic;
}
-->
</style>
</head>
<body>
<h2 align="center" class="style1">Пример программы</h2>
 <div align="justify">
   <blockquote>
     <p><em>Program Rotate_Line;  <br>
      { Демонстрация композиции двухмерных аффинных преобразований }  <br>
      { на примере перемещения и вращения отрезка прямой }  <br>
      { Моделирование объекта и аффинные преобразования }  <br>
      { задаются в матричном виде в однородных координатах }  <br>
      Uses Crt, Graph;  <br>
      Const  <br>
      { размер матрицы фигуры }  <br>
      l = 2; { количество точек }  <br>
      n = 3; { количество координат }  <br>
      alpha = 10/180; { угол поворота в радианах }  <br>
      { перемещение по координате X и Y }  <br>
      Dx = 2.87;  <br>
      Dy = 0.5;  <br>
      Type  <br>
      { тип матрицы фигуры в однородных мировых координатах }  <br>
      TKoord_World = array[1..l, 1..n] of real;  <br>
      { тип матрицы аффинного преобразования в однородных координатах }  <br>
      TMatrix = array[1..n, 1..n] of real;  <br>
      Const  <br>
      { мировые однородные координаты фигуры }  <br>
      K_W : TKoord_World = (( 45.5, 300.33, 1),  <br>
      (105.75, 200, 1));  <br>
      { определение матрицы перемещения }  <br>
      M_Trans : TMatrix = ((1, 0, 0),  <br>
      (0, 1, 0),  <br>
      (Dx, Dy, 1)  <br>
      );  <br>
      { размеры двухмерной области видимости }  <br>
      { в мировых координатах }  <br>
      Xw_max = 700.55;  <br>
      Yw_max = 500.7;  <br>
      Var  <br>
      { матрица поворота в однородных координатах }  <br>
      M_Rotate : TMatrix;  <br>
      { координаты центра поворота }  <br>
      x0, y0 : real;  <br>
      { размеры области вывода на экране }  <br>
      Xs_max, Ys_max : integer;  <br>
      { коэффициенты преобразования мировых координат в экранные }  <br>
      hx, hy : real;  <br>
      { переменные для инициализации графического режима }  <br>
      grDriver, grMode : integer;  <br>
      ErrCode : byte;  <br>
      { Процедура умножения матриц }  <br>
      procedure MultMatrix(f:TKoord_World; { исходная матрица фигуры }  <br>
      m:TMatrix; { матрица аффинного преобразования }  <br>
      Var r:TKoord_World);{ результирующая матрица фигуры }  <br>
      var  <br>
      i,j,k : byte;  <br>
      t : TKoord_World;  <br>
      begin  <br>
      for i := 1 to l do  <br>
      for j := 1 to n do  <br>
      begin  <br>
      t[i,j] := 0;  <br>
      for k := 1 to n do  <br>
      t[i,j] := t[i,j] + f[i,k]*m[k,j];  <br>
      end;  <br>
      r := t;  <br>
      end;  <br>
      { функции преобразования мировых координат в экранные }  <br>
      { преобразование координаты X }  <br>
      function IX(x : real; hx : real) : integer;  <br>
      begin  <br>
      IX := Round(x*hx);  <br>
      end;  <br>
      { преобразование координаты Y }  <br>
      function IY(y : real; hy : real) : integer;  <br>
      begin  <br>
      IY := GetMaxY - Round(y*hy);  <br>
      end;  <br>
      Begin  <br>
      { Инициализация графического режима }  <br>
      grDriver := Detect;  <br>
      InitGraph(grDriver, grMode, '');  <br>
      ErrCode := GraphResult;  <br>
      if ErrCode = grOk then  <br>
      begin  <br>
      { Вычисление коэффициентов преобразования координат }  <br>
      Xs_max := GetmaxX;  <br>
      Ys_max := GetmaxY;  <br>
      hx := Xs_max/Xw_max;  <br>
      hy := Ys_max/Yw_max;  <br>
      { Определение матрицы поворота }  <br>
      { Определяются все элементы матрицы }  <br>
      { Кроме элементов последней строки }  <br>
      { Элементы последеней строки формируются с учетом }  <br>
      { координат центра поворота }  <br>
      M_Rotate[1,1] := Cos(alpha);  <br>
      M_Rotate[1,2] := Sin(alpha);  <br>
      M_Rotate[1,3] := 0;  <br>
      M_Rotate[2,1] := -Sin(alpha);  <br>
      M_Rotate[2,2] := Cos(alpha);  <br>
      M_Rotate[2,3] := 0;  <br>
      M_Rotate[3,3] := 1;  <br>
      { Задание пользовательского типа линии }  <br>
      setlinestyle(UserBitLn, 153, 3);  <br>
      { Вывод текста }  <br>
      settextstyle(gothicFont, Horizdir, 3);  <br>
      setcolor(Yellow);  <br>
      OutTextXY(25, getmaxy - 40, ' Example 2-D Rotate&amp;Transform'); <br>
      repeat  <br>
      { Отображение линии }  <br>
      SetColor(Red);  <br>
      Line(IX(K_W[1,1],hx),IY(K_W[1,2],hy),IX(K_W[2,1],hx),IY(K_W[2,2],hy));  <br>
      Delay(1500);  <br>
      { Стирание линии }  <br>
      { Отрисовка линии цветом фона }  <br>
      SetColor(GetBkColor);  <br>
      Line(IX(K_W[1,1],hx),IY(K_W[1,2],hy),IX(K_W[2,1],hx),IY(K_W[2,2],hy));  <br>
      { Применение операции перемещения фигуры }  <br>
      { реализуется умножением матрицы фигуры }  <br>
      { на матрицу перемещения }  <br>
      MultMatrix(K_W, M_Trans, K_W);  <br>
      { Вычисление координат центра поворота }  <br>
      { в качестве центра выбирается середина отрезка}  <br>
      x0 := K_W[1,1]+(K_W[2,1]-K_W[1,1])/2; { X }  <br>
      y0 := K_W[1,2]+(K_W[2,2]-K_W[1,2])/2; { Y }  <br>
      { Определение элементов последеней строки }  <br>
      { матрицы поворота, исходя из координат центра поворота }  <br>
      M_Rotate[3,1] := -x0*Cos(alpha)+y0*Sin(alpha)+x0;  <br>
      M_Rotate[3,2] := -x0*Sin(alpha)-y0*Cos(alpha)+y0;  <br>
      { Применение операции поворота фигуры }  <br>
      { реализуется умножением матрицы фигуры }  <br>
      { на матрицу поворота }  <br>
      MultMatrix(K_W, M_Rotate, K_W);  <br>
      { Рисование следов от концов отрезка }  <br>
      PutPixel(IX(K_W[1,1],hx), IY(K_W[1,2],hy), Green);  <br>
      PutPixel(IX(K_W[2,1],hx), IY(K_W[2,2],hy), Blue);  <br>
      Delay(1500);  <br>
      until KeyPressed;  <br>
      CloseGraph;  <br>
      end  <br>
      else Writeln('Graphics error:', GraphErrorMsg(ErrCode));  <br>
      End.  <br>
           </em></p>
   </blockquote>
</div>
 
</body>
</html>
