<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0050)tcp.htm -->
<HTML>
	<HEAD>
		<TITLE>Протокол TCP</TITLE>
		<meta name="vs_showGrid" content="False">
		<META http-equiv="Content-Type" content="text/html; charset=windows-1251">
		<LINK title="Olga V.Alikberova" rev="made" href="mailto:info@citmgu.ru">
			<META content="Информационные Технологии,Internet, Протокол TCP " name="KeyWords">
			<META content="all" name="Robots">
			<META content="Спецификация протокола TCP, перевод Р. Усманова, Ноябрь 1994" name="Description">
			<META content="Static" name="Document-state">
			<LINK href="TCP.files/forum.css" type="text/css" rel="stylesheet">
				<META content="MSHTML 6.00.2600.0" name="GENERATOR"></HEAD>
	<BODY text="#000000" vLink="#003860" aLink="#800000" link="#006890" bgColor="#ffffff"
		topMargin="0" marginheight="0">
		<A name="top"></A>
		<CENTER>
			<H1>Протокол TCP</H1>
		</CENTER>
		<CENTER>
			<H3>&nbsp;</H3>
		</CENTER>
		<OL>
			<A href="tcp.htm#0">
				<LI>
				Общие сведения </A>
			<BR>
			<A href="tcp.htm#3.0">
				<LI>
				Описание&nbsp;протокола</A><BR>
			<A href="tcp.htm#3.1">2.1 Формат заголовка</A><BR>
			<A href="tcp.htm#3.2">2.2 Терминология</A><BR>
			<A href="tcp.htm#3.3">2.3 Номера последовательности</A><BR>
			<A href="tcp.htm#3.4">2.4 Установление соединения</A><BR>
			<A href="tcp.htm#3.5">2.5 Закрытие соединения</A><BR>
			<A href="tcp.htm#3.7">2.6 Передача данных</A><BR>
			<A href="tcp.htm#3.6">2.7 Ссылки</A> </LI>
		</OL>
		<H2 align="center"><A name="0">1&nbsp;Общие сведения</A></H2>
		<P align="justify">Протокол управления передачей TCP (Transmission Control 
			Protocol) является протоколом транспортного уровня и базируется на 
			возможностях, предоставляемых межсетевым протоколом IP. Основная задача TCP - 
			обеспечение надежной передачи данных в сети.</P>
		<P align="justify">Протокол TCP предоставляет транспортные услуги, отличающиеся от 
			услуг UDP. Вместо ненадежной доставки датаграмм без установления соединений, он 
			обеспечивает гарантированную доставку с установлением соединений в виде 
			байтовых потоков. Протокол TCP используется в тех случаях, когда требуется 
			надежная доставка сообщений. Он освобождает прикладные процессы от 
			необходимости использовать таймауты и повторные передачи для обеспечения 
			надежности.</P>
		<P align="justify">
			Внутренняя структура модуля TCP гораздо сложнее структуры модуля UDP. 
			Прикладные процессы взаимодействуют с модулем TCP через порты. Для отдельных 
			приложений выделяются общеизвестные номера портов. Например, сервер TELNET 
			использует порт номер 23. Клиент TELNET может получать услуги от сервера, если 
			установит соединение с TCP-портом 23 на его машине. Когда прикладной процесс 
			начинает использовать TCP, то модуль TCP на машине клиента и модуль TCP на 
			машине сервера начинают общаться. Эти два оконечных модуля TCP поддерживают 
			информацию о состоянии соединения, называемого виртуальным каналом.&nbsp;Канал 
			является дуплексным; данные могут одновременно передаваться в обоих 
			направлениях. Один прикладной процесс пишет данные в TCP-порт, они проходят по 
			сети, и другой прикладной процесс читает их из своего TCP-порта.</P>
		<P align="justify">Протокол TCP разбивает поток байт на пакеты; он не сохраняет 
			границ между записями. Например, если один прикладной процесс делает 5 записей 
			в TCP-порт, то прикладной процесс на другом конце виртуального канала может 
			выполнить 10 чтений для того, чтобы получить все данные. Но этот же процесс 
			может получить все данные сразу, сделав только одну операцию чтения. Не 
			существует зависимости между числом и размером записываемых сообщений с одной 
			стороны и числом и размером считываемых сообщений с другой стороны. Протокол 
			TCP требует, чтобы все отправленные данные были подтверждены принявшей их 
			стороной. Он использует таймауты и повторные передачи для обеспечения надежной 
			доставки. Отправителю разрешается передавать некоторое количество данных, не 
			дожидаясь подтверждения приема ранее отправленных данных. Таким образом, между 
			отправленными и подтвержденными данными существует окно уже отправленных, но 
			еще неподтвержденных данных. Количество байт, которые можно передавать без 
			подтверждения, называется размером окна. Как правило, размер окна 
			устанавливается в стартовых файлах сетевого программного обеспечения. Так как 
			TCP-канал является дуплексным, то подтверждения для данных, идущих в одном 
			направлении, могут передаваться вместе с данными, идущими в противоположном 
			направлении. Приемники на обеих сторонах виртуального канала выполняют 
			управление потоком передаваемых данных для того, чтобы не допускать 
			переполнения буферов.
		</P>
		<P>
		<P>
			<CENTER>
				<H2><A name="3.0">2&nbsp;Описание протокола</A></H2>
			</CENTER>
			<CENTER>
				<H3><A name="3.1">2.1 Формат заголовка
				</H3>
			</CENTER>
		<P align="justify">Передача TCP сегментов осуществляется в виде Internet датаграмм. 
			Заголовок датаграммы в Internet протоколе имеет несколько информационных полей, 
			включая адреса отправляющего и принимающего хост- компьютеров <A href="tcp.htm#2">[2].</A>
		Заголовок TCP следует за Internet заголовком и дополняет его информацией, 
		специфической для TCP протокола. Такое деление допускает использование на 
		уровне хост-компьютеров протоколов, иных нежели TCP.
		<P align="justify">
		Формат TCP заголовка:
		<P>
			<CENTER>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD>
							0
							<TD>
							1
							<TD>
							2
							<TD>
							3
							<TD>
							4
							<TD>
							5
							<TD>
							6
							<TD>
							7
							<TD>
							8
							<TD>
							9
							<TD width="12">
							A
							<TD>
							B
							<TD>
							C
							<TD>
							D
							<TD>
							E
							<TD>
							F
							<TD>
							0
							<TD>
							1
							<TD>
							2
							<TD>
							3
							<TD>
							4
							<TD>
							5
							<TD>
							6
							<TD>
							7
							<TD>
							8
							<TD>
							9
							<TD>
							A
							<TD>
							B
							<TD>
							C
							<TD>
							D
							<TD>
							E
							<TD>F</TD>
						<TR>
							<TD colSpan="16">
								<CENTER>Source Port</CENTER>
							<TD colSpan="16">
								<CENTER>Destination Port</CENTER>
							</TD>
						<TR>
							<TD colSpan="32">
								<CENTER>Sequence Number</CENTER>
							</TD>
						<TR>
							<TD colSpan="32">
								<CENTER>Acknowledgment Number</CENTER>
							</TD>
						<TR>
							<TD colSpan="4">
								<CENTER>Data<BR>
									Offset</CENTER>
							<TD colSpan="6">
								<CENTER><BR>
									Reserved</CENTER>
							<TD width="12">U
								R<BR>
							G
							<TD>A<BR>
								C<BR>
							K
							<TD>P<BR>
								S<BR>
							H
							<TD>P<BR>
								S<BR>
							T
							<TD>S<BR>
								Y<BR>
							N
							<TD>F<BR>
								I<BR>
							N
							<TD colSpan="16">
								<CENTER><BR>
									Window</CENTER>
							</TD>
						<TR>
							<TD colSpan="16">
								<CENTER>Checksum</CENTER>
							<TD colSpan="16">
								<CENTER>Urgent Pointer</CENTER>
							</TD>
						<TR>
							<TD colSpan="24">
								<CENTER>Options</CENTER>
							<TD colSpan="8">
								<CENTER>Padding</CENTER>
							</TD>
						<TR>
							<TD colSpan="32">
								<CENTER>Data</CENTER>
							</TD>
						</TR>
					</TBODY></TABLE>
				<P>
				Рис. 3 Формат TCP заголовка
			</CENTER>
		<P align="justify">
		Отметим, что каждая метка указывает здесь место для соответствующего бита.
		<P align="justify">Source Port (порт отправителя) 16 бит<BR>
			номер порта отправителя
		</P>
		<P align="justify">Destination Port (порт получателя) 16 бит<BR>
			номер порта получателя
		</P>
		<P align="justify">Sequence Number (номер очереди) 32 бита<BR>
			Номер очереди для первого октета данных в данном сегменте (за исключением тех 
			случаев, когда присутствует флаг синхронизации SYN). Если же флаг SYN 
			присутствует, то номер очереди является инициализационным (ISN), а номер 
			первого октета данных - ISN+1.
		</P>
		<P align="justify">Acknowledgment Number (номер подтверждения) 32 бита<BR>
			Если установлен контрольный бит ACK, то это поле содержит следующий номер 
			очереди, который отправитель данной датаграммы желает получить в обратном 
			направлении. Номера подтверждения посылаются постоянно, как только соединение 
			будет установлено.
		</P>
		<P align="justify">Data Offset (смещение данных) 4 бита<BR>
			Количество 32-битных слов в TCP заголовке. Указывает на начало поля данных. TCP 
			заголовок всегда кончается на 32-битной границе слова, даже если он содержит 
			опции.
		</P>
		<P align="justify">Reserved 6 бит<BR>
			Это резервное поле, должно быть заполнено нулями.
		</P>
		<P align="justify">Control Bits (контрольные биты) 6 бит<BR>
			Биты этого поля слева направо:<BR>
		</P>
		<CENTER>
			<TABLE border="1">
				<TBODY>
					<TR>
						<TH>
							URG:
							<TD>поле срочного указателя задействовано</TD>
							<TR>
								<TH>
									ACK:
									<TD>поле подтверждения задействовано</TD>
									<TR>
										<TH>
											PSH:
											<TD>функция проталкивания</TD>
											<TR>
												<TH>
													RST:
													<TD>перезагрузка данного соединения</TD>
													<TR>
														<TH>
															SYN:
															<TD>синхронизация номеров очереди</TD>
															<TR>
																<TH>
																	FIN:
																	<TD>нет больше данных для передачи</TD>
															</TR>
				</TBODY></TABLE>
		</CENTER>
		<P align="justify">Window (окно) 16 бит<BR>
			Количество октетов данных, начиная с октета, чей номер указан в поле 
			подтверждения. Количество октетов, получения которых ждет отправитель 
			настоящего сегмента.
		</P>
		<P align="justify">Checksum (контрольная сумма) 16 бит<BR>
			Поле контрольной суммы - это 16-битное дополнение суммы всех 16- битных слов 
			заголовка и текста. Если сегмент содержит в заголовке и тексте нечетное 
			количество октетов, подлежащих учету в контрольной сумме, последний октет будет 
			дополнен нулями справа с тем, чтобы образовать для предоставления контрольной 
			сумме 16-битное слово. Возникший при таком выравнивании октет не передается 
			вместе с сегментом по сети. Перед вычислением контрольной суммы поле этой суммы 
			заполняется нулями.
		</P>
		<P align="justify">
		Контрольная сумма, помимо всего прочего, учитывает 96 бит псевдозаголовка, 
		который для внутреннего употребления ставится перед TCP заголовком. Этот 
		псевдозаголовок содержит адрес отправителя, адрес получателя, протокол и длину 
		TCP сегмента. Такой подход обеспечивает защиту протокола TCP от ошибшихся в 
		маршруте сегментов. Эту информацию обрабатывает Internet протокол. Она 
		передается через интерфейс протокол TCP/локальная сеть в качестве аргументов 
		или результатов запросов от протокола TCP к протоколу IP.
		<P>
			<CENTER>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD colSpan="4">
								<CENTER>Адрес отправителя
								</CENTER>
							</TD>
						<TR>
							<TD colSpan="4">
								<CENTER>Адрес получателя
								</CENTER>
							</TD>
						<TR>
							<TD>
							нули
							<TD>
							PTCL
							<TD colSpan="2">длина TCP</TD>
						</TR>
					</TBODY></TABLE>
			</CENTER>
		<P align="justify">
		Длина TCP сегмента - это длина TCP заголовка и поля данных, измеренная в 
		октетах. Это не является точным указанием количества передаваемых по сети 
		октетов, она не учитывает 12 октетов псевдозаголовка, но тем не менее расчет 
		этого параметра все же производится.
		<P align="justify">Urgent Pointer (срочный указатель) 16 бит<BR>
			Это поле сообщает текущее значение срочного указателя. Последний является 
			положительной величиной - смещением относительно номера очереди данного 
			сегмента. Срочный указатель сообщает номер очереди для октета, следующего за 
			срочными данными. Это поле интерпретируется только в том случае, когда в 
			сегменте выставлен контрольный бит URG.
		</P>
		<P align="justify">Options (опции) длина переменная<BR>
			Опции могут располагаться в конце TCP заголовка, а их длина кратна 8 бит. Все 
			опции учитываются при расчете контрольной суммы.
		</P>
		<P align="justify">Опции могут начинаться с любого октета. Они могут иметь два 
			формата:<BR>
		</P>
		<UL>
			<LI>
			однооктетный тип опций;
			<LI>
				октет типа опции, октет длины опции и октеты данных рассматриваемой опции.
			</LI>
		</UL>
		<P align="justify">
		В октете длины опции учитываются октет типа опции, сам октет длины, а также все 
		октеты с данными.
		<P align="justify">
		Заметим, что список опций может оказаться короче, чем можно указать в поле Data 
		Offset. Место в заголовке, остающееся за опцией "End-of-Option", должно быть 
		заполнено нулями. Протокол TCP должен быть готов обрабатывать все опции.
		<P>В настоящее время определены следующие опции:<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR>
						<TH>
							Тип
							<TH>
								Длина
								<TH>
						Значение</TR>
					<TR>
						<TD>
						0
						<TD>
						-
						<TD>конец списка опций</TD>
					<TR>
						<TD>
						1
						<TD>
						-
						<TD>нет операций</TD>
					<TR>
						<TD>
						2
						<TD>
						4
						<TD>максимальный размер сегмента</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P>
			<CENTER>Определения указанных опций
			</CENTER>
		<P>Конец списка опций<BR>
			<TABLE>
				<TBODY>
					<TR>
						<TD>
						00000000
						<TD>тип 0</TD>
					</TR>
				</TBODY></TABLE>
		<P align="justify">
		Этот код опции определяет конец списка опций. Конец списка может не совпадать с 
		концом TCP заголовка, указанным в поле Data Offset.
		<P align="justify">
		Эта опция используется после всех опций, но не после каждой из них. Опцию 
		необходимо использовать только в том случае, если иначе не будет совпадения с 
		концом TCP заголовка.
		<P>Нет операций<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR>
						<TD>
						00000001
						<TD>тип 1</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">
		Опции этого типа могут ставиться между опциями. Целью при этом может служить 
		выравнивание очередной опции по границе слова. Нет гарантии, что отправители 
		будут использовать данную опцию. Поэтому получатели должны быть готовы 
		обрабатывать опции, даже если они не будут начинаться на границе слова.
		<P>Максимальный размер сегмента<BR>
		</P>
		<P>
			<TABLE border="1">
				<TBODY>
					<TR>
						<TD>
						00000010
						<TD>
						00000100
						<TD>макс.разм.сегм.</TD>
					<TR>
						<TD>
						тип 2
						<TD>
						длина 4
						<TD><FONT color="#fff5ee">. </FONT>
						</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">
		Поле данных опции - 16 бит. Если опция присутствует в списке, то она указывает 
		для программы протокола TCP максимальный размер получаемого сегмента, 
		отправившей сегмент с этой опцией. Эту опцию следует посылать лишь при 
		первоначальном запросе на установление соединения (т.е. в сегментах с 
		установленным контрольным битом SYN). Если данная опция не была использована, 
		ограничения на размер отсутствуют.
		<P align="justify">
		Padding (выравнивание) длина переменная Выравнивание TCP заголовка 
		осуществляется с тем, чтобы убедиться в том, что TCP заголовок заканчивается, а 
		поле данных сегмента начинается на 32-битной границе. Выравнивание выполняется 
		нулями.
		<P><A name="3.2">
				<CENTER><B>2.2 Терминология </B>
					<P align="justify">
				</CENTER>
			</A>
		Прежде чем мы сможем обсудить многие детали действия TCP протокола, нам 
		необходимо ввести подробную терминологию. Для поддержания TCP соединения 
		необходимо иметь несколько переменных. Мы решили, что эти переменные будут 
		помещены в соответствующую запись - блок управления передачей (Transmission 
		Control Block - TCB). Среди переменных блока TCB имеются номера местного и 
		чужого сокетов, флаги безопасности и приоритета для данного соединения, 
		указатели буферов посылки и получения, указатели текущего сегмента и очереди 
		повторной посылки. Кроме всего этого в TCB имеются несколько переменных, 
		имеющих отношение к номерам очередей отправителя и получателя.
		<P align="justify">Отправление<BR>
		</P>
		<CENTER>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TH>
							SND.UNA
							<TD>посылка неподтверждена</TD>
							<TR vAlign="top">
								<TH>
									SND.NXT
									<TD>послать следующий сегмент</TD>
									<TR vAlign="top">
										<TH>
											SND.WND
											<TD>отправить окно</TD>
											<TR vAlign="top">
												<TH>
													SND.UP
													<TD>отправить срочный указатель</TD>
													<TR vAlign="top">
														<TH>
															SND.WL1
															<TD>номер очереди сегмента, использованный для обновления последнего окна</TD>
															<TR vAlign="top">
																<TH>
																	SND.WL2
																	<TD>номер подтверждения в сегменте, используемый для обновления последнего окна</TD>
																	<TR vAlign="top">
																		<TH>
																			ISS
																			<TD>первоначальный номер очереди отправления</TD>
																	</TR>
				</TBODY></TABLE>
		</CENTER>
		<P align="justify">Получение<BR>
		</P>
		<CENTER>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TH>
							RCV.NXT
							<TD>- получить следующий сегмент</TD>
							<TR vAlign="top">
								<TH>
									RCV.WND
									<TD>- получить окно</TD>
									<TR vAlign="top">
										<TH>
											RCV.UP
											<TD>- получить срочный указатель</TD>
											<TR vAlign="top">
												<TH>
													IRS
													<TD>- первоначальный номер очереди получения</TD>
											</TR>
				</TBODY></TABLE>
		</CENTER>
		<P align="justify">
		Нижеприведенные диаграммы могут помочь связать некоторые из этих переменных с 
		местом в очереди
		<P>
		Очередь отправления
		<P><IMG src="TCP.files/5_2.gif">
		<P>
			<OL>
				<LI>
				старые номера очереди, которые получили подтверждение
				<LI>
				номера очереди для данных, не получивших подтверждения
				<LI>
				номера очереди, допущенные к новой передаче
				<LI>
					следующие номера очереди, чья передача еще не разрешена</LI></OL>
		<P>
			<CENTER><A name="рис.4">Рис. 4 Очередь отправления
			</CENTER>
		<P></A>Окно отправления - это участок очереди, отмеченный меткой 3 на <A href="tcp.htm#рис.4">
				рисунке 4.
				<P>
			</A>
		Очередь получения
		<P><IMG src="TCP.files/5_3.gif">
		<P>
			<OL>
				<LI>
				старые номера очереди, которые получили подтверждение
				<LI>
				номера очереди, допущенные к очередному этапу получения
				<LI>
					следующие номера очереди, еще не получившие разрешения</LI></OL>
		<P>
			<CENTER><A name="рис.5">Рис. 5 Очередь получения
			</CENTER>
		<P align="justify"></A>Окно получения - это участок очереди, отмеченный меткой 2 на <A href="tcp.htm#рис.5">
				рисунке 5.
				<P align="justify">
			</A>
		В обсуждении также часто используются некоторые переменные, берущие свое 
		значение из полей очередного сегмента.
		<P>Переменные для очередного сегмента<BR>
		</P>
		<CENTER>
			<TABLE>
				<TBODY>
					<TR>
						<TH>
							SEG.SEQ
							<TD>номер очереди для сегмента</TD>
							<TR>
								<TH>
									SEG.ACK
									<TD>номер подтверждения для сегмента</TD>
									<TR>
										<TH>
											SEG.LEN
											<TD>длина сегмента</TD>
											<TR>
												<TH>
													SEG.WND
													<TD>окно для сегмента</TD>
													<TR>
														<TH>
															SEG.UP
															<TD>срочный указатель для сегмента</TD>
															<TR>
																<TH>
																	SEG.PRC
																	<TD>приоритет для сегмента</TD>
															</TR>
				</TBODY></TABLE>
		</CENTER>
		<P align="justify">
		Соединение во время функционирования проходит через серии промежуточных 
		состояний. Это состояния LISTEN, SYN-SENT, SYN-RECEIVED, ESTABLISHED, 
		FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT, а также 
		фиктивное состояние CLOSED. Состояние CLOSED является фиктивным, поскольку оно 
		представляет состояние, когда не существует блока TCP, а потому и нет 
		соединения. Краткое описание состояний:
		<P>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TH>
							LISTEN
							<TD>Ожидание запроса на соединение со стороны чужих портов и программ TCP</TD>
							<TR vAlign="top">
								<TH>
									SYN-SENT
									<TD>Ожидание парного запроса на установление соединения. С нашей стороны запрос уже 
										сделан.
									</TD>
									<TR vAlign="top">
										<TH>
											SYN-RECEIVED
											<TD>Ожидание подтверждения после того, как запрос соединения уже принят и 
												отправлен.
											</TD>
											<TR vAlign="top">
												<TH>
													ESTABLISHED
													<TD>Состояние открытого соединения, принимаемые данные можно представить 
														пользователю. Это нормальное состояние соединения в фазе передачи данных.
													</TD>
													<TR vAlign="top">
														<TH>
															FIN-WAIT-1
															<TD>Ожидание запроса от чужой программы TCP, или подтверждения ранее отправленного 
																запроса на закрытие соединения.
															</TD>
															<TR vAlign="top">
																<TH>
																	FIN-WAIT-2
																	<TD>Ожидание запроса на закрытие соединения со стороны чужой программы TCP.
																	</TD>
																	<TR vAlign="top">
																		<TH>
																			CLOSE-WAIT
																			<TD>Ожидание запроса на закрытие соединения со стороны своего клиента.
																			</TD>
																			<TR vAlign="top">
																				<TH>
																					CLOSING
																					<TD>Ожидание подтверждения со стороны чужой программы TCP запроса о закрытии 
																						соединения.
																					</TD>
																					<TR vAlign="top">
																						<TH>
																							LAST-ACK
																							<TD>Ожидание запроса на закрытие соединения, ранее отправленного чужой программе 
																								TCP (запрос включал также подтверждение получения чужого запроса на закрытие 
																								соединения).
																							</TD>
																							<TR vAlign="top">
																								<TH>
																									TIME-WAIT
																									<TD>Ожидание когда истечет достаточное количество времени и можно быть уверенным, 
																										что чужая программа TCP получила подтверждение своего запроса на закрытие 
																										соединения.
																									</TD>
																									<TR vAlign="top">
																										<TH>
																											CLOSED
																											<TD>Состояние полного отсутствия соединения.
																											</TD>
																									</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">
		Соединение TCP переходит с одного состояния на другое в ответ на события. 
		Событие - это запросы клиента (открытие, посылка, получение, закрытие, отказ, 
		получение состояния соединения), приход сегментов, и особенно тех, которые 
		содержат флаги SYN, ACK, RST и FIN, а также истечение выделенного времени.
		<P align="justify">Диаграмма состояний на <A href="tcp.htm#рис.6">рисунке 6 </A>
		иллюстрирует лишь смену состояний, а также вызвавшие это события, производимые 
		действия, но не адреса, условия ошибок, не действия, не связанные прямо с 
		изменением состояния.
		<P align="justify">Замечание: данная диаграмма является лишь сводной и не должна 
			восприниматься как полная спецификация.<A name="рис.6">
				<P>
					<CENTER><IMG src="TCP.files/5_4.gif"></CENTER>
					<CENTER>&nbsp;</CENTER>
				<P>
			</A><A name="3.3">
				<CENTER><B>2.3 Номера последовательности</B>
			</A></CENTER>
			<CENTER>&nbsp;</CENTER>
			<DIV align="justify">Основополагающей идеей в проектировании протокола является то, 
				что каждый октет данных, посылаемый на TCP соединение, имеет номер очереди. 
				Поскольку каждый октет пронумерован, то каждый из них может быть опознан. 
				Приемлемый механизм опознания является накопительным, так что опознание номера 
				X означает, что все октеты с предыдущими номерами уже получены. Этот механизм 
				позволяет регистрировать появление дубликатов в условиях повторной передачи. 
				Нумерация октетов в пределах сегмента осуществляется так, чтобы первый октет 
				данных сразу вслед за заголовком имел наименьший номер, а следующие за ним 
				октеты имели номера по возрастающей.
			</DIV>
		<P>Протокол TCP должен осуществлять следующие типы сравнения для номеров очереди:<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TD>
						(a)
						<TD>является ли номер в подтверждении номером очереди для октетов, уже 
							отправленных, но еще не получивших подтверждения;</TD>
					<TR vAlign="top">
						<TD>
						(b)
						<TD>получили ли все октеты в сегменте подтверждение своих номеров (т.е. следует ли 
							удалить данный сегмент из очереди на повторную посылку);</TD>
					<TR vAlign="top">
						<TD>
						(c)
						<TD>содержит ли пришедший сегмент ожидаемые нами номера (т.е. "перекрывает" ли этот 
							сегмент окно получателя).</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">В ответ на посылку данных протокол TCP будет получать их 
			подтверждение.</P>
		<P>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TH>
							SND.UNA
							<TD>самого старого из номеров, не имевших подтверждения,</TD>
							<TR vAlign="top">
								<TH>
									SND.NXT
									<TD>следующего номера очереди, ждущего посылки,
									</TD>
									<TR vAlign="top">
										<TH>
											SEG.ACK
											<TD>номера подтверждения, полученного от чужой принимающей программы TCP 
												(следующего номера очереди, ожидаемого чужой программой TCP),
											</TD>
											<TR vAlign="top">
												<TH>
													SEG.SEQ
													<TD>номера очереди первого октета в сегменте,
													</TD>
													<TR vAlign="top">
														<TH>
															SEG.LEN
															<TD>количества октетов в поле данных сегмента (учитывая SYN и FIN),
															</TD>
															<TR vAlign="top">
																<TH>
																	SEG.SEQ+SEG.LEN-1
																	<TD>номера очереди последнего октета из сегмента.
																	</TD>
															</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">Новое подтверждение (называемое "подтверждением приемлемости") - 
			это подтверждение выполнимости неравенств
			<BR>
		SND.UNA &lt; SEG.ACK = &lt; SND.NXT &lt; /P &gt;
		<P align="justify">
		Сегмент из очереди повторной посылки получает полное подтверждение, если сумма 
		его номера в очереди и длины поля данных меньше или равна номеру подтверждения 
		из пришедшего сегмента.
		<P>При получении данных необходимо производить операции сравнения для следующих 
			величин:<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TH>
							RCV.NXT
							<TD>следующий номер из очереди приходящих сегментов, а также левая или нижняя 
								граница окна получения,</TD>
							<TR vAlign="top">
								<TH>
									RCV.NXT+RCV.WND-1
									<TD>номер очереди последнего сегмента, ожидаемого в приходящем сегменте, а также 
										правая или верхняя граница окна получения,</TD>
									<TR vAlign="top">
										<TH>
											SEG.SEQ
											<TD>первый номер в очереди, принесенный пришедшим сегментом,</TD>
											<TR vAlign="top">
												<TH>
													SEG.SEQ+SEG.LEN-1
													<TD>последний номер в очереди, принесенный пришедшим сегментом.
														<TR>
														</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify">Считается, что сегмент перекрывает часть разрешенных номеров в 
			очереди получения, если<BR>
			RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND или
			<BR>
		RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND &lt; /P &gt;
		<P align="justify">
		Первая часть этого текста смотрит, попадает ли начало сегмента на окно, а 
		вторая часть - попадает ли в окно задняя часть сегмента. Если выполняется 
		какая-либо часть теста, то сегмент попадает в окно.
		<P align="justify">
		Действительность несколько сложнее. Выбирая окно нулевой длины или сегмент 
		нулевой длины, мы получаем четыре варианта проверки на приемлемость для 
		приходящих сегментов
		<P>
			<CENTER>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD>длина
								<BR>
							сегмента
							<TD>окно
								<BR>
							получения
							<TD>
								<CENTER>тест</CENTER>
							</TD>
						<TR>
							<TD>
							0
							<TD>
							0
							<TD>SEG.SEQ = RCV.NXT
							</TD>
						<TR>
							<TD>
							0
							<TD>
							&gt;0
							<TD>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND
							</TD>
						<TR>
							<TD>
							&gt;0
							<TD>
							0
							<TD>неприемлемо
							</TD>
						<TR>
							<TD rowSpan="2">
							&gt;0
							<TD rowSpan="2">
							&gt;0
							<TD>RCV.NXT =&lt; SEG.SEQ &lt; RCV.NXT+RCV.WND или<BR>
								RCV.NXT =&lt; SEG.SEQ+SEG.LEN-1 &lt; RCV.NXT+RCV.WND
							</TD>
						</TR>
					</TBODY></TABLE>
				<P align="justify">
			</CENTER>
		Заметим, что когда окно, получения нулевое, никакие сегменты приниматься не 
		будут за исключением ACK сегментов. Таким образом, протокол TCP может 
		устанавливать нулевое окно получения при передаче данных и получении 
		подтверждений. Однако даже когда окно получения нулевое, программа протокола 
		TCP обязана обрабатывать поля RST и URG всех приходящих сегментов.
		<P align="justify">
		Мы получили преимущество данной схемы нумерации в том, что она допускает также 
		защиту для определенной управляющей информации. Это достигается косвенным 
		образом посредством включения некоторых контрольных флагов в очередь, так что 
		они могут быть повторно посланы и подтверждены без сбоя (т.е. будет 
		задействована одна или несколько копий).
		<P align="justify">
		Управляющая информация реально находится не в поле данных сегмента. 
		Следовательно, мы должны принять правила косвенного присвоения номеров очереди 
		сегментам управления. SYN и FIN являются единственными управляющими сигналами, 
		приемлемыми для такой защиты, и они используются только при открытии и закрытии 
		соединения. Для целей поддержания очередности, сигнал SYN рассматривается как 
		стоящий перед первым действительным октетом данных в сегменте, куда оба они 
		были помещены. В то же время FIN считается стоящим после последнего реального 
		октета данных в сегменте. Длина сегмента (SEG.LEN) учитывает как данные, так и 
		номера очереди, отведенные под управление. В случае, когда присутствует SYN, 
		значение SEG.SEQ соответствует номеру в очереди для сигнала SYN.
		<P>
			<CENTER>Выбор первоначального номера для очереди
			</CENTER>
		<P align="justify">
		Протокол не накладывает ограничения на многократное повторное использование 
		конкретного соединения. Соединение задается подбором пары сегментов. Новые 
		запросы на установление какого-либо соединения будут рассматриваться как 
		повторные реализации этого соединения. Вследствие такого подхода возникает 
		следующая проблема: "Как протокол TCP отличает дубликаты сегментов, оставшиеся 
		от предыдущей реализации этого соединения?" Эта проблема становится явной, если 
		соединение быстро открывается и закрывается несколько раз подряд, или же если 
		соединение прерывает свою работу с потерей информации, хранившейся в 
		оперативной памяти компьютера, и затем устанавливается повторно.
		<P align="justify">
		Чтобы избежать сбоя, мы должны избегать использования сегментов данной 
		реализации соединения, когда в сети еще присутствуют те же самые номера 
		очереди, оставшиеся от предыдущей реализации соединения. Мы желаем 
		застраховаться от этого, даже если программа протокола TCP даст сбой и потеряет 
		всю информацию об используемых ею номерах очередей. При создании новых 
		соединений применяется генератор первоначальных номеров очереди (ISN), который 
		выбирает новые 32 битные значения ISN. Генератор привязан к 32-битным часам 
		(вероятно, фиктивным), чье значение меняется каждые 4 микросекунды. Таким 
		образом, полный цикл часов ISN составляет примерно 4.55 часа. Поскольку мы 
		полагаем, что сегменты будут существовать в сети не более максимального времени 
		жизни сегмента (Maximum Segment Lifetime - MSL), и что MSL меньше, чем 4.55 
		часа, то мы можем с основанием полагать, что номера ISN будут уникальны.
		<P align="justify">
		Для каждого соединения существует номер в очереди отправления и номер в очереди 
		получения. Первоначальный номер в очереди отправления (ISS) выбирается 
		программой TCP, посылающей данные в этой очереди, а первоначальный номер в 
		очереди получения (IRS) выясняется во время установления соединения.
		<P align="justify">
		Во время установления или инициализации какого-либо соединения обе программы 
		протокола TCP должны синхронизировать друг с другом первоначальные номера 
		очередей. Это осуществляется посредством обмена сегментами, устанавливающими 
		соединения, несущими контрольный бит, называемый "SYN" (for synchronize - для 
		синхронизации), несущими исходные номера для очередей. Для краткости, сегменты, 
		несущие бит SYN, также называются SYN сегментами. Следовательно, решение 
		проблемы требует приемлемого механизма для подбора первоначального номера 
		очереди и немногочисленных сигналов подтверждения при обмене номерами ISN.
		<P align="justify">
		Синхронизация требует, чтобы каждая сторона, участвующая в соединении, посылала 
		свой собственный первоначальный номер очереди, а также получала подтверждение 
		на это от напарника. Каждая сторона должна также получить первоначальный номер 
		очереди от напарника и послать подтверждение.
		<P>
			<CENTER>
				<TABLE>
					<TBODY>
						<TR>
							<TD>1) A --&gt; B сигнал SYN: мой номер очереди X</TD>
						<TR>
							<TD>2) A &lt;-- B сигнал ACK: ваш номер очереди X</TD>
						<TR>
							<TD>3) A &lt;-- B сигнал SYN: мой номер очереди Y</TD>
						<TR>
							<TD>4) A --&gt; B сигнал ACK: ваш номер очереди Y</TD>
						</TR>
					</TBODY></TABLE>
				<P align="justify">
			</CENTER>
		Поскольку шаги 2 и 3 можно объединить в одно сообщение, последнее называется 
		подтверждением трех путей (трех сообщений).
		<P align="justify">Подтверждение трех путей необходимо, поскольку номера очереди не 
			привязываются к неким глобальным часам данной компьютерной сети, и программы 
			TCP могут иметь различные механизмы для подбора номеров ISN. Получатель первого 
			сигнала SYN не может знать, задержался ли этот сигнал и уже устарел, или это не 
			так, даже если получатель не помнит последний номер очереди, использованный 
			этим соединением (что тоже не всегда возможно). Так что он должен попросить 
			отправителя проверить этот сигнал SYN. Подтверждение трех путей и преимущества 
			хронометрированной схемы обсуждаются в статье <A href="tcp.htm#3">[3].</A>
		<P>
			<CENTER>Период молчания
				<P align="justify">
			</CENTER>
		Чтобы быть уверенным в том, что программа TCP не создает сегмента, несущего 
		номер очереди, который уже используется старым сегментом, все еще "ходящим" по 
		сети, программа TCP должна сохранять молчание по крайней мере в течении времени 
		жизни сегмента (MSL) до тех пор, пока она не назначит какие-либо номера очереди 
		при запуске или восстановлении после сбоя, когда записи в памяти для прежних 
		номеров из очереди были потеряны. В данной спецификации MSL берется равным 2 
		минуты.
		<P align="justify">
		Это значение выбрано разработчиками и может быть изменено, если практика 
		покажет необходимость в этом. Заметим, что если программа протокола в некотором 
		смысле повторно инициализируется, но при этом в памяти остались применявшиеся 
		ранее номера очереди, то в ожидании нужды нет; следует лишь убедиться в том, 
		что новые рабочие номера очередей больше, чем применявшиеся ранее.
		<P>
			<CENTER>Концепция периода молчания в протоколе TCP
				<P align="justify">
			</CENTER>
		Данная спецификация ставит условие что компьютеры, потерпевшие крах с потерей 
		всей информации о последних номерах очередей, передаваемых по открытым (т.е. не 
		закрытым специальной командой) соединениям, будут воздерживаться от посылки 
		каких-либо TCP сегментов в течении по крайней мере максимального времени жизни 
		сегмента (Maximum Segment Lifetime - MSL) в системе Internet, чей частью и 
		является данный хост. В последующих параграфах приводится объяснение для этой 
		спецификации. Некоторые реализации протокола TCP могут нарушать соглашение о 
		периоде молчания, рискуя при этом тем, что некоторые получатели в системе 
		Internet будут воспринимать старые данные как новые, или новые данные будут 
		отброшены словно дубликаты в действительности устаревших сегментов.
		<P align="justify">
		Программы протокола используют новые номер очереди всякий раз, когда какой-либо 
		сегмент формируется и помещается на хосте в очередь отправления по сети. 
		Процедура фиксирования дубликатов и алгоритм очереди в протоколе TCP полагаются 
		на уникальное связывание данных сегмента с местом в очереди. Номера очереди не 
		успевают пройти весь диапазон в 2**32 значения, прежде чем связанные с ними 
		данные из отправленного сегмента получат подтверждение от получателя, а все 
		копии-дубликаты упомянутого сегмента покинут сеть Internet. Без этого условия 
		можно предположить, что двум отдельным TCP сегментам могут быть назначены 
		одинаковые или перекрывающиеся номера, что вызовет проблему у получателя при 
		определении, какие данные являются новыми, а какие устаревшими. Напомним, что 
		каждый сегмент привязан как ко множеству следующих друг за другом номеров 
		очереди, так и к имеющимся в этом сегменте октетам данных.
		<P align="justify">
		При обычных условиях программы TCP отслеживают текущий номер очереди, 
		подлежащий отправке, а также самое старое из ожидаемый подтверждений, что 
		позволяет избежать ошибочного использования номера очереди, прежде чем будет 
		получено подтверждение от более раннего использования этого же номера. Одно это 
		не гарантирует, что старые данные - дубликаты будут удалены из сети, поэтому 
		номера очереди сделаны очень большими, чтобы уменьшить вероятность того, что 
		странствующие по сети дубликаты вызовут сбой по прибытии. При скорости обмена 2 
		мегабайта/сек очереди в 2**32 октета хватает на 4.5 часа. Поскольку 
		максимальное время жизни сегмента в сети вряд ли превышает несколько десятков 
		секунд, это считается достаточной защитой для будущих сетей, даже если скорости 
		передачи данных возрастут до десятков мегабит/сек.
		<P align="justify">
		При скорости 100 мегабит/сек один цикл использования всех номеров очереди 
		составляет 5.4 минуты, что может быть достаточно мало, но еще остается 
		приемлемым.
		<P align="justify">
		Однако основной механизм регистрации дублей и поддержания очередей может быть 
		отменен, если программа протокола TCP, посылающая данные, не имеет места в 
		памяти для хранения номеров в очереди, которые она использовала в последний раз 
		для конкретного соединения. Например, если программа TCP при создании всех 
		соединений начинает с номера очереди 0, то при сбое и повторном запуске 
		программа TCP может повторно сформировать прежнее соединение (возможно, после 
		анализа наполовину открытого соединения) и послать по нему пакеты, чьи номера в 
		очереди полностью совпадают или лишь частично перекрывают номера пакетов, 
		которые еще присутствуют в сети и были отправлены предыдущей реализацией этого 
		же соединения. В отсутствие сведений о номерах очереди, прежде использовавшихся 
		для передачи информации по данному конкретному соединению, спецификация 
		протокола TCP рекомендует отправителю воздержаться на MSL секунд от посылки 
		сегментов по этому со единению, что даст возможность сегментам, запущенным в 
		сеть старой реализацией соединения, покинуть систему.
		<P align="justify">
		От этой проблемы не защищены даже те хост-компьютеры, которые могут отслеживать 
		текущее время и использовать его при выборе исходных номеров очереди (т.е. даже 
		если время используется для выбора исходного номера при реализации каждого 
		нового соединения).
		<P align="justify">
		В качестве примера предположим, что соединение открыто со стартовым номером 
		очереди S. Предположим также, что это соединение используется не столь часто и 
		возможно, функция определения исходного номера очереди (ISN(t)) принимает 
		значение (скажем, S1), равное номеру последнего сегмента, отправленного данной 
		программой TCP, по этому конкретному соединению, Теперь предположим, что именно 
		в этот момент хост-компьютер дал сбой, восстановился и устанавливает новую 
		реализацию этого соединения. Первоначальный номер очереди при этом будет 
		S1=ISN(t), а это последний номер очереди в старой реализации соединения! Если 
		восстановление произойдет достаточно быстро, то старые дубликаты, созданные с 
		номером очереди, близким к номеру S1, могут быть получены своим адресатом и 
		обработаны так, как будто бы это новые пакеты в новой реализации соединения.
		<P align="justify">
		Проблема состоит в том, что хост-компьютер - получатель может не знать, как 
		долго он был в состоянии сбоя и существуют ли еще в системе старые дубликаты, 
		оставшиеся от прежних реализаций соединений.
		<P align="justify">
		Одним из путей решения этой проблемы является преднамеренная задержка в 
		отправлении сегментов в течении времени MSL после восстановления вслед за 
		крахом - это спецификация периода молчания. Хост-компьютеры, предпочитающие 
		избегать паузы, рискуют получить проблему столкновения старых и новых пакетов 
		на каком-либо адресате, пожелавшем не прибегать к периоду молчания.
		<P align="justify">
		Реализации протокола могут предложить пользователям TCP возможность выбора 
		между ожиданием в соединениях после сбоя и несоблюдением периода молчания для 
		любых соединений. Очевидно, что для тех программ, где пользователь выбрал режим 
		ожидания, в действительности, в этом нет нужды после того, как компьютер был 
		выключен по крайней мере MSL секунд.
		<P align="justify">
		Итак, каждый отправленный сегмент занимает один или несколько номеров в очереди 
		ожидания. Номера, отведенные под сегмент, являются "занятыми" или "в работе", 
		пока не истекут MSL секунд. При сбое определенное место в очереди в течении 
		определенного времени продолжает оставаться занятым октетами из последнего 
		отправленного сегмента. Если вскоре создается новое соединение и оно использует 
		какие-либо номера из очереди в момент, когда ими еще пользуется сегмент из 
		предыдущей реализации соединения, то следовательно эта область перекрывания 
		номеров очередей может являться причиной проблем у получателя.
		<P><A name="3.4">
				<CENTER><B>2.4 Установление соединения</B>
					<P align="justify">
				</CENTER>
			</A>
		"Подтверждение трех путей" - это процедура, используемая при установлении 
		соединения. Эта процедура обычно инициируется программой протокола TCP в ответ 
		на запрос другой программы TCP. Данная процедура также работает, если две 
		программы TCP инициируют ее одновременно. Когда попытка инициализации 
		осуществляется с обоих концов одновременно, каждая программа протокола TCP 
		получает сегмент "SYN", который не несет подтверждения для уже отправленного ею 
		"SYN". Конечно, прибытие старых дубликатов сегмента "SYN" может произвести 
		впечатление на получателя, будто осуществляется одновременное открытие 
		соединения. Корректное применение сегментов "перезагрузки" может предотвратить 
		двусмысленность таких ситуаций.
		<P align="justify">
		Ниже приведены несколько примеров инициализации соединений. Хотя эти примеры не 
		показывают синхронизации соединения с помощью сегментов, несущих данные, это 
		совершенно правомерно, поскольку программа TCP, получающая сегменты, не 
		передаст данные своему клиенту, пока не станет очевидным корректность данных 
		(т.е. данные должны "складироваться" пользователем до тех пор, пока соединение 
		не перейдет в состояние ESTABLISHED). Подтверждение трех путей уменьшает 
		вероятность появления ложных соединений. Получение информации для такой 
		проверки достигается посредством реализации обмена между памятью компьютера и 
		циркулирующими в сети сообщениями.
		<P align="justify">Простейшая процедура подтверждения трех путей показана ниже на <A href="tcp.htm#рис.7">
				рисунке 7.</A>
		Рисунки следует интерпретировать следующим образом. Для удобства каждая строка 
		пронумерована. Правые стрелки (--&gt;) показывают отправление TCP сегмента от 
		программы TCP A в программу TCB B, или же получение сегмента программой B из 
		программы A. Левые стрелки (&lt;--) показывают обратные процессы. Многоточие 
		(...) показывает сегмент, который все еще задерживается в сети. "XXX" указывает 
		на сегмент, который потерян или отвергнут. Комментарии появляются в скобках.
		<P align="justify">
			Здесь "состояния" программы протокола TCP соответствуют моменту сразу после 
			посылки или получения сегмента (содержимое этого сегмента показано в средней 
			колонке каждой строки). Содержимое сегмента в приводится в сокращенной форме и 
			представляет собой номер очереди, флаги управления и поле ACK. Остальные поля 
			сегмента, такие как окно, длина и поле данных остаются за рамками нашего 
			интереса.</P>
		<A name="рис.7">
			<P>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD><FONT color="#fff5ee">.</FONT>
							<TD>
							TCP A
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>TCP B</TD>
						<TR>
							<TD>
							1.
							<TD>
							CLOSED
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>LISTEN
							</TD>
						<TR>
							<TD>
							2.
							<TD>
							SYN-SENT
							<TD>
							--&gt;
							<TD>&lt;TD&gt;&lt;SEQ=100&gt;&lt;CTL=SYN&gt;
							<TD>
							--&gt;
							<TD>SYN-RECEIVED
							</TD>
						<TR>
							<TD>
							3.
							<TD>
							ESTABLISHED
							<TD>
							&lt;--<TD>
							&lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;
							<TD>
							&lt;--
							<TD>SYN-RECEIVED
							</TD>
						<TR>
							<TD>
							4.
							<TD>
							ESTABLISHED
							<TD>
							--&gt;<TD>
							&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;
							<TD>
							--&gt;
							<TD>ESTABLISHED
							</TD>
						<TR>
							<TD>
							5.
							<TD>
							ESTABLISHED
							<TD>
							--&gt;<TD>
							&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt;
							<TD>
							--&gt;
							<TD>ESTABLISHED
							</TD>
						</TR>
					</TBODY></TABLE>
			</P>
			<P>
				<CENTER>Основная процедура подтверждения трех путей для
					<BR>
					синхронизации соединения
					<BR>
					Рисунок 7.
					<P align="justify">
				</CENTER>
		</A>На строке 2 рисунка 7 программа TCP A начинает с посылки сигнала SYN, 
		показывая тем самым, что она будет использовать номера очереди, начиная с 
		номера 100. На строке 3 программа TCB B посылает сигнал SYN, а также 
		подтверждение о том, что сигнал SYN со стороны программы TCP A получен. 
		Заметим, что поле подтверждения информирует о том, что программа TCP B в данный 
		момент ожидает получение номера 101. Последнее также подтверждает, что сигнал 
		SYN уже занял место в очереди под номером 100.
		<P align="justify">
		На строке 4 для отправленного программой TCP B в строке 3 сигнала SYN программа 
		TCP A дает ответ с помощью пустого сегмента, содержащего сигнал ACK . В строке 
		5 программа TCP A передает по сети уже некую порцию данных. Заметим, что 
		сегмент в строке 5 имеет тот же номер очереди, что был у сегмента в строке 4, 
		поскольку сигнал ACK в очереди места не занимает (если бы это было не так, то 
		нам следовало обзавестись подтверждением -ACK- для самого подтверждения!).
		<P align="justify">
		На рисунке 8 показана та же инициализация с незначительными усложнениями. 
		Каждая программа TCP проходит по очереди состояния CLOSED, SYN-SENT, 
		SYN-RECIEVED и наконец, ESTABLISHED.
		<P>
			<TABLE border="1">
				<TBODY>
					<TR>
						<TD><FONT color="#fff5ee">. </FONT>
						<TD>
						TCP A
						<TD colSpan="3"><FONT color="#fff5ee">. </FONT>
						<TD>TCP B</TD>
					<TR>
						<TD>
						1.
						<TD>
						CLOSED
						<TD colSpan="3"><FONT color="#fff5ee">. </FONT>
						<TD>CLOSED</TD>
					<TR>
						<TD>
						2.
						<TD>
						SYN-SENT
						<TD>
						--&gt;
						<TD>&lt;SEQ=100&gt;&lt;CTL=SYN&gt;
						<TD>... 
						<TD>&nbsp;
					  </TD>
					<TR>
						<TD>
						3.
						<TD>
						  SYN-RECEIVED
					  <TD> &lt;--
					  <TD>&lt;SEQ=300&gt;&lt;CTL=SYN&gt;
						<TD>
						&lt;--
					  <TD>
							SYN-SENT
					  </TD>
					<TR>
						<TD>
						4.
						<TD>
						
						<TD>
						...
						<TD>&lt;SEQ=100&gt;&lt;CTL=SYN&gt;
						<TD>
						--&gt;
						<TD>
							SYN-RECEIVED
						</TD>
					<TR>
						<TD>
						5.
						<TD>
						SYN-RECEIVED
						<TD>
						--&gt;<TD>
						&lt;SEQ=100&gt;&lt;ACK=301&gt;&lt;CTL=SYN,ACK&gt;
						<TD>
						...
						<TD><FONT color="#fff5ee">.</FONT></TD>
					<TR>
						<TD>
						6.
						<TD>
						ESTABLISHED
						<TD>
						&lt;--<TD>
						&lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;
						<TD>
						&lt;--
						<TD>SYN-RECEIVED</TD>
					<TR>
						<TD>
						7.
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						...<TD>
						&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;
						<TD>
						--&gt;
						<TD>ESTABLISHED</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P>
			<CENTER>Одновременная синхронизация соединения
				<BR>
				Рисунок 8
				<P align="justify">
			</CENTER>
		Главной причиной для применения подтверждения трех путей является попытка 
		предотвратить возникновение сбоев при получении старых дубликатов, инициирующих 
		соединение. Для работы с подтверждением трех путей придумано специальное 
		контрольное сообщение - перезагрузка (reset).
		<P align="justify">Если получающая сигнал программа TCP находится не в 
			синхронизированном состоянии (т.е. в SYN-SENT, SYN-RECEIVED), то она возвращает 
			сигнал LISTEN, показывая, что она получила приемлемый сигнал перезагрузки. Если 
			же программа TCP находится в одном из синхронизированных состояний 
			(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, 
			TIME-WAIT), то она ликвидирует соединение и проинформирует об этом своего 
			клиента. Мы обсудим ниже такую ситуацию при рассмотрении "наполовину открытых" 
			соединений.<A name="рис.9">
				<P>
					<TABLE border="1">
						<TBODY>
							<TR>
								<TD><FONT color="#fff5ee">.</FONT>
								<TD>
								TCP A
								<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
								<TD>TCP B</TD>
							<TR>
								<TD>
								1.
								<TD>
								CLOSED
								<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
								<TD>LISTEN
								</TD>
							<TR>
								<TD>
								2.
								<TD>
								SYN-SENT
								<TD>
								--&gt;
								<TD>&lt;SEQ=100&gt;&lt;CTL=SYN&gt;
								<TD>
								...
								<TD>&nbsp;
									
								</TD>
							<TR>
								<TD>
								3.
								<TD>
								(дубликат)
								<TD>
								...<TD>&lt;SEQ=90&gt;&lt;CTL=SYN&gt;
								<TD>
								--&gt;
								<TD>SYN-RECEIVED</TD>
							<TR>
								<TD>
								4.
								<TD>
								SYN-SENT
								<TD>
								&lt;--<TD>
								&lt;SEQ=300&gt;&lt;ACK=91&gt;&lt;CTL=SYN,ACK&gt;
								<TD>
								&lt;--
								<TD>SYN-RECEIVED</TD>
							<TR>
								<TD>
								5.
								<TD>
								SYN-SENT
								<TD>
								--&gt;<TD>&lt;SEQ=91&gt;&lt;CTL=RST&gt;
								<TD>
								--&gt;
								<TD>LISTEN</TD>
							<TR>
								<TD>
								6.
								<TD><FONT color="#fff5ee">.</FONT>
								<TD>
								...<TD>
								&lt;SEQ=100&gt;&lt;CTL=SYN&gt;
								<TD>
								--&gt;
								<TD>SYN-RECEIVED</TD>
							<TR>
								<TD>
								7.
								<TD>
								SYN-SENT
								<TD>
								&lt;--<TD>
								&lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;
								<TD>
								&lt;--
								<TD>SYN-RECEIVED</TD>
							<TR>
								<TD>
								8.
								<TD>
								ESTABLISHED
								<TD>
								--&gt;<TD>
								&lt;SEQ=101&gt;&lt;ACK=401&gt;&lt;CTL=ACK&gt;
								<TD>
								--&gt;
								<TD>ESTABLISHED</TD>
							</TR>
						</TBODY></TABLE>
				</P>
				<P>
					<CENTER>Получение старого дубликата сигнала SYN
						<BR>
						Рисунок 9
					</CENTER>
				<P align="justify">
			</A>В качестве простого примера рассмотрим ситуацию с получением старых 
			дубликатов на <A href="tcp.htm#рис.9">рисунке 9. </A>
		На строке 3 старый дубликат сигнала SYN достигает программу TCP B. Последняя не 
		может определить, что это старый дубликат, и поэтому отвечает обычным образом 
		(строка 4).
		<P align="justify">
		Программа TCP A обнаруживает ошибочное значение в поле ACK и поэтому возвращает 
		сигнал RST (перезагрузка). При этом значение поля SEQ выбирается таким образом, 
		чтобы сделать сегмент правдоподобным. Про грамма TCP B по получении сигнала RST 
		переходит в состояние LISTEN. Когда на строке 6 сигнал SYN, действительный, а 
		не устаревший, достигает программу TCP B, процесс синхронизации происходит 
		нормально. Если же сигнал SYN на строке 6 достигает программу TCP B прежде 
		сигнала RST, может возникнуть более сложная комбинация обмена с посылкой RST в 
		обоих направлениях.
		<P>
			<CENTER>Наполовину открытые соединения и другие аномалии
			</CENTER>
		<P align="justify">
		Уже установившееся соединение называется "наполовину открытым", если одна из 
		программ TCP закрыла соединение, или отказалась от него. Причем сделала это на 
		своем конце, не предупредив своего партнера. Также такая ситуация может 
		возникнуть, если нарушена синхронизация на концах линии вследствие сбоя, 
		приведшего к потере информации в памяти. Если на таких соединениях делается 
		попытка отправить данные в каком-либо направлении, то автоматически 
		производится перезагрузка соединения. Однако предполагается, что наполовину 
		открытые соединения являются редкостью, а процедура восстановления применяется 
		в сети весьма умеренно.
		<P align="justify">
		Если на конце A соединение считается уже несуществующим, а клиент на конце B 
		пытается послать данные, то это приведет к тому, что программа TCP на конце B 
		получит контрольное сообщение о перезагрузке. Такое сообщение показывает 
		программе TCP на конце B, что что-то неправильно и ей предлагается 
		ликвидировать это соединение.
		<P align="justify">Предположим, что два клиента в точках A и B общаются друг с 
			другом, и в этот момент происходит крах, приводящий к потере информации в 
			памяти у программы TCP на конце A. В зависимости от операционной системы, 
			обслуживающей программу TCP A, вероятно, будет задействован некий механизм 
			исправления ошибки. Когда программа TCP A будет запущена вновь, она, вероятно, 
			вновь начнет свою работу с самого начала или же с инструкции преодоления сбоя. 
			В результате, программа A, вероятно, попытается открыть (OPEN) соединение или 
			послать информацию (SEND) через соединение, которое, как она полагает, является 
			открытым. В последнем случае от местной программы TCP (на конце A) будет 
			получено сообщение "соединение не открыто". При попытке установить соединение 
			программа TCP A будет посылать сегмент, содержащий сигнал SYN. Такой сценарий 
			приводит к ситуации, показанной на <A href="tcp.htm#рис.10">рисунке 10. </A>После 
			того, как программа TCP A потерпит крах, пользователь попытается повторно 
			открыть соединение. Программа TCP B тем временем продолжает полагать, будто 
			соединение остается открытым.</P>
		<A name="рис.10">
			<P>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD><FONT color="#fff5ee">.</FONT>
							<TD>
							TCP A
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>TCP B</TD>
						<TR>
							<TD>
							1.
							<TD>
							сбой
							<TD colSpan="3">
								<P ALIGN="center">
									(номер посылки 300, получения - 100)
								</P>
							<TD>&nbsp;
								
							</TD>
						<TR>
							<TD>
							2.
							<TD>
							CLOSED
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>ESTABLISHED</TD>
						<TR>
							<TD>
							3.
							<TD>
							SYN-SENT
							<TD>
							--&gt;<TD>&lt;SEQ=400&gt;&lt;CTL=SYN&gt;
							<TD>
							--&gt;
							<TD>(??)</TD>
						<TR>
							<TD>
							4.
							<TD>
							(!!)
							<TD>
							&lt;--<TD>
							&lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=SYN&gt;
							<TD>
							&lt;--
							<TD>ESTABLISHED</TD>
						<TR>
							<TD>
							5.
							<TD>
							SYN-SENT
							<TD>
							--&gt;
							<td>&lt;SEQ=100&gt;&lt;CTL=RST&gt;
							<TD>
							--&gt;
							<TD>(ликвидация!!)</TD>
						<TR>
							<TD>
							6.
							<TD>
							SYN-SENT
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>CLOSED</TD>
						<TR>
							<TD>
							7.
							<TD>
							SYN-SENT
							<TD>
							--&gt;<TD>&lt;SEQ=400&gt;&lt;CTL=SYN&gt;
							<TD>
							--&gt;
							<TD><FONT color="#fff5ee">.</FONT></TD>
						</TR>
					</TBODY></TABLE>
			</P>
			<P>
				<CENTER>Обнаружение наполовину открытого соединения
					<BR>
					Рисунок 10
				</CENTER>
			<P align="justify">
		</A>Когда на строке 3 сигнал SYN достигает программу TCP B, находящуюся в 
		синхронизированном состоянии, а пришедший сегмент находится за пределами окна, 
		программа TCP B отвечает на это его подтверждением, показывает номер очереди, 
		который она желает получить (ACK=100). Программа TCP A, видя, что сегмент на 
		строке 4 не подтвердил отправленную ею информацию, фиксирует отсутствие 
		синхронизации и посылает сигнал перезагрузки (RST), поскольку обнаружено, что 
		соединение является открытым наполовину. На строке 5 программа TCP B 
		ликвидирует соединение. Программа TCP A будет продолжать попытки установить 
		соединение.
		<P align="justify">Теперь возникшая проблема решается простым подтверждением трех 
			путей <A href="tcp.htm#рис.7">(рисунок 7).</A>
		<P align="justify">Другой интересный сюжет имеет место, если программа TCP A терпит 
			крах, а программа TCP B, полагая, что находится в состоянии синхронизации, 
			пытается послать данные. Эта ситуация показана на<A href="tcp.htm#рис.11"> рисунке 
				11. </A>
		<P align="justify">
			В этом случае данные, отправленные программой TCP B, и пришедшие на программу 
			TCP A (строка 2). будут отвергнуты, поскольку используемого ими соединения не 
			существует. На основании этого программа TCP A посылает сигнал RST. Как только 
			сигнал RST принят программой TCP B, он будет рассмотрен, а использованное 
			прежде соединение будет ликвидировано.</P>
		<A name="рис.11">
			<P><table border="1">
					<tr>
						<td><font color="#fff5ee">.</font>
						<TD>
						TCP A
						<TD colspan="3"><FONT color="#fff5ee">.</FONT>
						<TD>
							TCP B</TD>
					<TR>
						<TD>
						1.<TD>
						сбой
						<TD colspan="3">
							<P ALIGN="center">
								(номер посылки 300, получения - 100)
							</P>
						<TD>&nbsp;</TD>
					<TR>
						<TD>
						2.<TD>
						(??)
						<TD>
						&lt;--<TD>
						&lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;DATA=10&gt;&lt;CTL=SYN&gt;
						<TD>
						&lt;--
						<TD>
							ESTABLISHED</TD>
					<TR>
						<TD>
						3.<TD>
						
						<TD>
						--&gt;<TD>&lt;SEQ=100&gt;&lt;CTL=RST&gt;
						<TD>
						--&gt;
						<TD>
							(ликвидация!!)</TD>
					</TR>
				</table>
			</P>
			<P>
				<CENTER>Активная сторона приводит к обнаружению
					<BR>
					наполовину открытого соединения
					<BR>
					Рисунок 11
				</CENTER>
		</A>
		<P align="justify">На <A href="tcp.htm#рис.12">рисунке 12 </A>показано, что две 
			программы TCP - A и B - ,имея пассивное состояние, ждут сигнала SYN. Старый 
			дубликат сигнала, достигает программу TCP B (строка 2), запускает ее. 
			Возвращается сигнал SYN-ACK (строка 3) и заставляет программу TCP A 
			генерировать сигнал RST (на строке 3 сигнал ACK неприемлем). Программа TCP B 
			принимает команду перезагрузки и возвращается в пассивное состояние LISTEN.</P>
		<A name="рис.12">
			<P>
				<TABLE border="1">
					<TBODY>
						<TR>
							<TD><FONT color="#fff5ee">.</FONT>
							<TD>
							TCP A
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>TCP B</TD>
						<TR>
							<TD>
							1.
							<TD>
							LISTEN
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>LISTEN
							</TD>
						<TR>
							<TD>
							2.
							<TD>
							
							<TD>
							...
							<TD>&lt;SEQ=Z&gt;&lt;CTL=SYN&gt;
							<TD>
							--&gt;
							<TD>SYN-RECEIVED</TD>
						<TR>
							<TD>
							3.
							<TD>
							(??)
							<TD>
							&lt;--<TD>
							&lt;SEQ=X&gt;&lt;ACK=Z+1&gt;&lt;CTL=SYN,ACK&gt;
							<TD>
							&lt;--
							<TD>SYN-RECEIVED</TD>
						<TR>
							<TD>
							4.
							<TD><FONT color="#fff5ee">.</FONT>
							<TD>
							--&gt;
							<TD>&lt;SEQ=Z+1&gt;&lt;CTL=RST&gt;
							<TD>
							--&gt;
							<TD>возврат в LISTEN</TD>
						<TR>
							<TD>
							5.
							<TD>
							LISTEN
							<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
							<TD>LISTEN
							</TD>
						</TR>
					</TBODY></TABLE>
			</P>
			<P>
				<CENTER>Старый дубликат сигнала SYN инициирует перезагрузку
					<BR>
					на двух пассивных сокетах
					<BR>
					Рисунок 12
				</CENTER>
		</A>
		<P align="justify">
		Может быть множество других вариаций, которые могут быть объяснены 
		нижеописанными правилами для создания и обработки сигналов RST.
		<P>
			<CENTER>Создание сигнала перезагрузки
			</CENTER>
		<P align="justify">
		Согласно главному правилу, сигнал перезагрузки (RST) должен посылаться всякий 
		раз, когда приходит сегмент, который очевидным образом не предназначен для 
		данного соединения. Если непонятно, имеет ли место данный случай, следует 
		воздержаться от перезагрузки.
		<P align="justify">Можно выделить три группы состояний для соединения:
			<OL>
				<LI>
					<DIV align="justify">Если соединения не существует (CLOSED), то сигнал перезагрузки 
						посылается в ответ на любой пришедший сегмент, за исключением встречного 
						сигнала перезагрузки. В частности, сигналы SYN, адресованные на несуществующее 
						соединение, отвергаются именно таким образом.
					</DIV>
					<P align="justify">
					Если приходящий сегмент имеет флаг в поле ACK, то сегмент с сигналом 
					перезагрузки получает номер для очереди из поля ACK первого сегмента. В 
					противном случае сегмент с сигналом перезагрузки имеет нулевой номер очереди и 
					значение в поле ACK, равным сумме номера очереди пришедшего сегмента и его же 
					длины. Соединение остается в состоянии CLOSED.
					<P align="justify"></P>
				<LI>
					<DIV align="justify">Если соединение находится в каком-либо не синхронизированном 
						состоянии (LISTEN, SYN-SENT, SYN-RECEIVED), если какие-либо подтверждения 
						пришедшего сегмента еще не отправлены (сегмент несет неприемлемое значение в 
						поле ACK) или пришедший сегмент имеет уровень безопасности/закрытости не 
						соответствующий уровню и защите данного соединения, то отправляется сигнал 
						перезагрузки.
					</DIV>
					<P align="justify">
					Если наш сигнал SYN не был подтвержден, а уровень приоритета пришедшего 
					сегмента больше запрошенного уровня, то либо будет увеличен местный уровень 
					приоритета (если это приемлемо для пользователя и системы), либо будет послан 
					сигнал перезагрузки. Или же если уровень приоритета пришедшего сегмента меньше 
					запрошенного, то обработка будет продолжена далее, как если бы уровень был 
					таким же (если чужая программа TCP не может повысить уровень приоритета до 
					нашего, то это будет отмечено в следующем отправляемом ею сегменте, тогда и 
					будет закрыто соединение). Если наш сигнал SYN получил подтверждение (возможно 
					в пришедшем к нам сегменте), то уровень приоритета пришедшего сегмента должен 
					точно соответствовать мест ному уровню. Если последнее условие не выполняется, 
					посылается сигнал перезагрузки.
					<P align="justify">
					Если приходящий сегмент несет сигнал ACK, то сигнал перезагрузки будет иметь 
					номер в очереди, соответствующий номеру сигнала ACK в пришедшем сегменте. В 
					противном случае сигнал перезагрузки будет иметь нулевой номер очереди, а 
					сигнал ACK - номер, равный сумме номера пришедшего сегмента и его же длины. 
					Соединение не меняет своего состояния.
					<P align="justify"></P>
				<LI>
					<DIV align="justify">Если соединение находится в синхронизированном состоянии 
						(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST ACK, 
						TIME-WAIT), то любой неприемлемый сегмент (не попадающий в окно номеров 
						очереди, несущий неправильный номер подтверждения) должен приводить к появлению 
						сегмента с пустым полем подтверждения, содержащего текущий номер в очереди на 
						посылку, а также подтверждение, указывающее на следующий ожидаемый с этого 
						соединения номер. Соединение остается в своем прежнем состоянии.
					</DIV>
					<P align="justify">
					Если пришедший сегмент имеет уровень защиты, изоляции или приоритета, не 
					соответствующий местному уровню соединения, то отправляется сигнал 
					перезагрузки, а соединение переходит в состояние CLOSED. Сигнал перезагрузки 
					имеет номер очереди, соответствующий номеру сигнала ACK в пришедшем сегменте.
					<P></P>
				</LI>
			</OL>
			<CENTER>Обработка сигнала на перезагрузку
			</CENTER>
		<P align="justify">
		Для всех состояний, кроме SYN-SENT, все сегменты с сигналом перезагрузки (RST) 
		проходят проверку полей SEQ. Сигнал перезагрузки признается, если его номер 
		очереди попадает в окно. В состоянии же SYN SENT (сигнал RST получен в ответ на 
		посылку инициирующего сигнала SYN), сигнал RST признается, если поле ACK 
		подтверждает ранее сделанную посылку сигнала SYN.
		<P align="justify">
		Получатель сигнала RST сперва проверяет его, и лишь потом меняет свое 
		состояние. Если получатель находился в состоянии LISTEN, то он игнорирует 
		сигнал. Если получатель находился в состоянии SYN- RECEIVED, то он возвращается 
		вновь в состояние LISTEN. В иных случаях получатель ликвидирует соединение и 
		переходит в состояние CLOSED. Если получатель находится в каком-либо ином 
		состоянии, то он ликвидирует соединение и прежде чем перейти в состояние 
		CLOSED, оповещает об этом своего клиента.
		<P>
			<CENTER><A name="3.5"><B>2.5 Закрытие соединения</B>
					<P align="justify">
			</CENTER>
		</A>Состояние CLOSED означает "я не имею данных для передачи". Конечно, 
		закрытие полнодуплексного соединения является предметом множества 
		интерпретаций, поскольку не очевидно, как интерпретировать в соединении 
		сторону, получающую информацию. Мы решили интерпретировать CLOSE в упрощенной 
		манере. Клиент, находящийся в состоянии CLOSE, может все еще получать 
		информацию (RECEIVE) до тех пор, пока партнер тоже не сообщит, что переходит в 
		состояние CLOSE. Таким образом, клиент может изящно завершить работу на своем 
		конце соединения. Программа протокола TCP гарантированно получит все буферы с 
		информацией, отправленные до того, как соединение было закрыто. Поэтому 
		клиенту, не ждущему информации с соединения, следует лишь ждать сообщения об 
		успешном закрытии этого соединения, что означает, что все данные получены 
		программой TCP, принимающей информацию. Клиенты должны сохранять уже закрытые 
		ими для чтения информации соединения до тех пор, пока программа протокола TCP 
		не сообщит им, что такой информации больше нет.
		<P>Особое значение имеют три случая:
			<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR vAlign="top">
						<TD>
						1)
						<TD>клиент инициирует закрытие соединения, дав команду своей программе протокола 
							TCP.</TD>
					<TR vAlign="top">
						<TD>
						2)
						<TD>закрытие соединения начинается с того, что напарник посылает сюда управляющий 
							сигнал FIN. .</TD>
					<TR>
						<TD>
						3)
						<TD>оба клиента дают команду на закрытие одновременно.
						</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P align="justify"><STRONG>Случай 1. Местный клиент инициирует закрытие</STRONG>
			<BR>
			В этом случае создается сегмент с сигналом FIN и помещается в очередь 
			сегментов, ждущих отправления. После этого программа TCP уже не будет принимать 
			от этого клиента каких-либо команд на отправление данных по закрытому 
			соединению, а сама переходит в со стояние FIN-WAIT-1. Тем не менее, в этом 
			состоянии еще возможно получение клиентом данных с этого соединения. Все 
			сегменты, стоящие в очереди, и сам сегмент с сигналом FIN будут в случае 
			необходимости посылаться напарнику вновь и вновь, пока не получат своего 
			подтверждения. .
		</P>
		<P align="justify">
		Когда программа TCP партнера подтвердит получение сигнала FIN, и сама отправит 
		сюда свой сигнал FIN, местная программа может подтвердить получение последнего. 
		Заметим, что программа TCP, получающая сигнал FIN, будет подтверждать его, но 
		не будет посылать своего собственного сигнала FIN до тех пор, пока ее клиент 
		тоже не закроет соединения.
		<P align="justify"><STRONG>Случай 2. Программа TCP получает из сети сигнал FIN</STRONG>
			<BR>
			Если из сети приходит невостребованный сигнал FIN, то принимающая его программа 
			TCP может подтвердить получение такого сигнала и оповестить своего клиента о 
			том, что соединение закрыто. Клиент ответит командой CLOSE, по которой 
			программа TCP может после пересылки оставшихся данных послать партнеру сигнал 
			FIN. После этого программа TCP ждет, пока не придет подтверждение на 
			отправленный ею сигнал FIN, после чего она ликвидирует соединение. Если 
			подтверждения не было по истечении отведенного времени, то соединение 
			ликвидируется в принудительном порядке, о чем дается сообщение клиенту.
		</P>
		<P align="justify"><STRONG>Случай 3. Оба клиента закрывают соединение одновременно</STRONG>
			<BR>
			Одновременное закрытие соединения клиентами на обоих концах приводит к обмену 
			сегментами с сигналом FIN. Когда все сегменты, стоящие в очереди перед 
			сегментом с FIN, будут переданы и получат подтверждение, каждая программа TCP 
			может послать подтверждение на полученный ею сигнал FIN. Обе программы по 
			получении этих подтверждений будут ликвидировать соединение.
		</P>
		<P>
			<TABLE border="1">
				<TBODY>
					<TR>
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						TCP A
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>TCP B</TD>
					<TR>
						<TD>
						1.
						<TD>
						ESTABLISHED
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>ESTABLISHED</TD>
					<TR>
						<TD>
						2.
						<TD>(Close)<BR>
						FIN-WAIT-1
						<TD>
						--&gt;<TD>
						&lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;
						<TD>
						--&gt;
						<TD>CLOSE-WAIT</TD>
					<TR>
						<TD>
						3.
						<TD>
						FIN-WAIT-2
						<TD>
						&lt;--<TD>
						&lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;
						<TD>
						&lt;--
						<TD>CLOSE-WAIT</TD>
					<TR>
						<TD>
						4.
						<TD>(Close)<BR>
						TIME-WAIT
						<TD>
						&lt;--<TD>
						&lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=FIN,ACK&gt;
						<TD>
						&lt;--
						<TD>LAST-ACK</TD>
					<TR>
						<TD>
						5.
						<TD>
						TIME-WAIT
						<TD>
						--&gt;<TD>
						&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;
						<TD>
						--&gt;
						<TD>CLOSED</TD>
					<TR>
						<TD>
						6.
						<TD>(2 MSL)
							<BR>
						CLOSED
						<TD colSpan="4"><FONT color="#fff5ee">.</FONT></TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<CENTER>
			<P>Нормальная процедура закрытия
				<BR>
			Рисунок 13
		</CENTER>
		<P>
			<TABLE border="1">
				<TBODY>
					<TR>
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						TCP A
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>TCP B</TD>
					<TR>
						<TD>
						1.
						<TD>
						ESTABLISHED
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>ESTABLISHED</TD>
					<TR>
						<TD>
						2.
						<TD>
						(Close)
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>(Close)</TD>
					<TR>
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						FIN-WAIT-1
						<TD>
						--&gt;<TD>
						&lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;
						<TD>
						...
						<TD>FIN-WAIT-1</TD>
					<TR>
						<TD colSpan="2"><FONT color="#fff5ee">.</FONT>
						<TD>
						&lt;--<TD>
						&lt;SEQ=300&gt;&lt;ACK=100&gt;&lt;CTL=FIN,ACK&gt;
						<TD>
						&lt;--
						<TD><FONT color="#fff5ee">.</FONT></TD>
					<TR>
						<TD colSpan="2"><FONT color="#fff5ee">.</FONT>
						<TD>
						...<TD>
						&lt;SEQ=100&gt;&lt;ACK=300&gt;&lt;CTL=FIN,ACK&gt;
						<TD>
						--&gt;
						<TD><FONT color="#fff5ee">.</FONT></TD>
					<TR>
						<TD>
						3.
						<TD>
						CLOSING
						<TD>
						--&gt;<TD>
						&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;
						<TD>
						...
						<TD>CLOSING</TD>
					<TR>
						<TD colSpan="2"><FONT color="#fff5ee">.</FONT>
						<TD>
						&lt;--<TD>
						&lt;SEQ=301&gt;&lt;ACK=101&gt;&lt;CTL=ACK&gt;
						<TD>
						&lt;--
						<TD><FONT color="#fff5ee">.</FONT></TD>
					<TR>
						<TD colSpan="2"><FONT color="#fff5ee">.</FONT>
						<TD>
						...<TD>
						&lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;
						<TD>
						--&gt;
						<TD><FONT color="#fff5ee">.</FONT></TD>
					<TR>
						<TD>
						4.
						<TD>
						TIME-WAIT
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>TIME-WAIT</TD>
					<TR>
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						(2 MSL)
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>(2 MSL)</TD>
					<TR>
						<TD><FONT color="#fff5ee">.</FONT>
						<TD>
						CLOSED
						<TD colSpan="3"><FONT color="#fff5ee">.</FONT>
						<TD>CLOSED</TD>
					</TR>
				</TBODY></TABLE>
			<CENTER>
				<P>Процедура одновременного закрытия соединения с обоих концов
					<BR>
					Рисунок 14</P>
			</CENTER>
		<P>
			<DIV align="center"><A name="3.7"><B>2.6 Передача данных </B>
			</DIV>
			<DIV align="justify">&nbsp;</DIV>
		<P align="justify">
		</A>Когда соединение установлено передача данных осуществляется с помощью 
		обмена сегментами. Т.к. сегменты могут быть потеряны в результате ошибок 
		(например, ошибки в контрольной сумме) или перегрузки сети, то программа 
		протокола TCP использует механизм повторной посылки (по истечении определенного 
		времени) с тем, чтобы убедиться в получении каждого сегмента. В главе, 
		посвященной номерам очередей, обсуждалось, как программа TCP в сегментах 
		осуществляет проверку номе ров очередей и номеров подтверждения на предмет их 
		корректности.
		<P align="justify">
		Отправитель данных с помощью значения переменной SND.NXT отслеживает следующий 
		номер в очереди, подлежащий отправке. Получатель данных с помощью переменной 
		RCV.NXT отслеживает следующий номер, прибытие которого он ожидает. В переменную 
		SND.UNA отправитель данных помещает значение самого старого номера, который был 
		отправлен, но еще не получил подтверждения. Если бы поток данных моментально 
		иссяк, а все отправленные данные получили подтверждение, то тогда бы все эти 
		при переменные содержали одинаковое значение.
		<P align="justify">
		Когда отправитель информации создает и посылает некий сегмент, он увеличивает 
		значение переменной SND.NXT. Адресат по получении сегмента увеличивает значение 
		переменной RCV.NXT и отправляет подтверждение. Когда программа TCP, пославшая 
		данные, получает подтверждение, она увеличивает значение SND.UNA. Разность в 
		значениях этих переменных является мерой, характеризующей задержку сегментов в 
		сети. Величина, на которую надо всякий раз осуществлять приращение значения 
		этих переменных, является длиной поля данных в сегменте. Заметим, что поскольку 
		соединения находятся в состоянии ESTABLISHED, все сегменты, в дополнение к 
		собственно данным, должны нести некую информацию о подтверждении ранее 
		отправленных сегментов.
		<P align="justify">
		Запрос пользователя о закрытии соединения (CLOSE) подразумевает использование 
		функции проталкивания, что осуществляется с помощью контрольного флага FIN 
		приходящем сегменте.
		<P>
			<CENTER>Контрольное время повторной посылки
				<P align="justify">
			</CENTER>
		Вследствие непостоянства сетей, составляющих единую объединенную систему, и 
		большого числа клиентов, пользующихся услугами TCP соединений, существует 
		необходимость в динамическом определении контрольного времени повторной 
		посылки. В качестве иллюстрации здесь приводится одна из процедур определения 
		этого времени.
		<P align="justify">
		Пример процедуры измерения контрольного времени для повторной посылки сегментов 
		Во-первых, измерьте время, прошедшее между посылкой октета данных, имеющего 
		некий определенный номер в очереди, и получение подтверждения, указывающего 
		наряду с другими и на этот номер (посылаемые сегменты не обязаны 
		соответствовать полученным сегментам).
		<P align="justify">Измеренная временная задержка - это время обращения (Round Trip 
			Time - RTT). Следующий шаг - вычисление усредненного времени обращения 
			(Smoothed Round Trip Time - SRTT):<BR>
			SRTT = (ALPHA * RSTT) + ( (1-ALPHA) * RTT)
		</P>
		<P align="justify">Затем с помощью найденного значения определяется контрольное 
			время повторной посылки (Retransmission Timeout - RTO):<BR>
			RTO = min[ UBOUND, max[ LBOUND, (BETA * SRTT) ]]
			<BR>
			где
			<BR>
		</P>
		<P>
			<TABLE>
				<TBODY>
					<TR>
						<TD>
						UBOUND
						<TD>- верхний предел контрольного времени (например, 1 мин),
						</TD>
					<TR>
						<TD>
						LBOUND
						<TD>- нижний предел (например, 1 сек).</TD>
					<TR>
						<TD>
						ALPHA
						<TD>- фактор сглаживания (например, от 0.8 до 0.9),
						</TD>
					<TR>
						<TD>
						BETA
						<TD>- фактор изменения задержки (например, от 1.3 до 2.0).</TD>
					</TR>
				</TBODY></TABLE>
		</P>
		<P>
			<CENTER>Передача срочной информации
			</CENTER>
		<P align="justify">
		Механизм срочной передачи протокола TCP предназначен для того, чтобы клиент, 
		отправляющий данные, мог побудить получателя принять некую срочную информацию, 
		а также позволить программе TCP, принимающей данные, информировать своего 
		клиента, когда вся имеющаяся на настоящий момент информация будет получена.
		<P align="justify">
		Данный механизм позволяет помечать некую точку в потоке данных как конец блока 
		срочной информации. Когда в программе TCP, принимающей данные, данная точка 
		окажется впереди индикатора номера в очереди получения (RCV.NXT), эта программа 
		TCP должна дать команду своему клиенту перейти в "срочный режим". Когда номер в 
		очереди получения догонит срочный указатель в потоке данных, программа TCP 
		должна дать команду клиенту прийти в "нормальный режим". Если срочный указатель 
		сменит свое положение, когда клиент находится в "срочном режиме", последний не 
		узнает об этом.
		<P align="justify">
		Данный метод использует поле флага срочности, который присутствует во всех 
		передаваемых сегментах. Единица в поле контрольного флага URG означает, что 
		задействовано поле срочности . Чтобы получить указатель этого поля в потоке 
		данных, необходимо дополнить его номером рассматриваемого сегмента в очереди. 
		Отсутствие флага URG означает отсутствие у отправителя не посланных срочных 
		данных.
		<P align="justify">
		При указании срочности клиент должен также послать по крайней мере один октет 
		данных. Если клиент, помещающий данные, дополнительно закажет функцию 
		проталкивания, то передача срочной информации ждущему ее процессу многократно 
		ускорится.
		<P>
			<CENTER>Управление окном
			</CENTER>
		<P align="justify">
		Окно, посылаемое с каждым сегментом, указывает диапазон номеров очереди, 
		которые отправитель окна (он же получатель данных) готов принять в настоящее 
		время. Предполагается, что такой механизм связан с наличием в данный момент 
		места в буфере данных.
		<P align="justify">
		Указание окна большого размера стимулирует передачу. Но если при шло большее 
		количество данных, чем может быть принято программой TCP, данные будут 
		отброшены. Это приведет к излишним пересылкам информации и ненужному увеличению 
		нагрузки на сеть и программу TCP. Указание окна малого размера может ограничить 
		передачу данных скоростью, которая определяется временем путешествия по сети 
		после каждого посылаемого сегмента.
		<P align="justify">
		Такие механизмы протокола позволяют программе TCP заявлять большое окно, но 
		впоследствии объявлять окна намного меньшего размера и не принимать такое 
		большое количество данных. Такое, так называемое, сокращение окна выглядит 
		довольно обескураживающе. Принцип устойчивости диктует, чтобы программа 
		протокола TCP не сокращала сама окно, но была бы готова к таким действиям со 
		стороны другой программы TCP.
		<P align="justify">
		Программа TCP, посылающая данные, должна быть готова принять от клиента и 
		передать по сети по крайней мере один октет новых данных, даже если окно 
		отправления равно нулю. Программа TCP должна периодически повторно посылать 
		данные другой программе TCP, даже если окно нулевое. В случае нулевого окна 
		рекомендуется использовать интервал повторной посылки в две минуты. Такие 
		повторные посылки важны для того, чтобы гарантировать, что в случае, когда одна 
		из двух программ TCP имеет нулевое окно, открытие этого окна будет 
		гарантированно сообщено партнеру.
		<P align="justify">
		Когда программа TCP, получающая данные, имеет нулевое окно, но к ней приходит 
		сегмент, то эта программа должна послать подтверждение и указать, какой 
		следующий номер в очереди она ожидает и какое у нее окно в настоящий момент 
		(окно нулевое).
		<P align="justify">
		Программа TCP пакует предназначенные к в пересылке данные в сегменты, 
		заполняющие текущее окно. Однако она не может перепаковать уже имеющиеся 
		сегменты в очереди на повторную посылку. Такая перепаковка хоть и не 
		обязательна, но может быть полезна.
		<P align="justify">
		В соединении, имеющем односторонний поток данных, информация об окне будет 
		передаваться с сегментами подтверждения, а они будут все иметь одинаковый номер 
		очереди. Поэтому не будет способа восстановить их очередность при получении. 
		Это не является серьезной проблемой, но может случайно привести к получению 
		информации об окне из какого-нибудь устаревшего сообщения. Во избежание такой 
		проблемы должен осуществляться отсев и информация об окне должна браться из 
		сегментов, имеющих самый большой номер в очереди (это сегменты, чей номер 
		подтверждения больше или равен наибольшему из ранее полученных номеров). 
		Процедура управления окном оказывает значительное влияние на характеристики 
		коммуникаций.
		<P align="justify">
		<P align="center">Пожелания по управлению окном
		</P>
		<P align="justify">
		Выделение очень малого окна приводит к передаче данных очень маленькими 
		сегментами, тогда как лучший режим осуществляется при использовании сегментов 
		большего размера.
		<P align="justify">
		Чтобы избежать применения малых окон, получателю данных предлагается 
		откладывать изменение окна до тех пор, пока свободное место не составит X 
		процентов от максимально возможного в памяти для этого соединения (где X может 
		быть от 20 до 40).
		<P align="justify">
		Другой совет, чтобы не посылать малые сегменты, состоит в том, чтобы 
		отправитель не спешил с посылкой данных, пока окно не станет достаточно 
		большим. Но если клиент дает команду на использование функции проталкивания, то 
		данные следует немедленно отправлять, даже если это будет осуществляться малым 
		сегментом.
		<P align="justify">
		Заметим, что во избежание ненужных повторных пересылок не нужно медлить с 
		посылкой подтверждений. Стратегия может заключаться в посылке подтверждения при 
		получении сегмента малого размера (без обновления информации об окне), затем 
		посылается другое подтверждение с новой информацией об окне, если последнее 
		расширяется.
		<P align="justify">
		Сегмент, посылаемый для проверки нулевого окна, может инициировать разбивку 
		передаваемых данных на все более и более мелкие сегменты. Если сегмент, 
		содержащий единичный октет данных и отправленный для проверки нулевого окна, 
		получен, то он займет один октет в имеющемся в данный момент окне. Если же 
		программа TCP просто посылает столько данных, сколько может, всякий раз, когда 
		окно ненулевое, то передаваемые данные будут разбиваться на большие и малые 
		сегменты. По истечении некоторого времени случающиеся паузы в выделении окна 
		получателем данные приведут к разбивке больших сегментов на многочисленные и 
		уже не столь большие пары. Итак, по прошествии некоторого времени передача 
		данных будет осуществляться преимущественно малыми сегментами.
		<P align="justify">
			Предложение состоит в том, чтобы реализации протокола TCP активно пытались 
			объединить малые окна в более крупные, поскольку механизмы управления окном 
			стремятся ввести много малых окон в простейших реализациях протокола.</P>
		<P align="center"><A name="3.6"><B> 2.7&nbsp;Ссылки</B>
				<CENTER></CENTER>
				<TABLE border="0">
					<TBODY>
						<TR vAlign="top">
							<TD><A name="1">[1] </A>
							<TD>Cerf, V., and R. Kahn, "A Protocol for Packet Network Intercommunication", IEEE 
								Transactions on Communications, Vol. COM-22, No. 5, pp 637-648, May 1974.</TD>
						<TR vAlign="top">
							<TD><A name="2">[2] </A>
							<TD>Postel, J, (ed.) "Internet Protocol DARPA Internet Program Protocol 
								Specification", RFC 791, USC/Information Sciences Institute, September 1981.
							</TD>
						<TR vAlign="top">
							<TD><A name="3">[3] </A>
							<TD>Dalal, Y. and C.Sunshine, "Connection Management in Transport Protocols", 
								Computer Networks, Vol. 2, No. 6, pp. 454-473, December 1978.
							</TD>
						<TR vAlign="top">
							<TD><A name="4">[4]</A>
							<TD>Posterl, J, "Assigned Numbers", RFC 790, USC/Information Sciences Institute, 
								September 1981.
							</TD>
						</TR>
					</TBODY></TABLE>
			</A>
	</BODY>
</HTML>
