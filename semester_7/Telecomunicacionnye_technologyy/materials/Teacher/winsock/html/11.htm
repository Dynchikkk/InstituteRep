<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://doc.mpv.ru/steps/mfc/net/socket/11.html -->
<HTML><HEAD>
<META http-equiv=Content-Type content="text/html; charset=koi8-r">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY text=black vLink=blue aLink=red link=blue bgColor=white><LINK 
href="11.files/1.css" type=text/css rel=stylesheet><FONT color=red>
<H2 align=center>Шаг 11 - Четыре этапа транзакции HTTP</H2></FONT>
<H3>Установка соединения </H3>Перед обменом информации клиент и сервер должны 
иметь соединение <B>TCP</B>, именно по этому мы устанавливали соединение 
<B>Internet</B>. То есть нам нужен был <B>IP</B> адрес. Как различаются разные 
протоколы ? Для этого используются уникальные номера. Эти номера называются 
портами. Для <B>HTTP</B> стандартный порт <B>80</B>. Вот список наиболее 
известных портов. <PRE>FTP 	21
TELNET 	23
SMTP	25
TFTP	69
Gopher	70
Finger	79
HTTP	80
</PRE>Порты делятся на 2 части. С адресами ниже <B>1024</B> привелигированные вы 
не сможете создать свой порт с номером меньше <B>1024</B>. Мы с вами в нашей 
программе указывали номер порта создавая сокет. <PRE>#define PORT_ADDR 80
........
<B>socketaddr.sin_port = htons(PORT_ADDR);</B>
if (bind(servsocket,(LPSOCKADDR)&amp;socketaddr,sizeof(socketaddr)) == SOCKET_ERROR)
</PRE>
<H3>Запрос Клиента</H3>Каждый запрос клиента передаваемый на <B>WEB</B>-сервер 
начинается с метода, за которым следует <B>URL</B> объекта. Далее идет 
информация о версии протокола <B>HTTP</B> и символ возврата каретки с переводом 
строки. Метод - это команда клиента к серверу с целью указания запроса. Мы его 
не обрабатывали. Научимся :-) 
<H3>Ответ сервера</H3>После получения сообщения сервер отвечает сообщением 
<B>HTTP</B>. Затем идет код статуса и тема ответа из 3 цифр, потом 
дополнительная информация, а потом тело ответа. Если обратите внимание, что мы с 
Вами это упустили. Ну и ладно исправим потом. А вот данные мы посылали так. <PRE>CString buff="\nСайт шаг за шагом представляет\n\r\n";
HTTPServer.SendData(buff.GetBuffer(1000));
..........
void CSeverWinSock::SendData(LPSTR buff)
{
int Errors;
Errors = send(clientsocket,(LPSTR)buff,lstrlen(buff),0);
if (Errors == SOCKET_ERROR) AfxMessageBox("Error Send");
}
</PRE>
<H3>Сервер разрывает соединение</H3>После отправки сообщения сервер имеет 
возможность разорвать соединение. Вот так мы это делали закрывая сокет. <PRE> closesocket(HTTPServer.clientsocket);
</PRE>
<P>
<HR>

<CENTER><FONT size=2><A 
href="http://doc.mpv.ru/steps/mfc/net/socket/10.html">Предыдущий шаг</A> | <A 
href="http://doc.mpv.ru/steps/mfc/net/socket/12.html">Следующий Шаг</A> | <A 
href="http://doc.mpv.ru/steps/mfc/net/socket/socket.html">Оглавление</A></FONT></CENTER>
<HR>

<CENTER><FONT size=2>By <A href="mailto:kaev@yandex.ru">Artem</A>.</CENTER>
<SCRIPT src="11.files/banners.htm"></SCRIPT>
<!-- ><!-- "><!-- '><!-- --></TEXTAREA></FORM></TITLE></COMMENT></A>
<DIV></DIV></SPAN></ILAYER></LAYER></IFRAME></NOFRAMES></STYLE></NOSCRIPT></TABLE></SCRIPT></APPLET></FONT>
<STYLE>#bn {
	DISPLAY: block
}
#bt {
	DISPLAY: block
}
</STYLE>
</BODY></HTML>
