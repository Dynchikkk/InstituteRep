<html>

<!-- Mirrored from www.habarov.spb.ru/lab_net/Network_Simulate/NetSimulate/lab4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 09 Dec 2017 18:26:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=WINDOWS-1251" /><!-- /Added by HTTrack -->
<head>
<title>Моделирование функционирования IP-сетей - Протоколы TELNET И SNMP"</title>
<LINK href="../style.css" rel=stylesheet type=text/css>
<script SRC="../menu.js">
     document.write("Included JS file not found");
</script> 
</head>

<body class="MainText">
<script>Main_Menu();</script>

<h5>1. Лабораторная работа №4. "Уровень приложений: протоколы TELNET И SNMP"</h5>
<ul><li>Цель работы:
<p>На примере протоколов SNMP-DPI и TELNET ознакомиться с уровнем приложений стека протоколов TCP/IP.
</li><li>Порядок выполнения работы:
  <ol><li>На компьютере К1 запустить SNMP агента. Порт и имя группы
  доступа выбираются студентом.
  </li><li>компьютера К2 отправить запрос(ы) get, и получить переменные
   П1, П2, П3. Сравнить полученные значения с реальными;
  </li><li>С компьютера К2 отправить запрос(ы) getnext для переменных П1,
   П2, П3. Объяснить полученные результаты;
  </li><li>На компьютере К1 с помощью диалога "Set TCP/IP Properties"
  изменить IP адрес, маску подсети и шлюз по умолчанию. С
  компьютера К2 с помощью запросов set вернуть K1 в исходное
  состояние. Проверить результаты посредством SNMP;
  </li><li>На компьютере K2 запустить TELNET сервер. Порт и пароль
  выбрать самостоятельно;
  </li><li>С компьютера К3 по протоколу TELNET подключиться к компьютеру
  К2. Удалить все значения из таблицы маршрутизации и ARP
  таблицы. Добавить в таблицу маршрутизации и ARP таблицу записи
  необходимые для корректной работы компьютера К2;
  </li><li>С помощью команды TELNET-сервера snmp запустить SNMP агента
  на К3. Проверить работоспособность snmp-сервера: с компьютера
  К2 попытаться получить значение SNMP переменной П2;
  </li></ol>
</li><li>В отчет необходимо включить схему сети, все вводимые параметры
  (порт, имя группы доступа и др.), отправляемые запросы и получаемые ответы.
  Для протокола TELNET необходимо привести сообщения
  выводимые в TELNET-консоль.
</li></ul>





<h5>4.1. Пример выполнения лабораторной работы</h5>

<ul><li>Исходные данные: 
  <ul><li>Заданная конфигурация сети имеет вид, приведенный на рис.1.1.
         <script>myRisBig("1_0.gif",'Рис. 1.1. Структура исследуемой сетевой архитектуры.',0);</script>
    </li><li>Сеть между маршрутизаторами R1 и R2: 172.168.100.0.
	</li><li>Компьютер PC1 имеет IP-адрес 172.168.0.2.
    </li><li>Компьютер PC2 имеет IP-адрес 10.0.0.2.
  </li></ul>

</li><li>Задание:
  <ol><li>На компьютере PC1 запустить SNMP агента.
     </li><li>С компьютера PC2 отправить запрос(ы) get, и получить
	  переменные ip.address_eth0, device.hostname.
    </li><li>На компьютере PC2 запустить Telnet-сервер.
    </li><li>С компьютера PC1 по протоколу Telnet подключиться к
      компьютеру PC2. Удалить все значения из кэша ARP.
	  Добавить туда статическую запись для узла PC1.
    </li></ol>
</li></ul>

<br>
<p><b>Порядок выполнения будет следующим:</b></p>
<!--1-->
  <ol><li>Запустим на PC1 SNMP агент с параметрами: 
  	<ul><li> Порт на котором SNMP агент будет ожидать пакеты: 161.
    </li><li>Имя группы доступа для SNMP агента: defgroup.
	</li></ul>

<!--2-->
  </li><li>Выполним с PC2 запрос SNMP-агенту на PC1 со следующими
  параметрами:
  	<ul><li> IP адрес компьютера на котором установлен SNMP агент: 172.168.0.2.
    </li><li>порт на котором SNMP агент ожидает пакеты: 161;
    </li><li>SNMP запрос: get.
    </li><li>SNMP переменные: ip.address_eth0; device.hostname.
    </li><li>Имя группы доступа: defgroup.
	</li></ul>
    <p>Результаты запроса будут выведены в консоль:
<pre class="preText">
PC2 Received getResponse:
'IP.Address_Eth0=172.168.0.2', 'Device.Hostname=PC1'
</pre>

<!--3-->
  </li><li>Запустим Telnet-сервер со следующими параметрами:
  	<ul><li>Порт, на котором Telnet-сервер будет ожидать пакеты: 23.
    </li><li>Пароль для доступа к Telnet: 234.
	</li></ul>

<!--4-->
  </li><li>Запустим Telnet-клиент с параметрами:
  	<ul><li>IP адрес Telnet сервера: 10.0.0.2.
    </li><li>Порт, на котором Telnet-сервер ожидает пакеты: 23.
	</li></ul>
    <p>В ответ на приглашение к авторизации в системе необходимо ввести
    имя пользователя root и пароль 234. После входа в систему будет
    выведено приглашение командной строки:
<pre class="preText">
pc1 #
</pre>

   <p>Просмотрим записи в таблице маршрутизации:
<pre class="preText">
pc1 # arp -a
Internet Address Physical Address Type
10.0.0.1 A2:2A:55:20:75:42 Dynamic
</pre>

   <p>Как видно из вывода команды arp, в кэше находится лишь одна
    динамическая запись. Ее можно удалить следующим образом:
<pre class="preText">
pc1 # arp -d 10.0.0.1
</pre>

   <p>Для добавления статической записи в кэш ARP необходимо
   использовать ключ -s команды arp:
<pre class="preText">
pc1 # arp -s 10.0.0.1 A2:2A:55:20:75:42
</pre>

   <p>Таким образом была добавлена статическая запись для компьютера
   PC1. После завершения работы закрываем сеанс Telnet.
</li></ol>

<h5>4.2. Контрольные вопросы</h5>
</p><p>1. Для чего предназначен протокол SNMP?
</p><p>2. Если на SNMP запрос пришел отклик с установленным флагом
	ошибки, то какие переменные будут содержаться в этом отклике?
	Если в set запросе часть переменных имеет корректные значения,
	а часть некорректные то какие переменные объекта управления
	изменятся?
</p><p>3. Как обеспечивается защита в протоколе SNMP? Как вы думаете
	насколько безопасно применения протокола SNMP для управления
	реальной сетью? Что надо сделать для увеличения безопасности?
</p><p>4. Для чего предназначен протокол TELNET?
</p><p>5. Как работает протокол TELNET? Как обеспечивается безопасность
</p>

<hr /><br />

<h5>4.3. Варианты заданий</h5>
Внимание: Для всех вариантов заданий в качестве файла со схемой сети
использовать свой вариант лабораторной работы №1.

<script>variant(4,1,[
"Обозначения в задании: Компьютеры К1 – OFFICE2 pc1; К2 – Boss; К3 – Hacker.",
"SNMP переменные П1 – Counter.InputIP; П2 – IP.AllInterfaces; П3 – IP.Address_Eth0."
],"no");</script>

<script>variant(4,2,[
"Обозначения в задании: Компьютеры К1 – OFFICE1 pc4; К2 – BIGBOSS; К3 – M_CH_S.",
"SNMP переменные П1 – Counter.OutputIP; П2 – IP.ARPTable; П3 – IP.SubnetMask_Eth0."
],"no");</script>

<script>variant(4,3,[
"Обозначения в задании: Компьютеры К1 – OFFICE2 pc2; К2 – Hacker; К3 – Boss.",
"SNMP переменные П1 – Counter.ARP; П2 – IP.DefaultGateway; П3 – SNMP.CommunityName."
],"no");</script>

<script>variant(4,4,[
"Обозначения в задании: Компьютеры К1 – BIG BOSS; К2 – OFFICE1 pc1; К3 – OFFICE1 pc3.",
"SNMP переменные П1 – Counter.InputTCP; П2 – IP.Address_Eth0; П3 – SNMP.revision."
],"no");</script>

<script>variant(4,5,[
"Обозначения в задании: Компьютеры К1 – FileServer; К2 – Manager1; К3 – MegaBoss.",
"SNMP переменные П1 – Counter.OutputTCP; П2 – IP.SubnetMask_Eth0; П3 – IP.DefaultGateway."
],"no");</script>

<script>variant(4,6,[
"Обозначения в задании: Компьютеры К1 – PrintServer; К2 – Manager3; К3 – MicroBoss.",
"SNMP переменные П1 – Counter.ReceiveDuplicatedTCP; П2 – SNMP.CommunityName; П3 – IP.ARPTable."
],"no");</script>

<script>variant(4,7,[
"Обозначения в задании: Компьютеры К1 – Station1; К2 – Station4; К3 – Remote1.",
"SNMP переменные П1 – Counter.SendDuplicatedTCP; П2 – SNMP.revision; П3 – IP.AllInterfaces."
],"no");</script>

<script>variant(4,8,[
"Обозначения в задании: Компьютеры К1 – Station3; К2 – Remote1; К3 – Station2.",
"SNMP переменные П1 – Counter.SendAckTCP; П2 – Counter.InputIP; П3 – Device.MACaddress_Eth0."
],"no");</script>

<script>variant(4,9,[
"Обозначения в задании: Компьютеры К1 – PC1; К2 – PC2; К3 – PC4.",
"SNMP переменные П1 – Counter.InputUDP; П2 – Counter.OutputIP; П3 – Device.AvailableInterfaces."
],"no");</script>

<script>variant(4,10,[
"Обозначения в задании: Компьютеры К1 – PC2; К2 – PC3; К3 – PC4.",
"SNMP переменные П1 – Counter.OutputUDP; П2 – Counter.ARP; П3 – Device.AllInterfaces."
],"no");</script>

<!------------------------------------------------------------------------------------------------------------->
<br />
<hr>
<a name="menu"></a>
<h5>4.4. Краткие теоретические сведения</h5>
<div class="spisok">
	 <a href="#4-4-1">4.4.1. Уровень приложений стека протоколов TCP/IP.</a><br />
	 <a href="#4-4-2">4.4.2. Протокол SNMP.</a><br />
	 <a href="#4-4-3">4.4.3. Управляющая база данных MIB.</a><br />
	 <a href="#4-4-4">4.4.4. Протокол TELNET.</a><br />
</div>
<hr>

<!------------------------------------------------------------------------------------------------------- 4.4.1 --->
<a name="4-4-1"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>4.4.1. Уровень приложений стека протоколов TCP/IP.</h5> 
<!------------------------------------------------------------------------------------------------------- 4.4.1 --->
<p>Уровень приложений модели стека протоколов TCP/IP выполняет
следующие функции.
<ul><li>Обеспечивает управление диалогом между устройствами:
фиксирует какая из сторон является активной в настоящий момент,
предоставляет средства синхронизации и занимается отделением
данных одного приложения от данных другого приложения.

</li><li>Имеет дело с формой представления передаваемой по сети
информацией, не меняя при этом ее содержания. За счет этого
информация, передаваемая уровнем приложений одной системы,
всегда понятна уровню приложений другой системы. С помощью
средств данного уровня протоколы уровня приложений могут
преодолеть синтаксические различия в представлении данных.

</li><li>Может выполнять шифрование и дешифрование данных.

</li><li>Предоставляет набор разнообразных протоколов, с помощью
которых пользователи сети получают доступ к разделяемым
ресурсам, таким как файлы, принтеры или гипертекстовые Web-страницы,
а также организуют свою совместную работу, например,
с помощью протокола электронной почты.
</li></ul>

<p>Обобщая можно сказать, что прикладной уровень стека протоколов
TCP/IP объединяет все службы, предоставляемые системой
пользовательским приложениям. Прикладной уровень реализуется
программными системами, построенными в архитектуре 
клиент-сервер, базирующимися на протоколах нижних уровней. И в отличие
от протоколов остальных трех уровней стека протоколов TCP/IP, протоколы
прикладного уровня описывают работу конкретного приложения и
не способны к передаче данных по сети.

<p>Этот уровень постоянно
расширяется т.к. наравне со старым, прошедшими многолетнюю
эксплуатацию сетевыми протоколами типа TELNET, FTP, TFTP, DNS,
SNMP создаются сравнительно новые такие, например, как протокол
передачи гипертекстовой информации HTTP.

<p>Уровень приложений модели стека TCP/IP соответствует совокупности
трех уровней модели OSI: сеансового уровня, уровня представлений и
прикладного уровня. В этой главе рассмотрены два прикладных протокола:
SNMP – простой протокол управления сетью и TELNET – протокол для 
создания незащищенного соединения с серверным программным обеспечением.

<!------------------------------------------------------------------------------------------------------- 4.4.2 --->
<a name="4-4-2"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>4.4.2. Протокол SNMP.</h5> 
<!------------------------------------------------------------------------------------------------------- 4.4.2 --->
<p>С любой сети функционирует большое количество узлов,
маршрутизаторов и имеется широкий набор программных средств.
Сеть сохраняет работоспособность благодаря жесткой протокольной
регламентации, требующей разработки средств контроля и управления.
Функции диагностики сети возложены на ICMP, а функции управления
на SNMP (Simple Network Management Protocol – RFC1157). 

<p>Чаще всего управляющая прикладная программа воздействует на сеть по
цепочке: SNMP, UDP, IP, физическая сеть. Управление сетью – это
процесс управления отказами, контроля конфигураций, мониторинга
производительности, обеспечения защиты и учета деятельности в
сети передачи данных. Наиболее важным объектом управления
обычно является маршрутизатор. Каждому управляемому объекту
присваивается уникальный идентификатор.

<p>Протокол SNMP использует UDP в качестве транспортного протокола и
предназначен для использования сетевыми управляющими станциями.
Он позволяет управляющим станциям собирать информацию о
положении в сети. Протокол определяет формат данных, а их обработка
и интерпретация остаются на усмотрение управляющих станций или
менеджера сети.

<p>Приложения управления сетью называемые менеджерами, общаются
с программным обеспечением сетевых устройств, называемым
агентами. SNMP – это протокол типа "запрос-отклик", то есть на каждый
запрос, поступивший от менеджера, агент должен передать отклик. Под
запросом будем понимать передачу информации от менеджера к агенту
с целью получения параметров объекта управления. Под откликом
будем понимать ответ агента, на запрос менеджера, содержащий
требуемые параметры.

<p>Обмен данными между менеджером и агентом дает возможность менеджеру
собирать стандартный набор информации, который определен в базе данных
информации для управления сетью – MIB. Порция информации, существующая
в базе данных, называется объектом.

<p>Алгоритмы управления в сети обычно описывают в нотации ASN.1 (Abstract
Syntax Notation). Все объекты в сети разделены на 10 групп и
описаны в MIB: система, интерфейсы, обмены, трансляция адресов,
IP, ICMP, TCP, UDP, EGP, SNMP.

<ul><li>В группу "система" входит название и версия оборудования,
операционной системы, сетевого программного обеспечения и пр. 

</li><li>В группу "интерфейсы" входит число поддерживаемых
интерфейсов, тип интерфейса, работающего под управлением IP (Ethernet,
LAPB и т.д.), размер дейтаграмм, скорость обмена, адрес интерфейса.

</li><li>IP-группа включает время жизни дейтаграмм, информацию
о фрагментации, маски подсетей и т.д.

</li><li> В TCP-группу входит алгоритм повторной пересылки,
максимальное число повторных пересылок и пр.
</li></ul>

<p>Протокол SNMP имеет достаточно простую структуру и включает в себя
следующие команды:
<ul><li>Get-request используется менеджером для получения от агента
значения какого-либо параметра по его имени;

</li><li>GetNext-request используется для извлечения значения следующего
объекта (без указания его имени) при последовательном просмотре
таблицы объектов;

</li><li>Set используется менеджером для изменения значения какого-
либо объекта.
<p>С помощью команды Set происходит собственно
управление устройством. Агент должен понимать смысл значения
объекта, который используется для управления устройством, и
на основании этих значений выполнять реальное управляющее
воздействие – отключить порт, установить IP адрес и т.п.
<p>Команда Set пригодна также для установки условия, при
выполнении которого агент SNMP должен послать менеджеру
соответствующее сообщение. Может быть определена реакция
на такие события, как инициализация агента, рестарт агента,
обрыв связи, восстановление связи, неверная аутентификация,
потеря ближайшего маршрутизатора и др. Если происходит любое
из этих событий, то агент инициализирует прерывание (trap).
Если запросом Set устанавливаются значения сразу нескольких
объектов, то в случае ошибки все объекты останутся без изменений;

</li><li>Get-response обеспечивает передачу ответа на команды Get-request,
GetNext-request или Set от агента SNMP менеджеру. Get-response
возвращает значения запрошенных объектов, только в
случае успешного выполнения команд Get, GetNext или Set;

</li><li>Trap используется агентом для сообщения менеджеру о
возникновении особой ситуации.
</li></ul>

<p>Схема иллюстрирующая обмен данными между SNMP менеджером
и SNMP агентом представлена на рис. 4.2.
 
 <script>myRisBig("4_2.gif",'Рис. 4.2. Схема запросов/откликов SNMP.',0);</script>
 
<p>Прямоугольниками с числами обозначены порты на которых менеджер и/или
агент ожидает дейтаграммы пользователя. Обычно SNMP агент использует
161 порт для ожидания запросов get, get-next или set, а SNMP менеджер
– 162 порт для ожидания прерываний (trap). Объектом управления
является любое сетевое устройство поддерживающее протокол SNMP,
на котором запущен SNMP агент.

<p>В последнее время широкое распространение получила идеология
распределенного протокольного интерфейса DPI (Distributed Protocol
Interface). В этом случае для транспортировки SNMP-запросов
используется не только UDP, но и TCP-протокол. Это дает возможность
применять SNMP-протокол не только в локальных сетях.

<p>Форматы SNMP-DPI-запросов (версия 2.0) описаны в документе RFC1592.
На рис. 4.3 изображены форматы SNMP-DPI сообщений, вкладываемых в
UDP-дейтаграммы для запросов Get, GetNext или Set.

 <script>myRisBig("4_3.gif",'Рис. 4.3. Форматы сообщений протокола SNMP.',0);</script>

На рис. 5.2 прописными буквами латинского алфавита обозначены
поля, которые содержат следующие данные:
<ul><li>A – длина сообщения, без первых двух байтов;
</li><li>B – текущая версия протокола (для SNMPv2 это значение равно 2);
</li><li>C – минимальная версия протокола совместимая используемой версией
(для SNMPv2 это значение равно 2);
</li><li>D – версия модификации основного протокола (в первой редакции
протокола SNMPv2 это значение равно 0);
</li><li>E – идентификатор сообщения, т.е. уникальное число, характеризующее
отдельное сообщение посланный агенту и позволяющее связывать пары
запрос-отклик (это необходимо при использовании UDP, т.к. возможна
потеря пакетов);
</li><li>F – тип сообщения может принимать значения: SNMP_DPI_GET для get-
запроса, SNMP_DPI_GETNEXT для getnext-запроса, SNMP_DPI_SET
для set-запроса;
</li><li>G – длина поля "имя группы доступа";
</li><li>H – имя группы доступа – содержит последовательность символов,
которая является пропуском при взаимодействии менеджера и объекта
управления (обычно это поле содержит 6-байтовую строку public);
</li><li>I – идентификатор группы объекта управления – содержит
последовательность чисел, определяющую путь по дереву MIB до
объекта управления (последовательность должна заканчиваться
значением null);
</li><li>J – идентификатор объекта управления – лист MIB дерева, путь
до которого определяет идентификатор группы объекта управления
(идентификатор должен заканчиваться значением null);
</li><li>K – тип SNMP переменной, например: SNMP_TYPE_Integer32, SNMP_
TYPE_IpAddress, SNMP_TYPE_OCTET_STRING;
</li><li>L – длина поля "значение SNMP переменной";
</li><li>M – значение SNMP переменной соответствующего типа;
</li><li>N – статус ошибки – определяет причину ошибки и может принимать
следующие значения:
   <ul><li>noError(0) – нет ошибок;
   </li><li>tooBig(1) – объект не может уложить отклик в одно сообщение;
   </li><li>noSuchName(2) – в операции указана неизвестная переменная;
   </li><li>badValue(3) – в команде set использована недопустимая величина
    или неправильный синтаксис;
   </li><li>readOnly(4) – менеджер попытался изменить константу;
   </li><li>genErr(5) – прочие ошибки;
   </li><li>noAccess(6) – имя группы доступа содержащееся в сообщении и
   установленное на агенте не совпадают;
   </li><li>wrongType(7) – использован неправильный тип SNMP переменной;
   </li><li>wrongLength(8) – одно из полей длины не соответствует действительности;
   </li></ul>
</li><li>O – индекс ошибки – порядковый номер SNMP переменной, которая
привела к ошибке;

</li><li>P – в случае необходимости возможна запись дополнительных SNMP
переменных, т.е. пар: идентификатор группы(I), идентификатор
объекта(J);

</li><li>Q – в случае необходимости возможна запись дополнительных SNMP
переменных со значениями, т.е. последовательностей состоящих из пяти
полей:
<p>1. идентификатор группы(I),
<p>2. идентификатор объекта(J),
<p>3. тип SNMP переменной(K),
<p>4. длина поля "значение SNMP переменной"(L),
<p>5. значение SNMP переменной(M).
</li></ul>

<p>На рисунке числа и буквы над полями пакета обозначают смещение
соответствующего поля от начала пакета в байтах. А числа и буквы под
полями пакета обозначают длину соответствующего поля. Для краткости
записи были введены следующие обозначения:
<p>L1 – длина поля "имя группы доступа";
<p>L2 – длина поля "идентификатор группы объекта управления";
<p>L3 – длина поля "идентификатор объекта управления";
<p>L4 – длина поля "значение SNMP переменной";
<p>X = 10+L1+L2+L3;
<p>Y = 15+L2+L3.
<p>Видно, что сообщения SNMP имеют достаточно простую структуру.
Это упрощает реализацию протокола, но ведет к тому, что имя группы
доступа, предназначенное для ограничения доступа к SNMP агенту, ни
как не шифруется и передается по сети в открытой форме.


<!------------------------------------------------------------------------------------------------------- 4.4.3 --->
<a name="4-4-3"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>4.4.3. Управляющая база данных MIB.</h5> 
<!------------------------------------------------------------------------------------------------------- 4.4.3 --->
5.1.2. Управляющая база данных MIB
<p>Вся управляющая информация для контроля сетевых устройств
(маршрутизаторы, коммутаторы и т.п.) концентрируется в базе данных
MIB (Management Information Base, RFC1212, RFC1213). Каждая
порция информации, существующая в базе данных, называется
объектом. База данных информации для управления сетью содержит
объекты, которые нужны менеджеру для управления сетью.

<p>MIB выглядит как дерево с раздельными пунктами данных в качестве
выходов. Идентификатор объекта однозначно идентифицирует MIB-объект в
дереве. Объект обозначается, как последовательность чисел, разделенных
точкой. Объекты организуются иерархически и их части могут принадлежать
различным организациям.

<p>Верхний уровень идентификаторов MIB объектов установлен ISO/IEC.
Объекты более низкого уровня выделяются специальными организациями.
MIB-дерево постоянно расширяется, как результат экспериментов частных
разработок. Производители, например, могут определить свои личные
ветви для включения образов своих продуктов. Такие деревья MIB
не стандартизируются, а носят характер экспериментальных деревьев.

<p>Пример части такого дерева приведен на рис. 4.4. Из этого рисунка
видно, что например для узла snmpV2 идентификатор объекта будет: 1.3.8.1.6

 <script>myRisBig("4_4.gif",'Рис. 4.4. Дерево MIB - Management Information Base .',0);</script>

<!----------------------------------------------------------------------------------------------------- 4.4.4 --->
<a name="4-4-4"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>4.4.4. Протокол Telnet.</h5> 
<!----------------------------------------------------------------------------------------------------- 4.4.4 --->
<p>Для обеспечения удаленного доступа к сетевому устройству с
помощью командного интерпретатора используется протокол Telnet
(RFC854). Протокол Telnet – это сетевой протокол типа "клиент-
сервер". Telnet обеспечивает незащищенное соединение, т.е. все
данные передаются в открытой форме в том числе и пароли.

<p>Telnet использует TCP в качестве транспортного протокола. 
Общепринято, что Telnet-сервер ожидает соединения на 23 порту.
Telnet позволяет пользователю установить TCP-соединение с сервером и
затем передавать коды нажатия клавиш так, как если бы работа
проводилась на консоли сервера. Для входа в командный режим обычно
нужна аутентификация – ввод имени пользователя и его пароля.

<p>Telnet предлагает три услуги:
<ul><li>определяет сетевой виртуальный терминал (NVT – network virtual
terminal), который обеспечивает стандартный интерфейс доступа к
удаленной системе;
</li><li>включает механизм, который позволяет клиенту и серверу
согласовать опции обмена;
</li><li>обеспечивает соединение, при котором любая программа
(например FTP) может выступать в качестве клиента.
</li></ul>

<p>Протокол Telnet позволяет обслуживающей машине рассматривать
все удаленные терминалы как стандартные "сетевые виртуальные
терминалы" строчного типа, работающие в кодах ASCII, а также
обеспечивает возможность согласования более сложных функций.
Например, локальный или удаленный эхо-контроль, страничный
режим, высота и ширина экрана и т. д.. 

<p>На прикладном уровне над протоколом Telnet находится либо программа
поддержки реального терминала, либо прикладной процесс в обслуживающей
машине, к которому осуществляется доступ с терминала. Формат NTV
достаточно прост. Для данных используются 7-битовые ASCII коды. А
октеты из восьми бит зарезервированы для командных последовательностей.

<p>В упрощенном варианте протокол Telnet работает следующим
образом:
<ul><li>Между клиентом и сервером устанавливается TCP
соединение.
</li><li>Клиент посылает серверу символ перевода строки
для того, чтобы сервер знал что это клиент хочет соединится
по Telnet.
</li><li>В ответ сервер посылает приглашение ввода имени
(например: login) и ждет ввода имени пользователя. После ввода
сервер посылает приглашение ввода пароля (например: password) и
ждет ввода пароля.
</li><li>Если введенные имя и пароль корректны то Telnet-сервер
переходит в режим ввода.
</li><li>В этом режиме любой введенный текст пересылается удаленному
сетевому устройству. Ввод может производиться посимвольно или построчно.
При посимвольном режиме каждый введенный символ пересылается немедленно,
при построчном режиме отклик на каждое нажатие клавиши производится
локально, а пересылка выполняется лишь при нажатии клавиши &lt;Enter>.
</li></ul>

В режиме ввода Telnet-сервер выдает какое-либо приглашение (например:
Telnet>), и ожидает ввода команд пользователя. При вводе команды quit
сервер разрывает соединение.

<Script>Link_Menu("4")</Script>
</BODY>
<!-- Mirrored from www.habarov.spb.ru/lab_net/Network_Simulate/NetSimulate/lab4.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 09 Dec 2017 18:26:47 GMT -->
</HTML>
