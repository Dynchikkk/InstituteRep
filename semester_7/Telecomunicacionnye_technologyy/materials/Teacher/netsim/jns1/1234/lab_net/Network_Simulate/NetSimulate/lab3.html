<html>

<!-- Mirrored from www.habarov.spb.ru/lab_net/Network_Simulate/NetSimulate/lab3.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 09 Dec 2017 18:26:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=WINDOWS-1251" /><!-- /Added by HTTrack -->
<head>
<title>Моделирование работы IP-сетей - Сравнительный анализ протоколов TCP и UDP</title>
<LINK href="../style.css" rel=stylesheet type=text/css>
<script SRC="../menu.js">
     document.write("Included JS file not found");
</script> 
</head>

<body class="MainText">
<script>Main_Menu();</script>

<h5>3. Лабораторная работа №3. "Сравнительный анализ протоколов транспортного уровня TCP и UDP".</h5>
<ul><li>Цель работы:
<p>Провести анализ производительности протоколов TCP
и UDP для заданной конфигурации сети, и на основании
полученных результатов сделать заключение о том, какой протокол
предпочтительнее использовать.


</li><li>Порядок выполнения работы:
  <ol><li>В качестве схемы сети взять результат выполнения
соответствующего варианта лабораторной работы №1. Установить
коэффициенты прохождения пакетов согласно вашему варианту.
  </li><li>Протестировать отправку по UDP и по TCP 20 сообщений с K1 на K3.
  </li><li>Объяснить, анализируя вывод программы, какой протокол выгоднее
   использовать с точки зрения скорости доставки информации.
  </li><li>Протестировать отправку по UDP и по TCP 20 сообщений с K2 на K1.
  </li><li>Объяснить, анализируя вывод программы, какой протокол выгоднее
   использовать с точки зрения надежности доставки информации.
  </li><li>Подсчитать процент потерь пакетов. С учетом того, что должно
   теряться не более 7% пакетов. Объяснить, как привести сеть к
   требуемому лимиту по потерям.
  </li><li>Проанализировать время соединения, сделать вывод о том, какой
   протокол быстрее справился с поставленной задачей (необходимо
   учитывать требуемую надежность).
  </li><li>Определить состояние, при котором сеть начинает удовлетворять
   требованиям по потери пакетов. То есть подобрать такие значения
   коэффициентов пропускания, при которых будет теряться не более 7% пакетов.
   <p>Разрешается использовать диапазон значений длины 10, то есть
    можно найти интервал значений коэффициентов пропускания длины 10,
	где на нижней границе сеть не удовлетворяет критерию потерь пакетов,
	а на верхней заданный критерий удовлетворяется.
  </li></ol>
</li><li>Отчет должен содержать:
<p>Анализ производительности протоколов TCP и UDP для заданной
конфигурации сети при коэффициенте пропускания равном 100, расчет
процента потерь пакетов и
анализ производительности сети для обоих протоколов в условиях
недоброкачественных линий передач для обоих протоколов, оценку
удовлетворения сетью критерия по потере пакетов, анализ времени
соединения. В отчете также необходимо привести вывод о том, какой
протокол предпочтительнее использовать в данной конфигурации сети.
</li></ul>

<h5>3.1. Пример выполнения лабораторной работы.</h5>

<ul><li>Исходные данные: 
  <ul><li>Файл со схемой сети: lab4_sample.jfst.
    </li><li>Заданная конфигурация сети имеет вид, приведенный на рис.1.1.
         <script>myRisBig("1_0.gif",'Рис. 3.1. Структура исследуемой сетевой архитектуры.',0);</script>
	 
    </li><li>???? Сеть между маршрутизаторами R1 и R2: 172.168.100.0.
	</li><li>Компьютер PC1 имеет IP-адрес 192.168.0.1.
    </li><li>Компьютер PC2 имеет IP-адрес 192.168.0.2.
  </li></ul>

</li><li>Задание:
  <ol><li>Установить коэффициент пропускания всех линий равный 100.
    </li><li>Протестировать отправку по UDP и TCP 20 сообщений с PC2 на PC1.
    </li><li>Объяснить, анализируя вывод программы, какой протокол выгоднее
     использовать с точки зрения скорости доставки информации.
    </li><li>Установить коэффициент пропускания 65.
    </li><li>Протестировать отправку по UDP и TCP 20 сообщений с PC2 на PC1.
    </li><li>Объяснить, анализируя вывод программы, какой протокол выгоднее
    использовать с точки зрения надежности доставки информации.
    </li><li>Подсчитать процент потерь пакетов. С учетом того, что должно
   теряться не более 7% пакетов. Объяснить, как привести сеть к требуемой надежности.
    </li><li>Проанализировать время соединения, сделать вывод о том, какой
   протокол быстрее справился с поставленной задачей, учитывая требуемую надежность.
    </li><li>Определить состояние, при котором сеть начинает удовлетворять
   требованиям по потери пакетов. 
</li></ul>


<br>
<p><b>Порядок выполнения будет следующим:</b></p>
<ol><li>Убедимся, что коэффициент пропускания на всех линиях, в том
        числе между PC1 и PC2 равен 100.

</li><li>Выберем PC1 и запустим на нем UDP-приложение (UPD-сервер),
выбрав в качестве прослушиваемого порт 7.
Программа выдаст следующее сообщение:
<pre class="preText">
pc1 Application is now listening on port 7.
</pre>

</li><li>Выберем PC2 и пошлем через UDP-приложение 20 сообщений со
строкой "rsh" на PC1. Программа выдаст похожее на следующее
сообщение (для первого из двадцати сообщений):
<pre class="preText">
pc2 Start sending echo message 'rsh' to 192.168.0.1:7
pc2 Created UDP packet for 192.168.0.1:7.
pc1 Created ARP Response packet to 192.168.0.2
pc1 Sending packet from ProtocolStack (to 192.168.0.2).
pc2 Sending packet from ProtocolStack (to 192.168.0.1).
pc1 ProtocolStack received packet from local Interface.
pc1 Confirmed Packet is for this Network Layer Device.
pc1 UDP packet received from 192.168.0.2:3000 message:
"rsh". UDP Port 7 has status "busy" from now.
pc1 Application Recieving echo message 'rsh' from client.
pc1 Application Sending echo message 'rsh' to client.
pc1 Created UDP packet for 192.168.0.2:3000.
pc1 Sending packet from ProtocolStack (to 192.168.0.2).
pc2 ProtocolStack received packet from local Interface.
pc2 Confirmed Packet is for this Network Layer Device.
pc2 UDP packet received from 192.168.0.1:7 message: "rsh".
pc2 Recieving echo message 'rsh' from server.
pc1 Server closing connection. Now listening on 7.
pc1 Application is now listening on port 7.
</pre>

</li><li>Выберем меню статистики узла PC1 и проверим, сколько UDP
дейтаграмм он получил и отправил. Будет выведен следующий
результат:
<pre class="preText">
"Received UDP segments: 20" ,
</pre>
что означает, что получено 20 UDP дейтаграмм, и 
<pre class="preText">
"Sent UDP segments: 20", 
</pre>
что означает, что отправлено 20 UDP дейтаграмм. При заданных параметрах сети
процент потерь равен 0%, что удовлетворяет требованиям.

</li><li>Обнулим статистику узла PC1. Теперь установим коэффициент
пропускания линии между двумя узлами в значение, равное 65 и
снова пошлем с PC2 на PC1 20 UDP дейтаграмм.

</li><li>Выберем меню статистики узла PC1 и проверим, сколько UDP
дейтаграмм он получил и отправил. Будет, с большой вероятностью,
выведен следующий результат:
<pre class="preText">
"Received UDP segments: 13"
"Sent UDP segments: 13"
</pre>
что означает, что получено 13 UDP дейтаграмм, и отправлено 13 UDP дейтаграмм.

</li><li>Выберем меню статистики узла PC2 и проверим, сколько UDP
дейтаграмм он получил и отправил за все время нашего опыта.
Будет, с большой вероятностью, выведен следующий результат:
<pre class="preText">
"Received UDP segments: 26"
"Sent UDP segments: 40"
</pre>
что означает, что получено 26 UDP сегментов, и отправлено 40 UDP сегментов.
При заданных параметрах сети процент потерь больше, чем 7%, что не
удовлетворяет требованиям. Можно попробовать использовать протокол TCP.

</li><li>Выберем PC1 и запустим на нем TCP-приложение (TCP-сервер),
выбрав в качестве прослушиваемого порт 8.
Программа выдаст следующее сообщение:
<pre class="preText">
pc1 Application is now listening on port 8.
</pre>

</li><li>Выберем PC2 и пошлем через TCP-приложение 20 сообщений со
строкой "ppp" на PC1. Программа выдаст похожее на следующее
сообщение (для первого из двадцати сообщений, дошедших до PC1):
<pre class="preText">
pc2 Connecting to host 192.168.0.1:8.
Please wait...
pc2 TCP SYN-packet for 192.168.0.1:8.
pc1 ProtocolStack received packet from local Interface.
pc1 Created ARP Response packet to 192.168.0.2
pc1 Sending packet from ProtocolStack (to 192.168.0.2).
pc2 ProtocolStack received packet from local Interface.
pc2 Sending packet from ProtocolStack (to 192.168.0.1).
pc1 ProtocolStack received packet from local Interface.
pc1 TCP SYN-packet received from 192.168.0.2:3000.
TCP Port 8 has status "busy" from now.
pc1 Created TCP SYN-packet for 192.168.0.2:3000.
pc1 Sending packet from ProtocolStack (to 192.168.0.2).
pc2 TCP SYN-packet with ACK received from 192.168.0.1:8.
TCP Port 3000 still has status "busy".
pc2 Created TCP acknowledgement packet for 192.168.0.1:8.
pc2 Sending packet from ProtocolStack (to 192.168.0.1).
pc1 TCP packet with establishing connection ACK received
from 192.168.0.2:3000. Connection confirmed!
New TCP connection established!
pc2 Start sending echo message 'ppp' to 192.168.0.1:8
pc2 Created TCP data packet for 192.168.0.1:8.
pc2 Sending packet from ProtocolStack (to 192.168.0.1).
pc1 ProtocolStack received packet from local Interface.
pc1 Created TCP acknowledgement packet
for 192.168.0.2:3000.
pc1 Sending packet from ProtocolStack
(to 192.168.0.2).
pc2 ProtocolStack received packet from local Interface.
pc2 TCP packet with establishing connection ACK
received from 192.168.0.1:8. Connection confirmed!
pc1 TCP packet with data received from 192.168.0.2:3000.
Passing data to application program.
pc1 Recieving echo message 'ppp' from client.
pc1 Sending echo message 'ppp' to client.
</pre>

</li><li>Выберем меню статистики узла PC1 и проверим, сколько TCP
сегментов он получил и отправил. Будет выведен следующий
результат:
<pre class="preText">
"Received TCP segments: 45",
"Sent TCP segments: 43",
"Sent TCP ACKs: 23",
</pre>
что означает, что отправлено 23 подтверждения, также будет нулевая
статистика по отосланным и принятым дубликатам.

<p>Выберем меню статистики узла PC2 и проверим, сколько TCP сегментов
он получил и отправил. Будет выведен следующий результат: 
<pre class="preText">
"Received TCP segments: 43",
"Sent TCP segments: 45",
"Sent TCP ACKs: 23",
</pre> что означает, что отправлено 23 подтверждения, также будет
нулевая статистика по отосланным и принятым дубликатам.

<p>Из этого можно сделать вывод о том, что для хорошей линии
передач излишне проводить загрузку канала подтверждениями о
получении сегментов, которые занимают около 50% сегментов,
задействованных в обмене информацией, однако, были доставлены
все 20 сообщений, что удовлетворяет требованиям по процентам потерь.

</li><li>Обнулим статистику узла PC1 и PC2. Теперь установим
коэффициент пропускания 60 и снова пошлем с PC2 на PC1 20
TCP сегментов.

</li><li>Выберем PC2 и пошлем через TCP-приложение 20 сообщений со
строкой "ppp" на PC1. Программа, в нашем случае, выдаст
следующее сообщение:
<pre class="preText">
pc2 Packet lost due to physical link problems!
pc1 Server awaiting connection timeout!
Now server is listening to port: 8.
pc2 Connection timeout! Closing connection to host: 192.168.0.1:8.
</pre>
<p>Это говорит о том, что на PC2 было закрыто подключение к PC1
и на PC1 было закрыто подключение к PC2, т.к. качество линий
в данном примере не позволяет обмениваться информацией за
установленные программой на соединение промежутки времени.
При таких параметрах сеть не удовлетворяет требуемым условиям
по потерям: не более 7%.

<p>Если проверить статистику PC2, то можно увидеть, что было
отправлено 14 дубликатов, а получено 27 дубликатов. В то время,
как было отправлено 10 сегментов, а получено 11.

</li><li>Обнулим статистику узла PC1 и PC2. Теперь установим
коэффициент пропускания 88 и снова пошлем с PC2 на PC1 5 TCP сегментов.

</li><li>Выберем меню статистики узла PC2 и проверим, сколько TCP
сегментов он получил и отправил за время нашего опыта. Будет,
с большой вероятностью, выведен результат такой, что было
отправлено 14 TCP сегментов, 8 дубликатов, 6 подтверждений,
также было получено 10 сегментов.

</li><li>В результате анализа полученных результатов можно сделать
следующие выводы. В условиях качественного обеспечения
передачи UDP протокол показал себя с хорошей стороны, так
как все дейтаграммы дошли до адресатов. По времени было
затрачено 32ms. Не тратилось время на установление соединения
и на подтверждения получения пакетов.

<p>При плохом качестве линий не все пакеты дошли до пунктов назначения.
Оправданием использования UDP на плохих линиях может стать только то,
что информация за время задержки или потери станет неактуальна,
и ее можно не передавать. К примеру, видеоконференция через Интернет.

<p>Результаты проведенной работы по протоколу TCP говорят
о неэффективном использовании данным протоколом качественных
линий, так как дополнительное время тратится на подтверждение
пакетов, а также на установление и разрыв связи.
В условиях некачественной физической линии использование
TCP явно предпочтительнее, так как "потерявшиеся" сегменты
пересылаются и, в конечном счете, доходят до адресата.

<p>По времени передача по протоколу TCP заняла 344ms, что
в 10.75 раза больше, чем время затраченное при передаче
через UDP. Таким образом, применение протокола оправдано
в случаях, требующих гарантированного получения адресатом
всей посылаемой информации. К примеру, проверка электронной
цифровой подписи.

<p>Очевидно, что при использовании UDP сеть начинает
удовлетворять семипроцентному критерию по потере пакетов
при коэффициенте пропускания между узлами PC1 и PC2 не
менее 93%. Если использовать TCP, то критерий по потере пакетов
удовлетворяется при коэффициенте пропускания между узлами
PC1 и PC2, принадлежащем интервалу от 60 до 65.
</li></ol>

<h5>3.2. Контрольные вопросы.</h5>
</p><p>1. Какой из протоколов транспортного уровня обеспечивает надежную
доставку данных? За счет какого механизма обеспечивается
гарантия доставки?
</p><p>2. Назовите ситуации, в которых применение протокола UDP является
целесообразным.
</p><p>3. Назовите ситуации, в которых применение протокола TCP является
целесообразным.
</p><p>4. Чем в TCP обеспечивается ускорение работы по передаче данных?
</p><p>5. Сколькими пакетами обмениваются во время UDP-соединения
клиент и сервер?
</p><p>6. Сколькими пакетами обмениваются во время TCP-соединения
клиент и сервер? Какие существуют пакеты TCP?

</p>
<hr /><br />

<h5>3.3. Варианты заданий.</h5>
Внимание !!! Для всех вариантов заданий в качестве файла со схемой сети
использовать свой вариант лабораторной работы №1.

<script>variant(3,1,[
"Установите коэффициент прохождения пакетов между узлами Connector и Boss_R в 82.",
"Обозначения в задании: K1 – Boss, K2 – Hacker, K3 – OFFICE2 pc1."
],"no");</script>

<script>variant(3,2,[
"Установите коэффициент прохождения пакетов между узлами H_OFFICE1 и OFF_R в 71.",
"Обозначения в задании: K1 – BIG BOSS, K2 – M_CH_S, K3 – OFFICE1 pc4."
],"no");</script>

<script>variant(3,3,[
"Установите коэффициент прохождения пакетов между узлами Connector и Hacker в 75.",
"Обозначения в задании: K1 – Boss, K2 – Hacker, K3 – OFFICE2 pc1."
],"no");</script>

<script>variant(3,4,[
"Установите коэффициент прохождения пакетов между узлами BOSS HUB и R2 в 85.",
"Обозначения в задании: K1 – BIG BOSS, K2 – M_CH_S, K3 – OFFICE1 pc4."
],"no");</script>

<script>variant(3,5,[
"Установите коэффициент прохождения пакетов между узлами HBosses и center в 80.",
"Обозначения в задании: K1 – MegaBoss, K2 – Manager2, K3 – FileServer."
],"no");</script>

<script>variant(3,6,[
"Установите коэффициент прохождения пакетов между узлами HManagers и center в 78.",
"Обозначения в задании: K1 – Manager3, K2 – PrintServer, K3 – MicroBoss."
],"no");</script>

<script>variant(3,7,[
"Установите коэффициент прохождения пакетов между узлами Hub2 и R1 в 85.",
"Обозначения в задании: K1 – Station1, K2 – Remote1, K3 – Station2."
],"no");</script>

<script>variant(3,8,[
"Установите коэффициент прохождения пакетов между узлами Hub2 и R1 в 55.",
"Обозначения в задании: K1 – Station1, K2 – Remote1, K3 – Station2."
],"no");</script>

<script>variant(3,9,[
"Установите коэффициент прохождения пакетов между узлами Hub1 и R1 в 75.",
"Обозначения в задании: K1 – PC1, K2 – PC2, K3 – PC3."
],"no");</script>

<script>variant(3,10,[
"Установите коэффициент прохождения пакетов между узлами Hub1 и R1 в 65.",
"Обозначения в задании: K1 – PC1, K2 – PC2, K3 – PC3."
],"no");</script>

<!------------------------------------------------------------------------------------------------------------->
<br />
<hr>
<a name="menu"></a>
<h5>3.4. Краткие теоретические сведения.</h5>
<div class="spisok">
	 <a href="#3-4-1">3.4.1. Транспортный уровень: сравнение протоколов TCP и UDP.</a><br />
	 <a href="#3-4-2">3.4.2. Понятие портов.</a><br />
	 <a href="#3-4-3">3.4.3. Протокол транспортного уровня TCP.</a><br />
	 <a href="#3-4-4">3.4.4. Протокол транспортного уровня UDP.</a><br />
	 <a href="#3-4-5">3.4.5. Сравнение производительности TCP и UDP.</a><br />
</div>
<hr>

<!------------------------------------------------------------------------------------------------------- 3.4.1 --->
<a name="3-4-1"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>3.4.1. Транспортный уровень: сравнение протоколов TCP и UDP.</h5> 
<!------------------------------------------------------------------------------------------------------- 3.4.1 --->
<p>Поскольку на сетевом уровне не устанавливаются соединения,
то нет никаких гарантий, что все пакеты будут доставлены к
месту назначения в нужном порядке и без искажений информации,
содержащейся внутри. Задачу обеспечения надежной информационной
связи между двумя конечными узлами решает основной или
транспортный уровень стека TCP/IP.

<p>На этом уровне функционируют два протокола: протокол
управления передачей (Transmission Control Protocol) и протокол
дейтаграмм пользователя (User Datagram Protocol). Протокол TCP
обеспечивает надежную передачу сообщений между удаленными
прикладными процессами за счет образования логических соединений.
Обмен данными возможен в дуплексном режиме.

<p>TCP работает непосредственно над протоколом IP и использует
для транспортировки своих блоков данных потенциально ненадежный
протокол IP. Надежность передачи данных протоколом TCP достигается
за счет того, что он основан на установлении логических соединений
между взаимодействующими процессами. Поэтому ошибки протокола
IP не будут влиять на правильное получение данных.

<p>Протокол IP
используется протоколом TCP в качестве транспортного средства.
Перед отправкой своих блоков данных протокол TCP помещает их
в оболочку IP-пакета. При необходимости протокол IP осуществляет
любую фрагментацию и сборку блоков данных TCP.

<p>На рис. 3.2 показано, как процессы, выполняющиеся на двух
конечных узлах, устанавливают с помощью протокола TCP надежную
связь через составную сеть, все узлы которой используют для передачи
сообщений дейтаграммный протокол IP.

<script>myRisBig("3_2.gif",'Рис. 3.2. Логическое TCP–соединение.',0);</script>

<p>Протокол UDP позволяет передавать пакеты дейтаграммным
способом, как и протокол уровня межсетевого взаимодействия
IP. UDP выполняет только функции связующего звена между
сетевым протоколом и пользовательскими процессами, а также
многочисленными службами прикладного уровня.


<!------------------------------------------------------------------------------------------------------- 3.4.2 --->
<a name="3-4-2"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>3.4.2. Понятие портов.</h5> 
<!------------------------------------------------------------------------------------------------------- 3.4.2 --->
<p>Протоколы TCP и UDP взаимодействуют через межуровневые
интерфейсы с нижележащим протоколом IP и с вышележащими
протоколами прикладного уровня или приложениями. Таким образом,
после того, как пакет средствами протокола IP доставлен в компьютер-
получатель, данные необходимо направить конкретному
процессу-получателю. На одном компьютере могут выполняться несколько
процессов, более того, прикладной процесс может иметь несколько
точек входа, выступающих в качестве адреса назначения для пакетов
данных.

<p>Пакеты, поступающие на транспортный уровень, организуются
операционной системой в виде множества очередей к точкам входа
различных прикладных процессов. В терминологии TCP/IP такие
системные очереди называются портами. Таким образом, адресом
назначения, который используется протоколом TCP или UDP, является
идентификатор (номер) порта прикладной службы. Номер порта в
совокупности с номером сети и номером конечного узла однозначно
определяет прикладной процесс в сети. Этот набор идентифицирующих
параметров называется сокет (socket). Такое определение сокета
можно применять не только в терминах TCP/IP, но и, к примеру, в
терминах IPX.

<p>Назначение номеров портов прикладным процессам
осуществляется либо централизованно, если эти процессы
представляют собой популярные общедоступные службы (FTP – 21,
telnet – 23), либо локально для тех служб, которые еще не стали столь
распространенными, чтобы закреплять за ними стандартные номера.
Централизованное присвоение службам номеров портов выполняется
организацией Internet Assigned Numbers Authority (IANA). Эти номера
затем закрепляются и опубликовываются в стандартах Internet.

<p>Протокол TCP (также как и UDP) ведет для каждого порта
две очереди: очередь пакетов, поступающих в данный порт из
сети, и очередь пакетов, отправляемых данным приложением
через порт в сеть. Процедура обслуживания протоколом запросов,
поступающих от нескольких различных прикладных служб называется
мультиплексированием. Обратная процедура распределения
протоколом поступающих от сетевого уровня пакетов между набором
высокоуровневых служб, идентифицированных номерами портов,
называется демультиплексированием.

<!------------------------------------------------------------------------------------------------------- 3.4.3 --->
<a name="3-4-3"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>3.4.3. Протокол транспортного уровня TCP.</h5>
<!------------------------------------------------------------------------------------------------------- 3.4.3 --->
<p><b>Сегменты и потоки.</b></p>
<p>Единицей данных для протокола TCP является сегмент.
Информация, поступающая по протоколу TCP в рамках соединения от
протоколов более высокого уровня, рассматривается протоколом TCP
как неструктурированный поток байтов.

<p>Поступающие данные буферизуются. Для передачи на сетевой
уровень из буфера вырезается некоторая часть данных, – это и есть
сегмент. Отличительной особенностью TCP является то, что он
подтверждает получение не пакетов, а байтов потока.

<p>Сегменты, посылаемые через соединение могут иметь разный
размер. Оба участника соединения должны договариваться о
максимальном размере посылаемого сегмента. Размер выбирается
таким образом, чтобы при упаковке в IP-пакет сегмент помещался в
него целиком без фрагментации, т.е. размер максимального сегмента не
должен превосходить максимального размера поля данных IP-пакета.

<p><b>Соединения.</b></p>
<p>Для организации надежной передачи данных предусматривается
установление логического соединения между двумя прикладными
процессами. Т.к. соединение устанавливается через ненадежную среду
IP, то во избежание ошибочной инициализации соединений используется
специальная многошаговая процедура подтверждения связи.

<p>Соединение в протоколе TCP идентифицируется парой полных
адресов обоих взаимодействующих процессов – сокетов. Каждый
из взаимодействующих процессов может участвовать в нескольких
соединениях.

<p>Формально соединение – это набор параметров, характеризующий
процедуру обмена данными между двумя процессами. К таким
параметрам относятся:
<ul><li>Согласованные размеры сегментов.
</li><li>Объемы данных, которые разрешено передавать без подтверждения.
</li><li>Начальные и текущие номера передаваемых байтов.
</li></ul>

<p>В рамках соединения осуществляется обязательное подтверждение
правильности приема для всех переданных сообщений и, при
необходимости, выполняется повторная передача.

<p><b>Установка связи по протоколу.</b></p>
Этапы, из которых состоит процесс установки связи по протоколу
таковы:

<ul><li>Узел-отправитель запрашивает соединение, посылая сегмент с
установленным флагом синхронизации (SYN).
</li><li>Узел-адресат подтверждает получение запроса, отправляя обратно
сегмент с:
   <ul><li>установленным флагом синхронизации;
   </li><li>порядковым номером начального байта сегмента, который он
   может послать;
   </li><li>подтверждением, включающим порядковый номер следующего
   сегмента, который он ожидает получить.
   </li></ul>
</li><li>Запрашивающий узел посылает обратно сегмент с подтверждением
номера последовательности и номером своего подтверждения (ACK).

<p>Этап соединения проиллюстрирован на рис. 3.3
<script>myRisBig("3_3.gif",'Рис. 3.3. Зтап соединения по протоколу TCP,<br> SYN – пакет синхронизации, DB – блок данных, ACK – подтверждение.',0);</script>

<p>Из рис. 3.3 видно, что соединение выполняется в три этапа,
гарантирующих безошибочное установление связи.


<p><b>Реализация скользящего окна в TCP.</b></p>
<p>Во время установленного соединения правильность передачи
каждого сегмента должна подтверждаться квитанцией получателя.
Квитирование – это один из традиционных методов обеспечения
надежной связи. В протоколе TCP используется частный случай
квитирования – алгоритм скользящего окна.

<p>Идея состоит в том, что окно определено на множестве
нумерованных байтов неструктурированного потока данных,
поступающих с верхнего уровня и буферизуемых протоколом TCP. В
качестве квитанции получатель сегмента отсылает ответное сообщение
(сегмент), в которое помещается число на единицу большее, чем
максимальный номер байта в полученном сегменте. Это число называют
номером очереди.

<p>Особенности реализации скользящего окна в протоколе TCP
изображены на рис. 4.3.
<script>myRisBig("3_4.gif",'Рис. 3.4. Скользящее окно в протоколе TCP.',0);</script>

<p>Если размер окна равен W, а последняя
по времени квитанция содержала значение N, то отправитель может
посылать новые сегменты до тех пор, пока в очередной сегмент не
попадет байт с номером N + W. Этот сегмент выходит за рамки окна,
и передача в таком случае должна быть приостановлена до прихода
следующей квитанции.

<p>Выбор тайм-аута очередной квитанции – важная задача, результат
решения которой сильно влияет на производительность протокола TCP.
Время не должно быть слишком коротким – для исключения повторных
передач, снижающих полезную пропускную способность системы. И
время не должно быть слишком большим во избежание длинных
простоев, связанных с ожиданием несуществующей или потерявшейся
квитанции.

<p>Алгоритм определения тайм-аута. Для TCP он состоит в том,
что при каждой передаче сегмента засекается время до прихода
квитанции о его приеме (время оборота). Получаемые значения времен
оборота усредняются весовыми коэффициентами, возрастающими от
предыдущего значения к последующему, то есть усиливается влияние
последних замеров. В качестве тайм-аута выбирается среднее время
оборота, умноженное на специальный коэффициент. На практике
значение этого коэффициента должно превышать 2.

<p>В сетях с большим разбросом времени оборота при выборе тайм-аута
учитывается и дисперсия этой величины.

<p>Поскольку каждый байт пронумерован, то каждый из них может
быть опознан. Механизм опознавания является накопительным, поэтому
опознавание номера Х означает, что все байты с предыдущими
номерами уже получены.

<p>Этот механизм позволяет регистрировать появление дубликатов в
условиях повторной передачи.

<p>Нумерация байтов в пределах сегмента осуществляется так, чтобы
первый байт данных сразу вслед за заголовком имел наименьший
номер, а следующие за ним байты имели номера по возрастающей.

<p>Размер окна, посылаемый получателем данных с каждым
сегментом, определяет диапазон номеров очереди, которое отправитель
окна (он же получатель данных) готов принять в настоящее время. Такой
механизм связан с наличием в данный момент места в буфере данных.

<p>Чем больше окно, тем большую порцию неподтвержденных данных
можно послать в сеть. Но если пришло большее количество данных,
чем может быть принято программой TCP, данные будут отброшены.
Это приведет к излишним пересылкам информации и ненужному
увеличению нагрузки на сеть и программу TCP.
<p>C другой стороны,
указание малого размера окна может ограничить передачу данных
скоростью, которая определяется временем путешествия по сети
каждого сегмента в отдельности. Чтобы избежать применения малых
окон, получателю данных предлагается откладывать изменение окна до
тех пор, пока свободное место не составит 20-40 % от максимально
возможного объема памяти для этого соединения. Отправитель также
не должен спешить с посылкой данных, до того времени, пока окно не
станет достаточно большим.

<p>Разработчики протокола TCP предложили схему, согласно
которой при установлении соединения заявляется большое окно, но
впоследствии его размер существенно уменьшается.

<p>Если сеть не справляется с нагрузкой, то возникают очереди
в промежуточных узлах-маршрутизаторах и в конечных узлах-
компьютерах.

<p>При переполнении приемного буфера конечного узла
"перегруженный" узел отправляет TCP-квитанцию, помещая в нее
новый, уменьшенный размер окна. Если узел совсем отказывается
от приема, то в квитанции устанавливается нулевой размер окна.
Однако, даже после этого приложение может послать сообщение на
отказавшийся от приема порт, сопроводив его (сообщение) пометкой
"срочно". В такой ситуации порт обязан принять сегмент, даже если для
этого придется вытеснить их буфера уже находящиеся там данные.

<p>После приема квитанции с нулевым размером окна протокол-
отправитель время от времени делает контрольные попытки продолжить
обмен данными. Если приемник уже готов принимать информацию, то в
ответ он посылает квитанцию с указанием ненулевого размера окна.

<p>Другим проявлением перегрузки сети является переполнение
буферов в маршрутизаторах. В таких ситуациях они могут
централизованно изменить размер окна, посылая управляющие
сообщения некоторым конечным узлам, что позволяет им
дифференцированно управлять интенсивностью потока данных в
разных частях сети.

<!------------------------------------------------------------------------------------------------------- 3.4.4 --->
<a name="3-4-4"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>3.4.4. Протокол транспортного уровня UDP.</h5> 
<!------------------------------------------------------------------------------------------------------- 3.4.4 --->
<p><b>Общее описание.</b></p>
<p>Протокол User Datagram Protocol (UDP) обеспечивает
неориентированную на соединение службу доставки дейтаграмм
по принципу "максимального усилия". Это означает, что получение всей
дейтаграммы или правильной последовательности не гарантируется.
<p>Протокол UDP используется приложениями, не требующими
подтверждения. Обычно такие приложения передают данные
небольшого объема за один раз. К примеру, это: сервис имен Net-BIOS,
сервис SNMP, сервис дейтаграмм NetBIOS.

<p><b>Порты протокола UDP.</b></p>
<p>Для использования протокола UDP приложение должно знать IP-адрес
и номер порта получателя. Порт действует как мультиплексная
очередь сообщений, то есть он может получать несколько сообщение
одновременно.
<p>Важно отметить, что порты UDP отличаются от портов
TCP несмотря на использование одних и тех же значений номеров.

<p><b>Описание работы UDP.</b></p>
<p>Порт UDP легче всего представить в виде очереди. В большинстве
реализаций, когда прикладная программа "договаривается" с
операционной системой об использовании данного порта, операционная
система создает внутреннюю очередь, которая хранит приходящие
сообщения.
<p>Часто приложение может указать или изменить размеры
очереди. Когда узел получает дейтаграмму по UDP-протоколу,
он проверяет, нет ли порта назначения с таким номером среди
используемых портов. Если таких портов нет, UDP посылает ICMP-
сообщение об ошибке "порт недоступен" и уничтожает дейтаграмму.
Если есть, UDP добавляет новую дейтаграмму в очередь порта, где
прикладная программа может ее получить. Если очередь порта уже
переполнена, то тогда UDP уничтожает новую дейтаграмму.


<!------------------------------------------------------------------------------------------------------- 5.1 --->
<a name="3-4-5"></a>
<div class="begin">(<a href="#menu" >начало</a>)</div>
<h5>3.4.5. Сравнение производительности TCP и UDP.</h5> 
<!------------------------------------------------------------------------------------------------------- 5.1 --->
Последовательность действий (запросов и ответов) для протоколов
TCP и UDP представлена на рис. 3.5.

<script>myRisBig("3_5.gif",'Рис. 3.5. Последовательность запросов и ответов в TCP и UDP<br>SYN – пакет синхронизации, DB – блок данных, ACK – подтверждение.',0);</script>

Как видно из рисунка, передача началась в момент времени t0 по
обоим протоколам. К моменту времени
t1 протокол UDP завершил передачу, в то время, как по протоколу
TCP передача закончится только к моменту времени t2. Легко получить
разницу во времени времени &#916;t = t2-t1.
<p>Таким образом, протокол UDP работает
быстрее, чем TCP. Данные по протоколу UDP отсылаются получателю
друг за другом и не требуется получение подтверждения об успешной
доставке данных получателю. UDP не тратит время на установление
связи в несколько этапов.
<p>Стоит отметить, что TCP путем механизма
подтверждений гарантирует успешную доставку данных получателю,
в то время, как данные посланные через UDP могут и не дойти до
адресата.


<Script>Link_Menu("3")</Script>
</BODY>
<!-- Mirrored from www.habarov.spb.ru/lab_net/Network_Simulate/NetSimulate/lab3.htm by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 09 Dec 2017 18:26:47 GMT -->
</HTML>
