<html>
<head>
<title>Lab 3</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<style fprolloverstyle>A:hover {color: #FF0000}</style>
</head>
<body text=black bgcolor=#ffffff vlink=black link=black>
<!---------------- Title ------------>
<table border=0 CELLSPACING=0 cellpadding=0 width=99%>
<tr>
	<td align=center bgcolor=#FF9090><font color=white><big><b>Сети ЭВМ</td>
</tr>
</table>
<hr color=red size=1 width=99%>
<!---------------- Title Ends ------->
<br>
<!---------------- Nav Bar    ------->
<table width=99% cols=2 CELLSPACING=0 cellpadding=0>
<tr><td valign=top width=150>
    	<table width=140 CELLSPACING=0 cellpadding=5 border=1 bordercolor=red bordercolordark=white>
		<tr><td bgcolor=#FFe0E0><font size=-1><A href=lab1.html>Лабор. работа №1</A></td></tr>
		<tr><td><font size=-1><A href=lab2.html>Лабор. работа №2</A></td></tr>
		<tr><td bgcolor=#FFE0E0><font size=-1><b><A href=lab3.html>Лабор. работа №3</A></td></tr>
		<tr><td><font size=-1><A href=lab4.html>Лабор. работа №4</A></td></tr>
		<tr><td bgcolor=#FFE0E0><font size=-1><A href=cont_l2.html>Документация</A></td></tr>
		<tr><td><font size=-1><A href=arch.html>Архив</A></td></tr>
		<tr><td bgcolor=#FFE0E0><font size=-1><A href=vopr.html>Вопросы</A></td></tr>
	</td></tr>
	</table>
    </td>
    <td valign=top>
<!------------ Main Text ----- width=550 ------>
<CENTER><B><I><FONT SIZE=+1>Лабораторная работа №3</FONT></I></B>
<hr color=red size=1 width=70%>
Использование библиотеки MFC для работы с сокетами.</center>
<BR>
<BR>
<TABLE BORDER=0 WIDTH="99%" BGCOLOR="#FFE0E0"><TR><TD>Цель работы</TD></TR></TABLE>

<P>
Обеспечить передачу сообщений от клиента серверу по протоколам <A HREF="udp.htm" target="main">UDP</A> и <A HREF="transport.htm" target="main">TCP/IP</A>. При этом предусмотреть возможность закрытия данных (шифрования) при передачи их по сети между программами клиента и сервера. При этом необходимо использовать для работы с сокетами библиотеку классов MFC. 
<BR>
<BR>&nbsp;
<TABLE BORDER=0 WIDTH="99%" BGCOLOR="#FFE0E0"><TR><TD>Задание</TD></TR></TABLE>
<BR>


<b>Разработать программу клиента, которая должна:</b>
<BR>- запрашивать у пользователя адрес программы-сервера;
<BR>- устанавливать соединение с сервером;
<BR>- зашифровывать и расшифровывать данные;
<BR>- передавать на сервер данные;
<BR>- принимать ответ от сервера и выводить его на экран;
<BR>- закрывать соединение с сервером.
<BR>&nbsp;
<BR>
<b>Разработать программу сервера, которая должна: </b>
<BR>- ожидать запросов от программ клиентов на соединение; 
<BR>- устанавливать соединение с клиентами;
<BR>- зашифровывать и расшифровывать данные; 
<BR>- принимать данные от клиентов и выполнять их обработку; 
<BR>- пересылать результат обработки клиенту.
<BR>&nbsp;


<TABLE BORDER=0 WIDTH="99%" BGCOLOR="#FFE0E0"><TR><TD>Основные сведения</TD></TR></TABLE>

<p>В библиотеке MFC для работы с сокетами существуют два специальных класса: CAsyncSocket и CSocket, причем второй унаследован от первого.<br>
CAsyncSocket содержит основные функции для работы с сокетами, однако он не поддерживает блокирующие функции. Для работы с блокирующими функциями используется класс CSocket. 
<br>Перед началом работы необходимо подключить DLL WinSock с помощью функции WSAStartup(). Если при создании проекта был установлен флажок для использования Windows Sockets, то инициализация и подключение DLL производятся автоматически. 
<br>Для работы необходимо либо создать производный класс от CSocket и использовать объекты этого класса, либо использовать объекты класса CSocket. В первом случае возможно отслеживание возникающих событий с использованием асинхронных функций. 
<br>Создание сокета может производиться с помощью функций - членов класса Create и Socket. 
Функция Create используется для создания TCP сокетов. Прототип функции: 
<i><p>BOOL Create( UINT nSocketPort = 0, 
<p>int nSocketType = SOCK_STREAM, 
<p>LPCTSTR lpszSocketAddress = NULL )</i>
<p>Для создания серверного сокета нужно указать порт, для создания клиентского сокета можно вызвать функцию без параметров. 
<br>Функция возвращает TRUE в случае успеха, иначе - FALSE. Код ошибки получается с помощью функции GetLastError(). 
<br>При создании сокета с помощью функции Create вызывать функцию Bind не требуется. 
<br>Более универсальный способ, позволяющий создавать сокеты для любого протокола - с помощью функции - члена класса Socket. Прототип этой функции: 
<i><p>BOOL Socket(int nSocketType, 
<p>long lEvent, 
<p>int nProtocolType, 
<p>int nAddressFormat)</i>
<p>Здесь nSocketType - тип сокета (SOCK_STREAM, SOCK_DGRAM...); 
<br>lEvent - отслеживаемые события. Должно быть равно (FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE) 
<br>nProtocolType - используемый протокол 
<br>nAddressFormat - семейство адресов 
<br>Функция возвращает TRUE в случае успеха, иначе - FALSE. Код ошибки получается с помощью функции GetLastError(). 

<p>После вызова функции Socket требуется вызвать функцию - член класса Bind(). 
<br>Основные члены класса имеют имена, схожие с именами обычных функций для работы с сокетами, они также имеют сходные прототипы. Отличие в том, что не используется первый параметр - идентификатор сокета. Ниже перечислены такие функции: 

<i><p>Bind 
<br>Listen 
<br>Accept 
<br>GetPeerName 
<br>Connect 
<br>Send 
<br>Receive 
<br>SentTo 
<br>ReceiveFrom</i> 

<p>Функция Connect имеет кроме того еще одно представление, используемое для TCP сокетов: 
<i><p>BOOL Connect( LPCTSTR lpszHostAddress, UINT nHostPort )</i>
<p>Здесь lpszHostAddress - строка представляющая Интернет адрес. Допустимые адреса могут быть, например, такими: "123.45.67.89", "www.microsoft.com". 
nHostPort - номер порта TCP. Аналогичные представления имеют функции SendTo, ReceiveFrom, хотя эти функции не рекомендуется использовать при работе по TCP. 
<br>Закрытие сокета производится автоматически при удалении объекта. 

<p><i><A HREF="primer_lab3.html#primer1" target="main">Пример №1:  создание серверного сокета для TCP</A>
<br><A HREF="primer_lab3.html#primer2" target="main">Пример №2:  создание клиентского сокета для TCP</A>
<br><A HREF="primer_lab3.html#primer3" target="main">Пример №3:  создание IPX сокета</A>
<br><A HREF="primer_lab3.html#primer4" target="main">Пример №4:  прием данных от клиента по протоколу SPX</A>
<br><A HREF="primer_lab3.html#primer5" target="main">Пример №5:  передача данных на сервер по протоколу SPX</A>
</i>
<BR><BR>


<TABLE BORDER=0 WIDTH="99%" BGCOLOR="#FFE0E0"><TR><TD>Порядок выполнения лабораторной работы</TD></TR></TABLE>

<b>Загрузка, компилирование и выполнение проекта:</b><br>
1. Запустить <i>Microsoft Visual Studio 2005</i>. <br>
2. Выбрать в главном меню <i>File->Open->Project/Solution</i>. <br>
3. Указать путь к файлу <i>lab_3.sln</i> и далее нажать кнопку <i>Open</i>.  <br>
4. Слева в окне выбрать вкладку <i>Solution Explorer</i>. Все файлы проекта будут представлены в этом окне. Двойное нажатие левой кнопкой мыши на файле откроет его для редактирования в основной области экрана.<br>
<center><br>
 <IMG SRC="img/pic_3_Solution.JPG" ><br>
<b>Рисунок 1. Окно Solution Explorer</b>
</center><br>
5.Нажать кнопку <i>F7</i>. Проект будет откомпилирован целиком. Внизу в окне <i>Output</i> будет представлен отчет.<br> 
<center><br>
 <IMG SRC="img/pic_3_output.JPG" ><br>
<b>Рисунок 2. Окно Output</b>
</center><br>


Обратите внимание на последнюю строчку в проекте, в ней приведены результаты компиляции:<br><br>
<i>========== Build: 2 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========</i><br>
<br>
6. В папке <i>Debug</i> (или <i>Release</i>) будут созданы исполняемые файлы программ: <i>server.exe</i> – программа-сервер, <i>client.exe</i> – программа-клиент.<br>

<br><TABLE BORDER=0 WIDTH="99%" BGCOLOR="#FFE0E0"><TR><TD>Описание работы программ</TD></TR></TABLE><br>

<b>Программа-сервер<br></b><p>
<p>Перед запуском сервера (кнопка Start) необходимо выбрать протокол обмена данными в сети (TCP, UDP), и, если необходимо, включить симметричное шифрование (галка Protected) с указанием ключа. Аналогичный ключ должен быть указан на стороне клиента. После того, как настройки будут установлены, можно запустить сервер. Далее программа переходит в режим ожидания подключений от клиента (если выбран протокол TCP) или в режим приёма сообщений от клиента (если протокол - UDP).  В окне Log выводится информация о текущих событиях, а также сообщения от клиента. Остановка работы сервера производится нажатием кнопки Stop.<br>
 
<center><br>
 <IMG SRC="img/pic_3_server.JPG" ><br>
<b>Рисунок 3. Работа сервера</b>
</center><br>


<b>Программа-клиент<br></b><p>
<p>После запуска программы необходимо выбрать протокол для работы в сети (UDP/TCP) и ввести IP-адрес сервера. 
<br>При работе по протоколу UDP адрес сервера должен быть <i>127.0.0.2</i>. Для изменения IP адреса сервера и клиента необходимо перекомпилировать приложения с новыми значениями IP. При работе по протоколу TCP таких ограничений не накладывается. 
Шифрование проходит аналогично закрытию данных на сервере.
<br>При нажатии кнопки “Connect(TCP)” при выбранном TCP протоколе создается сокет и устанавливается соединение с сервером, а при UDP – только создается сокет. В поле “Message”  пользователь набирает сообщение и по нажатию кнопки “Send” осуществляется отправка с последующим разрывом соединения.
<br>
 
<center><br>
 <IMG SRC="img/pic_3_client.JPG" ><br>
<b>Рисунок 4. Работа клиента</b>
</center><br>


    </td>
</tr>
</table>
<hr size=1 color=red width=100%>
<table width=99% cellspacing=0 cellpadding=0><tr><td bgcolor=#FF9090><font color=white>&nbsp;&copy Пензенский Госудрственный Университет. 2009 г.</td>
</tr>
</td></tr>
</table>
</body>
</html>