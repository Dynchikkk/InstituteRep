	; шим с выходом на втором разряде порта C
	; таймер TMR2 считает число циклов выполнения команд (Fosc/4)

	list p=16F887          
	include "p16F887.inc"   ; подключаем определения регистров и констант

ct1	EQU 0x20              ; рабочая переменная: ct1 — счётчик повторений n
ct2	EQU 0x21              ; рабочая переменная: ct2 — текущая ширина импульса (Ti)
ct3	EQU 0x22              ; вспомогательная переменная

	org 0x00                ; вектор сброса — начало программы
	 goto start             ; переход на метку start
	;org 0x08              ; вектор прерываний

start 	
	; загрузка начальной ширины Ti = 20 (0x14)
	movlw 0x14             ; W = 0x14 (20 десятич) — начальная длительность импульса
	movwf ct2	           ; ct2 = 20 — сохраняем в рабочую переменную
	movwf CCPR1L           ; CCPR1L = 20 — младшая часть кода ширины для CCP (задаётся длительность)

	; переключение банк/загрузка PR2: период T = 40 -> PR2 = 39 (0x27)
	bsf STATUS,5           ; установить бит RP0
	movlw 0x27             ; W = 0x27 (39). PR2 хранит (T ? 1), а не само T. PR2 + 1 = 40 = PR2 = 39
	movwf PR2              ; PR2 = 39

	; настраиваем порт RC2 как выход
	bcf TRISC,2            ; TRISC<2>=0 -> RC2 как выход

	; конфигурация порта D
	movlw 0x08             ; W = 0x08
	movwf TRISD            ; TRISD = 0x08 -> на порту D бит3 как вход, остальные — выход
	bcf STATUS,5           ; сброс RP0 (возвращаем банк)

	bsf PORTD,2            ; установить PORTD<2> = 1
	bcf PORTD,2            ; сброс PORTD<2> = 0
	bsf PORTD,2            ; снова установить PORTD<2> = 1

	; настройка таймера TMR2 и предделителя/постделителя
	movlw 0x04             ; W = 0x04 -> в T2CON: TMR2ON = 1, предделителя = 1:1, постделителя = 1:1
	movwf T2CON            ; запись в T2CON
	; комментарий: бит2 = TMR2ON; биты 1..0 — предделителя; биты 6..3 — постделителя

	; включаем CCP1 в режим ШИМ (1100b -> 0x0C)
	movlw 0x0c             ; W = 0x0C -> CCP1M3..0 = 1100 = ШИМ режим
	movwf CCP1CON          ; включаем ШИМ-модуль

; Начало цикла уменьшения ширины с шагом 1 после каждых n периодов
m1	movlw 0x14            ; загрузить W = 0x14 (20) — повторно помещаем начальную ширину в ct2
	movwf ct2              ; ct2 = 20

m2	movf ct2,0            ; поместить ct2 в W для записи в регистр CCPR1L
	movwf CCPR1L           ; CCPR1L = ct2 — задаётся длительность импульса перед серией периодов

	movlw 0x04            ; W = 4 (n = 4 повторения)
	movwf ct1             ; ct1 = n — число повторов текущей ширины

loop clrwdt              ; clrwdt — сбрасываем сторожевой таймер
	btfsc PORTC,2         ; пропустить следующую инструкцию если бит в PORTC<2> = 0
	bsf  PORTD,0          ; если PORTC<2>] = 1 -> выполнить: установить PORTD<0] = 1
	btfss PORTC,2         ; пропустить следующую инструкцию если бит в PORTC<2> = 1 (skip if set)
	bcf  PORTD,0          ; если PORTC<2>] = 0 -> выполнить: сбросить PORTD<0] = 0
	decfsz ct1,1          ; декрементируем ct1; если результат != 0 -> не пропускаем следующую инструкцию
	goto loop             ; пока ct1 != 0 — повторяем цикл (повторяем n раз)

	;decfsz ct3,1        ; дополнительный счётчик не используется
	;goto loop

	decfsz ct2,1          ; уменьшаем ct2 (ширину) на 1, если ct2 после декр. = 0 — пропускаем следующий goto
	goto m2               ; если ct2 != 0 — возвращаемся к m2 и выдаём следующую серию из n периодов с новой шириной
	goto m1               ; если ct2 == 0 (дошли до нуля), возвращаемся к m1 и повторяем процесс с начальной шириной

	end                  